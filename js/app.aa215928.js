(function(s){function a(a){for(var t,l,c=a[0],o=a[1],r=a[2],i=0,h=[];i<c.length;i++)l=c[i],Object.prototype.hasOwnProperty.call(e,l)&&e[l]&&h.push(e[l][0]),e[l]=0;for(t in o)Object.prototype.hasOwnProperty.call(o,t)&&(s[t]=o[t]);d&&d(a);while(h.length)h.shift()();return p.push.apply(p,r||[]),n()}function n(){for(var s,a=0;a<p.length;a++){for(var n=p[a],t=!0,l=1;l<n.length;l++){var c=n[l];0!==e[c]&&(t=!1)}t&&(p.splice(a--,1),s=o(o.s=n[0]))}return s}var t={},l={app:0},e={app:0},p=[];function c(s){return o.p+"js/"+({}[s]||s)+"."+{"chunk-2d0c7964":"783327cf","chunk-b1aac4f0":"33dacb30"}[s]+".js"}function o(a){if(t[a])return t[a].exports;var n=t[a]={i:a,l:!1,exports:{}};return s[a].call(n.exports,n,n.exports,o),n.l=!0,n.exports}o.e=function(s){var a=[],n={"chunk-b1aac4f0":1};l[s]?a.push(l[s]):0!==l[s]&&n[s]&&a.push(l[s]=new Promise((function(a,n){for(var t="css/"+({}[s]||s)+"."+{"chunk-2d0c7964":"31d6cfe0","chunk-b1aac4f0":"93d83a61"}[s]+".css",e=o.p+t,p=document.getElementsByTagName("link"),c=0;c<p.length;c++){var r=p[c],i=r.getAttribute("data-href")||r.getAttribute("href");if("stylesheet"===r.rel&&(i===t||i===e))return a()}var h=document.getElementsByTagName("style");for(c=0;c<h.length;c++){r=h[c],i=r.getAttribute("data-href");if(i===t||i===e)return a()}var d=document.createElement("link");d.rel="stylesheet",d.type="text/css",d.onload=a,d.onerror=function(a){var t=a&&a.target&&a.target.src||e,p=new Error("Loading CSS chunk "+s+" failed.\n("+t+")");p.code="CSS_CHUNK_LOAD_FAILED",p.request=t,delete l[s],d.parentNode.removeChild(d),n(p)},d.href=e;var j=document.getElementsByTagName("head")[0];j.appendChild(d)})).then((function(){l[s]=0})));var t=e[s];if(0!==t)if(t)a.push(t[2]);else{var p=new Promise((function(a,n){t=e[s]=[a,n]}));a.push(t[2]=p);var r,i=document.createElement("script");i.charset="utf-8",i.timeout=120,o.nc&&i.setAttribute("nonce",o.nc),i.src=c(s);var h=new Error;r=function(a){i.onerror=i.onload=null,clearTimeout(d);var n=e[s];if(0!==n){if(n){var t=a&&("load"===a.type?"missing":a.type),l=a&&a.target&&a.target.src;h.message="Loading chunk "+s+" failed.\n("+t+": "+l+")",h.name="ChunkLoadError",h.type=t,h.request=l,n[1](h)}e[s]=void 0}};var d=setTimeout((function(){r({type:"timeout",target:i})}),12e4);i.onerror=i.onload=r,document.head.appendChild(i)}return Promise.all(a)},o.m=s,o.c=t,o.d=function(s,a,n){o.o(s,a)||Object.defineProperty(s,a,{enumerable:!0,get:n})},o.r=function(s){"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(s,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(s,"__esModule",{value:!0})},o.t=function(s,a){if(1&a&&(s=o(s)),8&a)return s;if(4&a&&"object"===typeof s&&s&&s.__esModule)return s;var n=Object.create(null);if(o.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:s}),2&a&&"string"!=typeof s)for(var t in s)o.d(n,t,function(a){return s[a]}.bind(null,t));return n},o.n=function(s){var a=s&&s.__esModule?function(){return s["default"]}:function(){return s};return o.d(a,"a",a),a},o.o=function(s,a){return Object.prototype.hasOwnProperty.call(s,a)},o.p="",o.oe=function(s){throw console.error(s),s};var r=window["webpackJsonp"]=window["webpackJsonp"]||[],i=r.push.bind(r);r.push=a,r=r.slice();for(var h=0;h<r.length;h++)a(r[h]);var d=i;p.push([0,"chunk-vendors"]),n()})({0:function(s,a,n){s.exports=n("cd49")},"0152":function(s,a,n){},"01af":function(s,a){!function(s){var a,n,t,l,e,p,c='<svg><symbol id="i-checkbox-indeterminate-fill" viewBox="0 0 1024 1024"><path d="M170.666667 128h682.666666a42.666667 42.666667 0 0 1 42.666667 42.666667v682.666666a42.666667 42.666667 0 0 1-42.666667 42.666667H170.666667a42.666667 42.666667 0 0 1-42.666667-42.666667V170.666667a42.666667 42.666667 0 0 1 42.666667-42.666667z m128 341.333333v85.333334h426.666666v-85.333334H298.666667z"  ></path></symbol><symbol id="i-checkbox" viewBox="0 0 1024 1024"><path d="M426.005333 725.994667l384-384-60.010667-61.994667-324.010667 324.010667-152-152-60.010667 60.010667zM810.005333 128q36.010667 0 60.992 26.005333t25.002667 60.010667l0 596.010667q0 34.005333-25.002667 60.010667t-60.992 26.005333l-596.010667 0q-36.010667 0-60.992-26.005333t-25.002667-60.010667l0-596.010667q0-34.005333 25.002667-60.010667t60.992-26.005333l596.010667 0z"  ></path></symbol><symbol id="i-check-box-outline-bl" viewBox="0 0 1024 1024"><path d="M810.666667 213.333333v597.333334H213.333333V213.333333h597.333334m0-85.333333H213.333333c-47.146667 0-85.333333 38.186667-85.333333 85.333333v597.333334c0 47.146667 38.186667 85.333333 85.333333 85.333333h597.333334c47.146667 0 85.333333-38.186667 85.333333-85.333333V213.333333c0-47.146667-38.186667-85.333333-85.333333-85.333333z"  ></path></symbol><symbol id="i-chevron_left_24px" viewBox="0 0 1024 1024"><path d="M597.333333 277.12l39.04 39.04-195.413333 195.84 195.413333 195.797333-39.04 39.082667L362.453333 512z"  ></path></symbol><symbol id="i-chevron_right_24px" viewBox="0 0 1024 1024"><path d="M426.666667 277.12L661.546667 512 426.666667 746.88l-39.082667-39.082667L582.997333 512l-195.413333-195.84z"  ></path></symbol><symbol id="i-expand_more_24px" viewBox="0 0 1024 1024"><path d="M707.797333 387.584l39.082667 39.082667L512 661.546667 277.12 426.666667l39.04-39.082667 195.84 195.413333z"  ></path></symbol><symbol id="i-expand_less_24px" viewBox="0 0 1024 1024"><path d="M512 362.453333L746.88 597.333333l-39.082667 39.04L512 440.96l-195.84 195.413333L277.12 597.333333z"  ></path></symbol><symbol id="i-search" viewBox="0 0 1024 1024"><path d="M702.626084 625.966635l-40.874943 0-15.347546-15.321964c51.106981-56.222489 81.776492-132.88245 81.776492-214.658941 0-183.989431-148.205437-332.193845-332.194868-332.193845S63.79035 211.997322 63.79035 395.986753c0 183.989431 148.205437 332.193845 332.193845 332.193845 81.776492 0 158.436452-30.66951 214.658941-81.775468l15.322987 15.346523 0 40.875966L881.500007 958.161503l76.660984-76.659961L702.626084 625.966635zM395.985218 625.966635c-127.766942 0-229.980905-102.21294-229.980905-229.980905 0-127.766942 102.213963-229.980905 229.980905-229.980905 127.766942 0 229.980905 102.213963 229.980905 229.980905C625.966123 523.753695 523.75216 625.966635 395.985218 625.966635z"  ></path></symbol><symbol id="i-document" viewBox="0 0 1024 1024"><path d="M29.924473 1024l211.821065 0L241.745538 67.153121c0-29.216699-14.608349-58.433397-36.520873-58.433397L66.445346 8.719724c-21.912524 0-36.520873 29.216699-36.520873 58.433397L29.924473 1024 29.924473 1024zM146.791268 929.04573 117.574569 929.04573l0-138.779318L146.791268 790.266411 146.791268 929.04573 146.791268 929.04573zM59.141172 213.236614c0-21.912524 14.608349-43.825048 29.216699-43.825048l80.345921 0c14.608349 0 29.216699 21.912524 29.216699 43.825048l0 73.041746c0 21.912524-14.608349 43.825048-29.216699 43.825048L88.35787 330.103408C73.749521 330.103408 59.141172 315.495059 59.141172 286.27836L59.141172 213.236614 59.141172 213.236614zM59.141172 213.236614"  ></path><path d="M314.787284 1024l211.821065 0L526.608349 67.153121c0-29.216699-14.608349-58.433397-36.520873-58.433397L351.308158 8.719724c-21.912524 0-36.520873 29.216699-36.520873 58.433397L314.787284 1024 314.787284 1024 314.787284 1024zM395.133206 929.04573 373.220682 929.04573l0-138.779318 21.912524 0L395.133206 929.04573 395.133206 929.04573zM468.174952 929.04573 438.958254 929.04573l0-138.779318 29.216699 0L468.174952 929.04573 468.174952 929.04573zM351.308158 213.236614c0-21.912524 14.608349-43.825048 29.216699-43.825048l80.345921 0c14.608349 0 29.216699 21.912524 29.216699 43.825048l0 73.041746c0 21.912524-14.608349 43.825048-29.216699 43.825048L380.524856 330.103408c-14.608349 0-29.216699-21.912524-29.216699-43.825048L351.308158 213.236614 351.308158 213.236614zM351.308158 213.236614"  ></path><path d="M818.775335 1024l204.51689-58.433397L745.733589 45.240597C738.429414 16.023898 716.51689-5.888626 694.604366 1.415549L563.129223 45.240597C548.520873 45.240597 533.912524 74.457296 548.520873 110.978169L818.775335 1024 818.775335 1024 818.775335 1024zM869.904558 907.133206l-21.912524 7.304175-36.520873-131.475144 21.912524-7.304175L869.904558 907.133206 869.904558 907.133206zM942.946304 892.524856l-29.216699 7.304175L877.208732 768.353887l29.216699-7.304175L942.946304 892.524856 942.946304 892.524856zM621.56262 235.149138c-7.304175-21.912524 0-43.825048 14.608349-51.129223l80.345921-21.912524c14.608349-7.304175 36.520873 7.304175 43.825048 36.520873l21.912524 73.041746c7.304175 21.912524 0 43.825048-14.608349 51.129223L687.300192 344.711758C672.691842 344.711758 650.779318 330.103408 643.475144 308.190884L621.56262 235.149138 621.56262 235.149138zM621.56262 235.149138"  ></path></symbol><symbol id="i-search1" viewBox="0 0 1056 1024"><path d="M48 1024h672c26.464 0 48-21.536 48-48V736c0-0.32-0.16-0.576-0.192-0.896 1.76-1.12 3.584-2.176 5.312-3.36l255.552 255.552a16 16 0 1 0 22.656-22.592l-253.216-253.216A207.328 207.328 0 0 0 864 560a207.808 207.808 0 0 0-96.192-175.104c0.032-0.32 0.192-0.576 0.192-0.896V304c0-0.544-0.256-0.992-0.288-1.504-0.064-0.736-0.256-1.376-0.416-2.08a15.616 15.616 0 0 0-2.88-6.112c-0.224-0.288-0.192-0.64-0.416-0.928l-256-288c-0.096-0.096-0.224-0.096-0.32-0.192a15.68 15.68 0 0 0-7.136-4.288c-0.608-0.192-1.152-0.256-1.792-0.352C497.824 0.384 496.96 0 496 0h-448C21.536 0 0 21.536 0 48v928c0 26.464 21.536 48 48 48zM832 560c0 97.056-78.976 176-176 176S480 657.056 480 560s78.976-176 176-176 176 78.944 176 176zM512 58.08L716.384 288H528c-7.04 0-16-13.44-16-24V58.08zM32 48a16 16 0 0 1 16-16H480v232c0 25.888 20.96 56 48 56H736v48.032A207.2 207.2 0 0 0 506.272 416H176a16 16 0 0 0 0 32h305.024a206.144 206.144 0 0 0-32.192 96H176a16 16 0 0 0 0 32h272.8a206.528 206.528 0 0 0 32.192 96H176a16 16 0 0 0 0 32h328c0.672 0 1.248-0.288 1.92-0.384a207.232 207.232 0 0 0 230.08 48.32V976a16 16 0 0 1-16 16h-672c-8.96 0-16-7.04-16-16v-928z"  ></path><path d="M176 320h192a16 16 0 0 0 0-32h-192a16 16 0 0 0 0 32zM176 832h416a16 16 0 0 0 0-32h-416a16 16 0 0 0 0 32z"  ></path></symbol><symbol id="i-search2" viewBox="0 0 1024 1024"><path d="M989.952 989.952c-37.12 37.12-97.216 37.12-134.336 0l-167.68-167.68c-68.992 44.16-150.464 70.528-238.4 70.528-244.864 0-443.328-198.464-443.328-443.264S204.672 6.208 449.536 6.208c244.8 0 443.264 198.464 443.264 443.328 0 87.936-26.368 169.472-70.528 238.4l167.616 167.616c37.12 37.184 37.12 97.28 0.064 134.4zM447.68 127.872c-176.576 0-319.808 143.232-319.808 319.808 0 176.64 143.168 319.744 319.808 319.744S767.424 624.256 767.424 447.68c0.064-176.576-143.104-319.808-319.744-319.808z"  ></path></symbol><symbol id="i-search3" viewBox="0 0 1024 1024"><path d="M881.3 899c-2.6 0-5.1-1-7.1-2.9L620.7 642.6c-3.9-3.9-3.9-10.2 0-14.1 3.9-3.9 10.2-3.9 14.1 0L888.3 882c3.9 3.9 3.9 10.2 0 14.1-1.9 1.9-4.4 2.9-7 2.9zM365.4 678.9c-79 0-153.3-30.8-209.2-86.7-55.9-55.9-86.7-130.2-86.7-209.1 0-79 30.8-153.3 86.7-209.1 55.9-55.9 130.2-86.7 209.1-86.7 86.4 0 168.3 37.6 224.6 103.3 3.6 4.2 3.1 10.5-1.1 14.1-4.2 3.6-10.5 3.1-14.1-1.1-52.5-61.2-128.8-96.3-209.4-96.3-152.1 0-275.8 123.7-275.8 275.8s123.8 275.8 275.9 275.8c152.1 0 275.8-123.7 275.8-275.8 0-23-2.8-45.9-8.4-67.8-1.4-5.4 1.9-10.8 7.2-12.1 5.4-1.4 10.8 1.9 12.1 7.2 6 23.6 9 48.1 9 72.8 0 79-30.8 153.3-86.7 209.2-55.7 55.7-130 86.5-209 86.5z"  ></path></symbol><symbol id="i-Documentpaperdraft" viewBox="0 0 1024 1024"><path d="M746.666667 85.333333H277.333333a106.773333 106.773333 0 0 0-106.666666 106.666667v640a106.773333 106.773333 0 0 0 106.666666 106.666667h469.333334a106.773333 106.773333 0 0 0 106.666666-106.666667V192a106.773333 106.773333 0 0 0-106.666666-106.666667z m64 746.666667a64.064 64.064 0 0 1-64 64H277.333333a64.064 64.064 0 0 1-64-64V192a64.064 64.064 0 0 1 64-64h469.333334a64.064 64.064 0 0 1 64 64z"  ></path><path d="M661.333333 256H362.666667a21.333333 21.333333 0 0 0 0 42.666667h298.666666a21.333333 21.333333 0 0 0 0-42.666667zM661.333333 384H362.666667a21.333333 21.333333 0 0 0 0 42.666667h298.666666a21.333333 21.333333 0 0 0 0-42.666667zM661.333333 512H362.666667a21.333333 21.333333 0 0 0 0 42.666667h298.666666a21.333333 21.333333 0 0 0 0-42.666667zM490.666667 640h-128a21.333333 21.333333 0 0 0 0 42.666667h128a21.333333 21.333333 0 0 0 0-42.666667z"  ></path></symbol><symbol id="i-document1" viewBox="0 0 1024 1024"><path d="M704.192 16H160a96 96 0 0 0-96 96v768a96 96 0 0 0 96 96h704c52.992 0 96-43.008 96-96v-576l-255.808-288z m-0.032 48.992L917.312 304H768a64 64 0 0 1-64-64l0.16-175.008zM928 880a64 64 0 0 1-64 64H160a64 64 0 0 1-64-64v-768a64 64 0 0 1 64-64h512.16L672 240a96 96 0 0 0 96 96h160v544z m-703.84-544H512v32H224.16v-32z m0 192H832v32H224.16v-32z m0 192.032H832v31.968H224.16v-31.968z"  ></path></symbol><symbol id="i-add" viewBox="0 0 1024 1024"><path d="M66.769262 448.402918l890.359149 0 0 127.194164L66.769262 575.597082 66.769262 448.402918z"  ></path><path d="M448.454082 66.820426l127.194164 0 0 890.359149L448.454082 957.179574 448.454082 66.820426z"  ></path></symbol><symbol id="i-add1" viewBox="0 0 1026 1024"><path d="M511.17819 1023.449171C232.458621 1030.059121-1.643784 782.185986 0.008703 508.974708 1.661191 236.865089 239.068571-1.64395 516.135653 0.008538c271.55879 1.652488 510.618658 239.059868 508.966171 516.12695C1023.449336 787.694278 787.694443 1031.711609 511.17819 1023.449171zM491.34834 97.505304c-195.544362-1.652488-418.630184 188.383583-394.944528 457.188227 15.974046 181.222803 190.03607 398.249504 459.942373 374.013019 181.773632-16.524876 396.046187-190.586899 371.809703-459.391544C911.080182 278.177278 730.408208 79.327941 491.34834 97.505304z"  ></path><path d="M560.201988 362.454144c0 27.541459 0.550829 55.082919 0 82.624378-0.550829 15.423217 5.508292 20.38068 20.38068 19.829851 55.082919-0.550829 110.165838 0 165.248757-0.550829 15.974046 0 22.583997 4.406634 21.482338 20.931509-1.101658 18.728192-1.101658 37.456385 0 55.633748 0.550829 14.872388-5.508292 19.279022-19.279022 18.728192-55.082919-0.550829-110.165838 0-165.248757-0.550829-16.524876 0-23.134826 4.957463-22.583997 22.033168 1.101658 54.53209 0 108.51335 0.550829 163.04544 0.550829 17.626534-6.059121 23.134826-22.583997 22.033168-17.075705-1.101658-34.702239-1.101658-51.777944 0-15.974046 1.101658-21.482338-4.957463-21.482338-21.482338 0.550829-53.430431-0.550829-107.411692 0.550829-160.842123 0.550829-20.38068-6.60995-25.888972-25.888972-25.338143-53.430431 1.101658-107.411692 0-160.842123 0.550829-14.872388 0-21.482338-4.406634-20.38068-19.829851 1.101658-18.728192 1.101658-37.456385 0-55.633748-1.101658-15.974046 5.508292-19.829851 20.38068-19.829851 54.53209 0.550829 108.51335-0.550829 163.04544 0.550829 17.626534 0.550829 24.236484-4.406634 23.685655-23.134826-1.101658-54.53209 0-108.51335-0.550829-163.04544 0-16.524876 5.508292-22.033168 21.482338-21.482338 17.626534 1.101658 35.803897 1.101658 53.430431 0 14.872388-0.550829 20.931509 4.406634 20.38068 19.829851C559.651159 306.269567 560.201988 334.361856 560.201988 362.454144z"  ></path></symbol><symbol id="i-info" viewBox="0 0 1024 1024"><path d="M512 0C229.23 0 0 229.23 0 512s229.23 512 512 512 512-229.23 512-512S794.77 0 512 0zM512 928c-229.75 0-416-186.25-416-416S282.25 96 512 96s416 186.25 416 416S741.75 928 512 928z"  ></path><path d="M537.64 343.452c47.074 0 83.266-37.528 83.266-78.072 0-32.46-20.832-60.878-62.496-60.878-54.816 0-82.178 44.618-82.178 77.11C475.144 320.132 498.152 343.452 537.64 343.452z"  ></path><path d="M533.162 728.934c-7.648 0-10.914-10.136-3.264-39.55l43.25-166.406c16.386-60.848 10.944-100.398-21.92-100.398-39.456 0-131.458 39.83-211.458 107.798l16.416 27.392c25.246-17.256 67.906-34.762 77.792-34.762 7.648 0 6.56 10.168 0 35.508l-37.746 158.292c-23.008 89.266 1.088 109.538 33.984 109.538 32.864 0 117.808-30.47 195.57-109.632l-18.656-25.34C575.354 716.714 543.05 728.934 533.162 728.934z"  ></path></symbol><symbol id="i-up" viewBox="0 0 1024 1024"><path d="M512 0C230.11236 0 0 230.11236 0 512c0 281.88764 230.11236 512 512 512 281.88764 0 512-230.11236 512-512C1024 230.11236 793.88764 0 512 0M241.617978 207.101124c0-17.258427 11.505618-28.764045 28.764045-28.764045l471.730337 0c17.258427 0 28.764045 11.505618 28.764045 28.764045l0 51.775281c0 17.258427-11.505618 28.764045-28.764045 28.764045L270.382022 287.640449c-17.258427 0-28.764045-11.505618-28.764045-28.764045L241.617978 207.101124zM638.561798 632.808989l0 247.370787L391.191011 880.179775 391.191011 632.808989 235.865169 632.808989l270.382022-299.146067 270.382022 299.146067L638.561798 632.808989z"  ></path></symbol><symbol id="i-info1" viewBox="0 0 1024 1024"><path d="M511.131213 105.299231c-247.079328 0-447.37105 163.902954-447.37105 366.030487 0 99.163487 48.374754 188.963723 126.617769 254.863618l-45.277206 192.507432 240.525052-96.184643c39.856753 9.481955 81.897242 14.84408 125.506459 14.84408 247.078305 0 447.37105-163.851788 447.37105-366.030487C958.502263 269.201162 758.209518 105.299231 511.131213 105.299231M511.131213 796.690948c-38.762839 0-77.806063-4.626367-116.052133-13.762445-3.120061-0.733711-6.296403-1.110287-9.454326-1.110287-5.143137 0-10.285251 0.972141-15.092743 2.918469l-167.922501 67.170842 27.365254-116.400057c3.536546-14.923898-1.666966-30.541597-13.384845-40.402175-72.323189-60.905138-112.159476-140.399657-112.159476-223.774553 0-179.391716 182.459588-325.361229 406.700769-325.361229 224.260623 0 406.700769 145.969513 406.700769 325.361229C917.831982 650.731668 735.391836 796.690948 511.131213 796.690948"  ></path><path d="M663.449317 383.915833l-302.898635 0c-13.226233 0-24.047696-10.821463-24.047696-24.047696l0 0c0-13.226233 10.821463-24.047696 24.047696-24.047696l302.898635 0c13.226233 0 24.047696 10.821463 24.047696 24.047696l0 0C687.497013 373.09437 676.67555 383.915833 663.449317 383.915833z"  ></path><path d="M663.449317 637.69577l-302.898635 0c-13.226233 0-24.047696-10.821463-24.047696-24.047696l0 0c0-13.226233 10.821463-24.047696 24.047696-24.047696l302.898635 0c13.226233 0 24.047696 10.821463 24.047696 24.047696l0 0C687.497013 626.874307 676.67555 637.69577 663.449317 637.69577z"  ></path><path d="M788.292674 512l-552.585347 0c-13.226233 0-24.047696-10.821463-24.047696-24.047696l0 0c0-13.226233 10.821463-24.047696 24.047696-24.047696l552.585347 0c13.226233 0 24.047696 10.821463 24.047696 24.047696l0 0C812.340369 501.178537 801.518906 512 788.292674 512z"  ></path></symbol><symbol id="i-up1" viewBox="0 0 1024 1024"><path d="M176.442548 161.367201l671.114904 0 0 87.866187-671.114904 0 0-87.866187Z"  ></path><path d="M562.948369 862.632799 463.180108 862.632799 463.180108 427.634544 320.117808 569.036018 256.157078 505.075287 512 249.232364 767.841899 505.075287 703.882192 569.036018 561.41341 430.704462Z"  ></path></symbol><symbol id="i-trash" viewBox="0 0 1024 1024"><path d="M402.285714 786.285714V384q0-8-5.142857-13.142857t-13.142857-5.142857h-36.571429q-8 0-13.142857 5.142857t-5.142857 13.142857v402.285714q0 8 5.142857 13.142857t13.142857 5.142858h36.571429q8 0 13.142857-5.142858t5.142857-13.142857z m146.285715 0V384q0-8-5.142858-13.142857t-13.142857-5.142857h-36.571428q-8 0-13.142857 5.142857t-5.142858 13.142857v402.285714q0 8 5.142858 13.142857t13.142857 5.142858h36.571428q8 0 13.142857-5.142858t5.142858-13.142857z m146.285714 0V384q0-8-5.142857-13.142857t-13.142857-5.142857h-36.571429q-8 0-13.142857 5.142857t-5.142857 13.142857v402.285714q0 8 5.142857 13.142857t13.142857 5.142858h36.571429q8 0 13.142857-5.142858t5.142857-13.142857zM384 219.428571h256l-27.428571-66.857142q-4-5.142857-9.714286-6.285715H421.714286q-5.714286 1.142857-9.714286 6.285715z m530.285714 18.285715v36.571428q0 8-5.142857 13.142857t-13.142857 5.142858h-54.857143v541.714285q0 47.428571-26.857143 82t-64.571428 34.571429H274.285714q-37.714286 0-64.571428-33.428572T182.857143 836.571429V292.571429H128q-8 0-13.142857-5.142858t-5.142857-13.142857v-36.571428q0-8 5.142857-13.142857t13.142857-5.142858h176.571429l40-95.428571q8.571429-21.142857 30.857142-36t45.142858-14.857143h182.857142q22.857143 0 45.142858 14.857143t30.857142 36l40 95.428571h176.571429q8 0 13.142857 5.142858t5.142857 13.142857z"  ></path></symbol><symbol id="i-error" viewBox="0 0 1024 1024"><path d="M512 0C229.23 0 0 229.23 0 512s229.23 512 512 512 512-229.23 512-512S794.77 0 512 0z m169.71 568.57a80 80 0 0 1-113.14 113.14L512 625.14l-56.57 56.57a80 80 0 1 1-113.14-113.14L398.86 512l-56.57-56.57a80 80 0 1 1 113.14-113.14L512 398.86l56.57-56.57a80 80 0 1 1 113.14 113.14L625.14 512z"  ></path></symbol><symbol id="i-wancheng" viewBox="0 0 1024 1024"><path d="M512 976.7424c-256.67072 0-464.7424-208.07168-464.7424-464.73728C47.2576 255.32928 255.32928 47.2576 512 47.2576s464.7424 208.07168 464.7424 464.7424c0 256.67072-208.07168 464.7424-464.7424 464.7424z m225.41312-754.26816c-161.65888 106.2144-264.18176 424.86272-264.18176 424.86272L410.14272 490.54208l-130.11968 101.16096c55.20896 25.28768 134.0672 106.2144 201.09312 212.4288 47.31392-111.26784 193.20832-338.87744 264.18176-359.11168-27.5968-80.9216-11.82208-146.67776-7.8848-222.54592z m0 0"  ></path></symbol><symbol id="i-warning" viewBox="0 0 1024 1024"><path d="M512 64q190.016 4.992 316.512 131.488T960 512q-4.992 190.016-131.488 316.512T512 960q-190.016-4.992-316.512-131.488T64 512q4.992-190.016 131.488-316.512T512 64z m0 192q-26.016 0-43.008 19.008T453.984 320l23.008 256q2.016 14.016 11.488 22.496t23.488 8.512 23.488-8.512 11.488-22.496l23.008-256q2.016-26.016-15.008-44.992T511.936 256z m0 512q22.016-0.992 36.512-15.008t14.496-36-14.496-36.512T512 665.984t-36.512 14.496-14.496 36.512 14.496 36T512 768z"  ></path></symbol></svg>',o=(o=document.getElementsByTagName("script"))[o.length-1].getAttribute("data-injectcss");if(o&&!s.__iconfont__svg__cssinject__){s.__iconfont__svg__cssinject__=!0;try{document.write("<style>.svgfont {display: inline-block;width: 1em;height: 1em;fill: currentColor;vertical-align: -0.1em;font-size:16px;}</style>")}catch(s){console&&console.log(s)}}function r(){e||(e=!0,t())}a=function(){var s,a,n,t;(t=document.createElement("div")).innerHTML=c,c=null,(n=t.getElementsByTagName("svg")[0])&&(n.setAttribute("aria-hidden","true"),n.style.position="absolute",n.style.width=0,n.style.height=0,n.style.overflow="hidden",s=n,(a=document.body).firstChild?(t=s,(n=a.firstChild).parentNode.insertBefore(t,n)):a.appendChild(s))},document.addEventListener?~["complete","loaded","interactive"].indexOf(document.readyState)?setTimeout(a,0):(n=function(){document.removeEventListener("DOMContentLoaded",n,!1),a()},document.addEventListener("DOMContentLoaded",n,!1)):document.attachEvent&&(t=a,l=s.document,e=!1,(p=function(){try{l.documentElement.doScroll("left")}catch(s){return void setTimeout(p,50)}r()})(),l.onreadystatechange=function(){"complete"==l.readyState&&(l.onreadystatechange=null,r())})}(window)},"0273":function(s,a,n){"use strict";n.r(a),n.d(a,"install",(function(){return l}));n("b0c0");var t=n("fc61"),l=function(s){s.component(t["a"].name,t["a"])};a["default"]={install:l}},"03e3":function(s,a,n){},"04f5":function(s,a,n){"use strict";n.r(a);var t=n("7a23"),l={class:"markdown-body"},e=Object(t["j"])('<html><head></head><body><h1>git fetch</h1><p>同步远程仓库的分支信息到本地，同步完之后本地与远端的commit树保持一致，但工作区状态不变。</p><h2>将合并请求映射为本地分支</h2><p>映射完了可以配合 VSCode 的版本管理来 Review 代码，比网页版舒服</p><h3>Github的PR</h3><pre><code class="language-sh"><span class="hljs-comment"># remote_name 远程仓库名称 pr_id PR的ID local_branch_name 要映射的本地分支</span>\ngit fetch <span class="hljs-variable">$remote_name</span> pull/<span class="hljs-variable">$pr_id</span>/head:<span class="hljs-variable">$local_branch_name</span>\n</code></pre><p>登陆为 MAC alias</p><pre><code class="language-zsh"><span class="hljs-comment">#  git checkout $(git_main_branch); 切到主分支</span>\n<span class="hljs-comment">#  if [ `git branch --list pr-$1_$2` ]; then git branch -D pr-$1_$2; fi; ❗️❗️❗️❗️❗️❗️❗️❗️Warning：如果分支已存在会强制删除，不需要可以删除</span>\n<span class="hljs-comment">#  git fetch $1 pull/$2/head:pr-$1_$2; 映射PR到该分支</span>\n<span class="hljs-comment">#  git checkout pr-$1_$2 切换到该分支</span>\n<span class="hljs-built_in">alias</span> git-pr=<span class="hljs-string">&#39;cr(){ git checkout $(git_main_branch);if [ `git branch --list pr-$1_$2` ]; then git branch -D pr-$1_$2; fi; git fetch $1 pull/$2/head:pr-$1_$2; git checkout pr-$1_$2 };cr&#39;</span>\n</code></pre><h3>GitLab的MR</h3><pre><code class="language-sh"><span class="hljs-comment"># remote_name 远程仓库名称 mr_id MR的ID local_branch_name 要映射的本地分支</span>\ngit fetch <span class="hljs-variable">$remote_name</span> merge_requests/<span class="hljs-variable">$mr_id</span>/head:<span class="hljs-variable">$local_branch_name</span>\n</code></pre><p>登陆为 MAC alias</p><pre><code class="language-zsh"><span class="hljs-built_in">alias</span> git-pr=<span class="hljs-string">&#39;cr(){ git checkout $(git_main_branch);if [ `git branch --list mr-$1_$2` ]; then git branch -D mr-$1_$2; fi; git fetch $1 merge_requests/$2/head:mr-$1_$2; git checkout mr-$1_$2 };cr&#39;</span>\n</code></pre></body></html>',1),p=[e];function c(s,a){return Object(t["z"])(),Object(t["h"])("section",l,p)}var o=n("6b0d"),r=n.n(o);const i={},h=r()(i,[["render",c]]);a["default"]=h},"0529":function(s,a,n){"use strict";n.r(a);var t=n("7a23"),l={class:"markdown-body"},e=Object(t["j"])('<html><head></head><body><h1>JS 数组扩展方法实现</h1><h2>forEach</h2><p>forEach 方法的特性：</p><ol><li>对数组进行遍历，该方法接收两个参数 <ul><li><code>callback: (currentValue, index, array) =&gt; void</code>，遍历的回调</li><li><code>thisArg</code>，用于指定 callback 的 this 指向</li></ul></li></ol><pre><code class="language-js"><span class="hljs-built_in">Array</span>.prototype.myForEach = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">callback, thisArg</span>) </span>{\n\t<span class="hljs-keyword">var</span> _arr = <span class="hljs-built_in">this</span>, <span class="hljs-comment">// 获取数组本身</span>\n\t\t_len = _arr.length,\n\t\t_index = <span class="hljs-number">0</span>;\n\t<span class="hljs-keyword">if</span> (thisArg == <span class="hljs-literal">null</span>) thisArg = <span class="hljs-built_in">window</span>;\n\t<span class="hljs-keyword">for</span> (; _index &lt; _len; _index++) {\n\t\tcallback.call(thisArg, _arr[_index], _index, _arr);\n\t}\n};\n</code></pre><h2>map</h2><ol><li>对数组进行遍历，并<code>将 callback 返回的值组成一个新的数组返回</code><ul><li><code>callback: (currentValue, index, array) =&gt; newValue</code></li><li><code>thisArg</code></li></ul></li></ol><pre><code class="language-js"><span class="hljs-built_in">Array</span>.prototype.myMap = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">callback, thisArg</span>) </span>{\n\t<span class="hljs-keyword">var</span> _arr = <span class="hljs-built_in">this</span>,\n\t\t_len = _arr.length,\n\t\t_ctx = thisArg || <span class="hljs-built_in">window</span>,\n\t\t_newArr = []; <span class="hljs-comment">// 存放callback返回值的数组</span>\n\t<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; _len; i++) {\n\t\t_newArr.push(callback.call(_ctx, _arr[i], i, _arr));\n\t}\n\t<span class="hljs-keyword">return</span> _newArr;\n};\n</code></pre><h2>filter</h2><ol><li>对数组进行遍历，依次执行回调函数，若回调函数返回 true（truely 值） 则筛选通过，<code>将筛选通过的值组成新数组并返回</code><ul><li><code>callback: (currentValue, index, array) =&gt; newValue</code></li><li><code>thisArg</code></li></ul></li></ol><pre><code class="language-js"><span class="hljs-built_in">Array</span>.prototype.myFilter = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">callback, thisArg</span>) </span>{\n\t<span class="hljs-keyword">var</span> _arr = <span class="hljs-built_in">this</span>,\n\t\t_len = _arr.length,\n\t\t_ctx = thisArg || <span class="hljs-built_in">window</span>,\n\t\t_newArr = []; <span class="hljs-comment">// 存放筛选结果</span>\n\t<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; _len; i++) {\n\t\t<span class="hljs-keyword">if</span> (callback.call(_ctx, _arr[i], i, _arr)) _newArr.push(_arr[i]);\n\t}\n\t<span class="hljs-keyword">return</span> _newArr;\n};\n</code></pre><h2>find</h2><pre><code class="language-js"><span class="hljs-built_in">Array</span>.prototype.myFind = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">callback, thisArg</span>) </span>{\n\t<span class="hljs-keyword">var</span> _arr = <span class="hljs-built_in">this</span>,\n\t\t_len = _arr.length,\n\t\t_ctx = thisArg || <span class="hljs-built_in">window</span>;\n\t<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; _len; i++) {\n\t\t<span class="hljs-keyword">if</span> (callback.call(_ctx, _arr[i], i, _arr)) <span class="hljs-keyword">return</span> _arr[i];\n\t}\n};\n</code></pre><h2>every</h2><ol><li>对数组进行遍历，依次执行回调函数，<code>有任意一次回调返回 false（falsely 值）则返回 false，否则 true</code><ul><li><code>callback: (currentValue, index, array) =&gt; newValue</code></li><li><code>thisArg</code></li></ul></li><li>只要有回调返回 false 立即中断循环并返回结果</li></ol><pre><code class="language-js"><span class="hljs-built_in">Array</span>.prototype.myEvery = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">callback, thisArg</span>) </span>{\n\t<span class="hljs-keyword">var</span> _arr = <span class="hljs-built_in">this</span>,\n\t\t_len = _arr.length,\n\t\t_ctx = thisArg || <span class="hljs-built_in">window</span>;\n\t<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; _len; i++) {\n\t\t<span class="hljs-comment">// 有判断不通过的直接返回false，否则返回true</span>\n\t\t<span class="hljs-keyword">if</span> (!callback.call(_ctx, _arr[i], i, _arr)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;\n\t}\n\t<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;\n};\n</code></pre><h2>some</h2><ol><li>对数组进行遍历，依次执行回调函数，<code>有任意一次回调返回 true（truely 值）则返回 true，否则 false</code><ul><li><code>callback: (currentValue, index, array) =&gt; newValue</code></li><li><code>thisArg</code></li></ul></li><li>只要有回调返回 true 立即中断循环并返回结果</li></ol><pre><code class="language-js"><span class="hljs-built_in">Array</span>.prototype.mySome = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">callback, thisArg</span>) </span>{\n\t<span class="hljs-keyword">var</span> _arr = <span class="hljs-built_in">this</span>,\n\t\t_len = _arr.length,\n\t\t_ctx = thisArg || <span class="hljs-built_in">window</span>;\n\t<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; _len; i++) {\n\t\t<span class="hljs-comment">// 有判断通过的直接返回</span>\n\t\t<span class="hljs-keyword">if</span> (callback.call(_ctx, _arr[i], i, _arr)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;\n\t}\n\t<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;\n};\n</code></pre><h2>reduce</h2><ol><li>对数组进行遍历，依次执行回调函数，并在各个回调函数之间传递一个变量 accumulator，也是 reduce 的返回值 <ul><li><code>callback: (accumulator, currentValue, index, array) =&gt; newValue</code></li><li><code>initialValue</code>，可选，</li></ul></li><li>若无初始值则会取数组第一个为初始值同时跳过对其的回调（因此目标数组长度必须大于 1，在没有初始值的空数组上调用 reduce 将报错）。</li></ol><pre><code class="language-js"><span class="hljs-built_in">Array</span>.prototype.myReduce = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">callback</span>) </span>{\n\t<span class="hljs-keyword">var</span> _arr = <span class="hljs-built_in">this</span>,\n\t\t_len = _arr.length,\n\t\t<span class="hljs-comment">// 根据实参长度判断是否需要取目标数组第一个用作初始值</span>\n\t\t_acc = <span class="hljs-built_in">arguments</span>.length &gt; <span class="hljs-number">1</span> ? <span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>] : _arr[<span class="hljs-number">0</span>],\n\t\ti = <span class="hljs-built_in">arguments</span>.length &gt; <span class="hljs-number">1</span> ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>;\n\t<span class="hljs-keyword">for</span> (; i &lt; _len; i++) {\n\t\t_acc = callback(_acc, _arr[i], i, _arr);\n\t}\n\t<span class="hljs-keyword">return</span> _acc;\n};\n</code></pre></body></html>',1),p=[e];function c(s,a){return Object(t["z"])(),Object(t["h"])("section",l,p)}var o=n("6b0d"),r=n.n(o);const i={},h=r()(i,[["render",c]]);a["default"]=h},"08f3":function(s,a,n){s.exports=n.p+"img/线性渐变.48bfa1fa.png"},"0997":function(s,a,n){"use strict";n.r(a);var t=n("7a23"),l={class:"markdown-body"},e=Object(t["j"])('<html><head></head><body><h1>Python 迭代对象</h1><h2>迭代器实现实例</h2><pre><code class="language-python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IterTest</span>:</span>\n    __data = {}\n\n    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, dataList</span>):</span>\n        <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(dataList)):\n            self.__data[key] = dataList[key]\n\n    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__iter__</span>(<span class="hljs-params">self</span>):</span>\n        <span class="hljs-keyword">return</span> IterTestIterator(self.__data)\n\n\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IterTestIterator</span>:</span>\n    __iterCount = -<span class="hljs-number">1</span>\n\n    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, dataSource</span>):</span>\n        self.__data = dataSource\n\n    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__next__</span>(<span class="hljs-params">self</span>):</span>\n        <span class="hljs-keyword">if</span> self.__iterCount &lt; <span class="hljs-built_in">len</span>(self.__data) - <span class="hljs-number">1</span>:\n            self.__iterCount += <span class="hljs-number">1</span>\n            <span class="hljs-keyword">return</span> self.__data[self.__iterCount]\n        <span class="hljs-keyword">else</span>:\n            <span class="hljs-keyword">raise</span> StopIteration\n\nt = IterTest(<span class="hljs-built_in">range</span>(<span class="hljs-number">30</span>,<span class="hljs-number">0</span>,-<span class="hljs-number">2</span>))\n\n<span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> t:\n    <span class="hljs-built_in">print</span>(m)\n</code></pre><p>类<code>__iter__()</code>方法作用为对 iter()方法做出响应，即返回一个可迭代（含有<code>__next__()</code>）方法的对象（迭代器），在迭代器的<code>__next__()</code>方法中可以自定义对对象的迭代方式，需要在特定状态抛出<code>StopIteration</code>异常，否则迭代将一直持续下去。</p><h2>yeild 语句</h2><p>生成器，自动返回迭代器，迭代器的每一次<code>next</code>将会执行至一个<code>yeild</code>，<code>yeild</code>返回输出并记录当前执行位置，下一次<code>next</code>从中断处继续执行。</p><h3>yeild 实例，利用迭代器特性读取大文件</h3><p>迭代器由于其即用即销毁的特性，方便管理内存</p><pre><code class="language-python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read_in_chunks</span>(<span class="hljs-params">filePath, chunk_size=<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span></span>):</span>\n    <span class="hljs-string">&quot;&quot;&quot;\n    Lazy function (generator) to read a file piece by piece.\n    Default chunk size: 1M\n    You can set your own chunk size\n    &quot;&quot;&quot;</span>\n    file_object = <span class="hljs-built_in">open</span>(filePath)\n    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:\n        chunk_data = file_object.read(chunk_size)\n        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> chunk_data:\n            <span class="hljs-keyword">break</span>\n        <span class="hljs-keyword">yield</span> chunk_data\n</code></pre><p>同时 python 的<code>with open() as file</code>将自动使用迭代器进行管理，可以直接使用。</p></body></html>',1),p=[e];function c(s,a){return Object(t["z"])(),Object(t["h"])("section",l,p)}var o=n("6b0d"),r=n.n(o);const i={},h=r()(i,[["render",c]]);a["default"]=h},"0a76":function(s,a,n){"use strict";n.r(a),n.d(a,"$popup",(function(){return k})),n.d(a,"install",(function(){return w}));n("b0c0");var t=n("7a23");function l(s,a,n,l,e,p){var c=Object(t["H"])("ShutBMask"),o=Object(t["H"])("ShutBWrapper"),r=Object(t["H"])("ShutBTransition");return Object(t["z"])(),Object(t["f"])(r,{name:"fade",duration:s.duration,mode:"out-in"},{default:Object(t["Q"])((function(){return[Object(t["R"])(Object(t["l"])(o,{class:"shut-b-popup",style:Object(t["t"])({zIndex:s.zIndex})},{default:Object(t["Q"])((function(){return[Object(t["l"])(c,{visible:!0,backgroundColor:s.backgroundColor,opacity:s.opacity},null,8,["backgroundColor","opacity"]),s.$slots.default&&!s.component?(Object(t["z"])(),Object(t["h"])("div",{key:0,class:"shut-b-popup__content",style:Object(t["t"])({zIndex:s.zIndex+1})},[Object(t["G"])(s.$slots,"default",{},void 0,!0)],4)):Object(t["g"])("",!0),s.component?(Object(t["z"])(),Object(t["h"])("div",{key:1,class:"shut-b-popup__content",ref:"componentRef",style:Object(t["t"])({zIndex:s.zIndex+1})},null,4)):Object(t["g"])("",!0)]})),_:3},8,["style"]),[[t["N"],s.visible]])]})),_:3},8,["duration"])}n("d3b7"),n("a9e3");var e=n("fc61"),p=n("1fa9"),c=n("4ce0"),o=n("5fd2"),r=function(s){var a=Object(t["E"])(""),n=function(){if(s.component.name){var n=Object(t["e"])(s.component,s.componentOpt);return Object(t["r"])((function(){n.mount(a.value)})),Object(t["v"])((function(){n.unmount()})),n}};return{componentRef:a,createIntance:n}},i=function(s,a){var n=r(s),l=n.componentRef,e=n.createIntance,p=Object(t["E"])(!1);Object(t["P"])((function(){p.value&&s.component&&e()})),Object(t["O"])(s,(function(){var a=s.modelValue;p.value=a}));var c=function(){return new Promise((function(s){p.value=!1,a("update:modelValue",!1),s(null)}))},o=function(){return new Promise((function(n){p.value=!0,a("update:modelValue",!0),s.visibleTimer>0&&setTimeout((function(){c()}),s.visibleTimer),n(null)}))};return{visible:p,show:o,hide:c,componentRef:l}},h=function(){var s=Object(t["E"])(Object(o["c"])());return{zIndex:s}},d=Object(t["m"])({name:"ShutBPopup",setup:function(s,a){var n=a.emit,t=i(s,n),l=t.visible,e=t.show,p=t.hide,c=t.componentRef,o=h(),r=o.zIndex;return{visible:l,show:e,hide:p,componentRef:c,zIndex:r}},props:{modelValue:{type:Boolean,description:"从组件外控制组件显隐"},visibleTimer:{type:Number,default:-1},component:{type:Object,default:function(){return{}}},componentOpt:{type:Object,default:function(){return{}}},backgroundColor:{type:String,default:"black"},opacity:{type:Number,default:.2},duration:{type:Number,default:300}},components:{ShutBWrapper:e["a"],ShutBMask:p["a"],ShutBTransition:c["a"]},emits:{"update:modelValue":function(){return!0}}}),j=(n("47c0"),n("6b0d")),u=n.n(j);const m=u()(d,[["render",l],["__scopeId","data-v-01642412"]]);var b=m,g=n("5530"),f=function(s,a,n){var l=document.createElement("div");s.appendChild(l);var e=Object(t["e"])(a,n),p=e.mount(l);return{inst:p,unmount:function(){e.unmount(),s.removeChild(l)}}},y=function(s,a){return f(document.body,s,a)},A={duration:300,opacity:.3};function k(s){var a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:15e3,n=y(b,Object(g["a"])(Object(g["a"])({},A),s)),l=n.inst,e=n.unmount;Object(t["r"])((function(){l.show()}));var p=-1;return{show:function(){l.show().then((function(){clearTimeout(p)}))},hide:function(){l.hide().then((function(){p=setTimeout((function(){e()}),a)}))}}}var w=function(s){s.component(b.name,b)};a["default"]={install:w}},"0c37":function(s,a,n){"use strict";n.r(a);var t=n("7a23"),l={class:"markdown-body"},e=Object(t["j"])('<html><head></head><body><h1>JS 闭包</h1><h2>概念</h2><ol><li>垃圾回收器，JS 引擎会不定时检索内存，查看<code>对象和变量的被引用情况</code>，若某个对象或变量在内存中<code>没有被引用</code>，该内存区域就会被回收。</li><li>作用域链，简单理解，一对大括号<code>{}</code>内部的内容即为一个作用域，大括号的嵌套即构成了 JS 的作用域链，在多重大括号时，在内部引用变量将根据作用域链往外进行查找。JS 采用词法作用域，也叫静态作用域，函数的作用域链与定义的位置相关。</li></ol><pre><code class="language-js"><span class="hljs-keyword">let</span> a1 = <span class="hljs-number">1</span>;\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"></span>) </span>{\n\t<span class="hljs-keyword">let</span> a2 = <span class="hljs-number">2</span>;\n\t<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f2</span>(<span class="hljs-params"></span>) </span>{\n\t\t<span class="hljs-keyword">let</span> a3 = <span class="hljs-number">3</span>;\n\t\t<span class="hljs-keyword">let</span> a1 = <span class="hljs-number">11</span>;\n\t\t<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f3</span>(<span class="hljs-params"></span>) </span>{\n\t\t\t<span class="hljs-keyword">let</span> a4 = <span class="hljs-number">4</span>;\n\t\t\t<span class="hljs-keyword">return</span> { a1, a2, a3, a4 };\n\t\t};\n\t};\n}\n<span class="hljs-built_in">console</span>.log(f1()()());\n<span class="hljs-built_in">console</span>.log(a1);\n<span class="hljs-comment">/* 输出\n{ a1: 11, a2: 2, a3: 3, a4: 4 }\n1\n*/</span>\n</code></pre><pre><code class="language-js"><span class="hljs-comment">//JS采用词法作用域，作用域链在词法分析时确定</span>\n<span class="hljs-keyword">let</span> value = <span class="hljs-number">1</span>;\n\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{\n\t<span class="hljs-built_in">console</span>.log(value);\n}\n\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>{\n\t<span class="hljs-keyword">let</span> value = <span class="hljs-number">2</span>;\n\tfoo();\n}\n\nbar();\n</code></pre><ol start="3"><li>内部函数，我们可以在 JS 函数的内部声明内部函数，内部函数可以访问（即引用，使用）内部函数的作用域及其内部变量和对象，反之外部函数不可直接访问内部函数的信息。</li></ol><pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{\n\t<span class="hljs-keyword">let</span> value = <span class="hljs-string">&#39;data&#39;</span>;\n\t<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handler</span>(<span class="hljs-params">operate</span>) </span>{\n\t\toperate(value);\n\t};\n}\n\n<span class="hljs-keyword">let</span> valueHandler = foo();\n\nvalueHandler(<span class="hljs-built_in">console</span>.log);\n<span class="hljs-comment">/*输出\ndata\n*/</span>\n</code></pre><p>闭包即为闭包函数块+定义闭包函数块时的作用域链</p><p>访问了外部函数的内部函数<code>handler</code>称为<code>闭包函数</code>，通过闭包特性，我们可以将某个变量<code>value</code>声明为函数内部变量，同时借由闭包特性来获取它的<code>handler</code>函数。外部函数<code>foo</code>执行完毕时本该由垃圾回收器回收，但由于你保留了闭包函数<code>handler</code>的引用，而闭包函数又是对内部变量<code>value</code>的唯一引用（或者说的唯一的访问途径），因此该变量不会被回收，且已经拥有了<code>“私有”</code>特性，即除你的闭包函数<code>handler</code>外无法通过别的手段访问或修改。</p><h2>优缺点</h2><ul><li>优点： <ol><li>可以使得某个变量不被垃圾回收器回收</li><li>可以避免全局变量过多导致变量名污染，将部分变量名以闭包的形式挂在函数作用域里。</li><li>可以实现私有变量。</li></ol></li><li>缺点： <ol><li>使用不当会导致内存泄露，每次生成的闭包函数均有独立且完全相同的作用域链以及内容，占用大量内存。</li></ol></li></ul></body></html>',1),p=[e];function c(s,a){return Object(t["z"])(),Object(t["h"])("section",l,p)}var o=n("6b0d"),r=n.n(o);const i={},h=r()(i,[["render",c]]);a["default"]=h},"0dbe":function(s,a,n){},"0ffa":function(s,a,n){"use strict";n.r(a);var t=n("7a23"),l={class:"markdown-body"},e=Object(t["j"])("<html><head></head><body><h1>react 生命周期</h1><h2>componentWillMount</h2><p>在渲染前调用,在客户端也在服务端。</p><h2>componentDidMount</h2><p>在第一次渲染后调用，只在客户端。之后组件已经生成了对应的 DOM 结构，可以通过 this.getDOMNode()来进行访问。 如果你想和其他 JavaScript 框架一起使用，可以在这个方法中调用 setTimeout, setInterval 或者发送 AJAX 请求等操作(防止异步操作阻塞 UI)。</p><h2>componentWillReceiveProps</h2><p>在组件接收到一个新的 prop (更新后)时被调用。这个方法在初始化 render 时不会被调用。</p><h2>shouldComponentUpdate</h2><p>返回一个布尔值。在组件接收到新的 props 或者 state 时被调用。在初始化时或者使用 forceUpdate 时不被调用。</p><p>可以在你确认不需要更新组件时使用。</p><h2>componentWillUpdate</h2><p>在组件接收到新的 props 或者 state 但还没有 render 时被调用。在初始化时不会被调用。</p><h2>componentDidUpdate</h2><p>在组件完成更新后立即调用。在初始化时不会被调用。</p><h2>componentWillUnmount</h2><p>在组件从 DOM 中移除之前立刻被调用。</p></body></html>",1),p=[e];function c(s,a){return Object(t["z"])(),Object(t["h"])("section",l,p)}var o=n("6b0d"),r=n.n(o);const i={},h=r()(i,[["render",c]]);a["default"]=h},"10bd":function(s,a,n){"use strict";n("83c8")},"11ac":function(s,a,n){},"13bc":function(s,a,n){"use strict";n.r(a);var t=n("7a23"),l={class:"markdown-body"},e=Object(t["i"])("html",null,[Object(t["i"])("head"),Object(t["i"])("body",null,[Object(t["i"])("h1",null,"Vue 中绑定 key 的作用"),Object(t["i"])("p",null,[Object(t["i"])("code",null,"key是给每一个vnode的唯一id,可以依靠key,更准确, 更快的拿到oldVnode中对应的vnode节点。")]),Object(t["i"])("p",null,[Object(t["k"])("vue 和 react 都是采用 diff 算法来对比新旧虚拟节点，从而更新节点。在 vue 的 diff 函数中交叉对比中，当新节点跟旧节点头尾交叉对比没有结果时，会"),Object(t["i"])("code",null,"根据新节点的key去对比旧节点数组中的key"),Object(t["k"])("，从而找到相应旧节点（这里对应的是一个 key => index 的 map 映射）。如果没找到就认为是一个新增节点。而如果没有 key，那么就会采用遍历查找的方式去找到对应的旧节点。一种一个 map 映射，另一种是遍历查找。相比而言。map 映射的速度更快。")]),Object(t["i"])("ol",null,[Object(t["i"])("li",null,"key 使得新旧 vdom 树的对比更准确。因为带 key 就不是就地复用了，在 sameNode 函数 a.key === b.key 对比中可以避免就地复用的情况。所以会更加准确。"),Object(t["i"])("li",null,"对比更快。利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快。")])])],-1),p=[e];function c(s,a){return Object(t["z"])(),Object(t["h"])("section",l,p)}var o=n("6b0d"),r=n.n(o);const i={},h=r()(i,[["render",c]]);a["default"]=h},1565:function(s,a,n){"use strict";n("3e03")},1882:function(s,a,n){"use strict";n.r(a),n.d(a,"install",(function(){return m}));n("b0c0");var t=n("ade3"),l=n("7a23");function e(s,a,n,e,p,c){var o,r=Object(l["H"])("ShutBIcon"),i=Object(l["H"])("ShutBMask"),h=Object(l["H"])("ShutBWrapper");return Object(l["z"])(),Object(l["f"])(h,{class:Object(l["s"])(["shut-b-button",(o={},Object(t["a"])(o,s.type,!0),Object(t["a"])(o,s.size,!0),Object(t["a"])(o,"disabled",s.disabled),o)]),onMouseenter:a[0]||(a[0]=function(a){return s.changeMaskVisible(!0)}),onMouseleave:a[1]||(a[1]=function(a){return s.changeMaskVisible(!1)})},{default:Object(l["Q"])((function(){return[Object(l["G"])(s.$slots,"prefix",{},(function(){return[s.prefixIcon?(Object(l["z"])(),Object(l["f"])(r,{key:0,name:s.prefixIcon,style:{"margin-right":"0.1em"}},null,8,["name"])):Object(l["g"])("",!0)]}),!0),Object(l["G"])(s.$slots,"default",{},void 0,!0),Object(l["G"])(s.$slots,"suffix",{},(function(){return[s.suffixIcon?(Object(l["z"])(),Object(l["f"])(r,{key:0,name:s.suffixIcon,style:{"margin-left":"0.1em"}},null,8,["name"])):Object(l["g"])("",!0)]}),!0),Object(l["l"])(i,{visible:s.maskVisible},null,8,["visible"])]})),_:3},8,["class"])}n("caad");var p=n("fc61"),c=n("1fa9"),o=n("db95");function r(){var s=Object(l["E"])(!1),a=function(a){s.value=a};return{maskVisible:s,changeMaskVisible:a}}var i=Object(l["m"])({name:"ShutBButton",components:{ShutBWrapper:p["a"],ShutBMask:c["a"],ShutBIcon:o["a"]},props:{type:{type:String,default:"plain",validator:function(s){return["plain","primary","text"].includes(String(s))}},size:{type:String,default:"mid",validator:function(s){return["min","mid","max"].includes(String(s))}},disabled:{type:Boolean,default:!1},prefixIcon:{type:String},suffixIcon:{type:String}},setup:function(){var s=r(),a=s.maskVisible,n=s.changeMaskVisible;return{maskVisible:a,changeMaskVisible:n}}}),h=(n("d86bb"),n("6b0d")),d=n.n(h);const j=d()(i,[["render",e],["__scopeId","data-v-2b1573fc"]]);var u=j,m=function(s){s.component(u.name,u)};a["default"]={install:m}},"1a22":function(s,a,n){"use strict";n.r(a);var t=n("7a23"),l=n("4357"),e=n.n(l),p={class:"markdown-body"},c=Object(t["j"])('<html><head></head><body><h1>CSS3 边框特效</h1><h2>border-radius 圆角边框</h2><p>border-radius 为简写属性，实际代表的四个属性：</p><ol><li>border-top-left-radius</li><li>border-top-right-radius</li><li>border-bottom-right-radius</li><li>border-bottom-left-radius</li></ol><p>以上四个属性可接收单值也可接收双值，若接收单值，则该值为边界圆的半径；<code>若接收双值，则值1为椭圆x方向半轴长，值2为y方向的半轴长。</code></p><p>border-radius 语法实例：</p><pre><code class="language-css"><span class="hljs-attribute">border-radius</span>: <span class="hljs-number">30px</span>; <span class="hljs-comment">/*四角均为30px半径的圆角*/</span>\n<span class="hljs-attribute">border-radius</span>: <span class="hljs-number">25%</span> <span class="hljs-number">10%</span>; <span class="hljs-comment">/*左上及右下为25%半径圆角，右上及左下为10%半径圆角*/</span>\n<span class="hljs-attribute">border-radius</span>: <span class="hljs-number">10%</span> <span class="hljs-number">30%</span> <span class="hljs-number">50%</span>; <span class="hljs-comment">/*依次为左上、右上及左下、右下*/</span>\n<span class="hljs-attribute">border-radius</span>: <span class="hljs-number">10%</span> <span class="hljs-number">30%</span> <span class="hljs-number">50%</span> <span class="hljs-number">70%</span>; <span class="hljs-comment">/*依次为左上、右上、右下、左下*/</span>\n</code></pre><p>当表达式中出现<code>&#39;/&#39;</code>时：</p><pre><code class="language-css"><span class="hljs-attribute">border-radius</span>: <span class="hljs-number">1em</span>/<span class="hljs-number">5em</span>;\n<span class="hljs-comment">/* 等价于： */</span>\n<span class="hljs-attribute">border-top-left-radius</span>: <span class="hljs-number">1em</span> <span class="hljs-number">5em</span>;\n<span class="hljs-attribute">border-top-right-radius</span>: <span class="hljs-number">1em</span> <span class="hljs-number">5em</span>;\n<span class="hljs-attribute">border-bottom-right-radius</span>: <span class="hljs-number">1em</span> <span class="hljs-number">5em</span>;\n<span class="hljs-attribute">border-bottom-left-radius</span>: <span class="hljs-number">1em</span> <span class="hljs-number">5em</span>;\n\n<span class="hljs-attribute">border-radius</span>: <span class="hljs-number">4px</span> <span class="hljs-number">3px</span> <span class="hljs-number">6px</span> / <span class="hljs-number">2px</span> <span class="hljs-number">4px</span>;\n<span class="hljs-comment">/* 等价于： */</span>\n<span class="hljs-attribute">border-top-left-radius</span>: <span class="hljs-number">4px</span> <span class="hljs-number">2px</span>;\n<span class="hljs-attribute">border-top-right-radius</span>: <span class="hljs-number">3px</span> <span class="hljs-number">4px</span>;\n<span class="hljs-attribute">border-bottom-right-radius</span>: <span class="hljs-number">6px</span> <span class="hljs-number">2px</span>;\n<span class="hljs-attribute">border-bottom-left-radius</span>: <span class="hljs-number">3px</span> <span class="hljs-number">4px</span>;\n</code></pre><p><code>&#39;/&#39;</code>号前后为两组语法，分别匹配四个角的 x 方向及 y 方向。</p><h2>box-shadow 边框阴影</h2><p><code>box-shadow: h-shadow v-shadow blur spread color inset;</code></p><p>box-shadow 接收六个值：</p><ol><li>h-shadow 必需。水平阴影的位置。允许负值。</li><li>v-shadow 必需。垂直阴影的位置。允许负值。</li><li>blur 可选。模糊距离。</li><li>spread 可选。阴影的尺寸。</li><li>color 可选。阴影的颜色。请参阅 CSS 颜色值。</li><li>inset 可选。将外部阴影 (outset) 改为内部阴影。</li></ol><h2>border-image 特效边框</h2><p>覆盖 border 属性中设置的 color 属性，使得可以实现多色的边框。（也可以用 url 使用现成的图片）</p><ol><li>border-image-source：用在边框的图片的路径。</li><li>border-image-slice：图片边框向内偏移。</li><li>border-image-width：图片边框的宽度。</li><li>border-image-outset：边框图像区域超出边框的量。</li><li>border-image-repeat：图像边框是否应平铺(repeated)、铺满(rounded)或拉伸(stretched)。</li></ol><p>默认值：<code>&#39;border-image: none 100% 1 0 stretch;&#39;</code></p><h2>outline-offset 轮廓位置</h2><p>设置轮廓线距离元素实际边界的距离（向外）。</p><p>实例：</p><pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;outer&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background: wheat;&quot;</span>&gt;</span>\n\t<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>asdfasdfasdfasdfsdfasd<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n\t<span class="hljs-tag">&lt;<span class="hljs-name">a</span>&gt;</span>fasdfasdf<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>\n\t<span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>打发斯蒂芬阿斯顿发<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n</code></pre><pre><code class="language-css"><span class="hljs-selector-class">.outer</span> {\n\t<span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;\n\t<span class="hljs-attribute">overflow</span>: auto;\n\t<span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;\n\t<span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;\n\t<span class="hljs-attribute">box-sizing</span>: content-box;\n}\n<span class="hljs-selector-class">.outer</span> <span class="hljs-selector-tag">span</span> {\n\t<span class="hljs-attribute">outline-offset</span>: <span class="hljs-number">10px</span>;\n\t<span class="hljs-comment">/* \n    outline-style: dashed;\n    outline-color: violet;\n    outline-width: 1px; \n    */</span>\n\t<span class="hljs-attribute">outline</span>: violet dashed <span class="hljs-number">1px</span>;\n}\n</code></pre><p>样式：<img src="'+e.a+'" alt="outline样式"></p><h2>background-* 背景显示</h2><h3>background-clip 背景显示区域</h3><p>background-clip 属性用于确定背景画区，有以下几种可能的属性：</p><ol><li><code>background-clip: border-box;</code> 背景从 border 开始显示</li><li><code>background-clip: padding-box;</code> 背景从 padding 开始显示</li><li><code>background-clip: content-box;</code> 背景显 content 区域开始显示</li><li><code>background-clip: no-clip;</code> 默认属性，等同于 border-box</li></ol><p>通常情况，背景都是覆盖整个元素的，利用这个属性可以设定背景颜色或图片的覆盖范围。</p><h3>background-origin 背景的位置</h3><p>用于确定背景的位置，它通常与 background-position 联合使用，可以从 border、padding、content 来计算 background-position（就像 background-clip）。</p><ol><li><code>background-origin: border-box;</code> 从 border 开始计算 background-position</li><li><code>background-origin: padding-box;</code> 从 padding 开始计算 background-position</li><li><code>background-origin: content-box;</code> 从 content 开始计算 background-position</li></ol><h4>background-position 背景图片的位置</h4><pre><code class="language-css"><span class="hljs-comment">/* 关键字 */</span>\n<span class="hljs-attribute">background-position</span>: top | bottom | left | right | center;\n\n<span class="hljs-comment">/* 百分比 */</span>\n<span class="hljs-attribute">background-position</span>: <span class="hljs-number">25%</span> <span class="hljs-number">75%</span>;\n\n<span class="hljs-comment">/* 长度值 */</span>\n<span class="hljs-attribute">background-position</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span>;\n<span class="hljs-attribute">background-position</span>: <span class="hljs-number">1cm</span> <span class="hljs-number">2cm</span>;\n<span class="hljs-attribute">background-position</span>: <span class="hljs-number">10ch</span> <span class="hljs-number">8em</span>;\n\n<span class="hljs-comment">/* 多张背景图时，以逗号分开依次匹配 */</span>\n<span class="hljs-attribute">background-position</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span>, center;\n\n<span class="hljs-comment">/* 以边界为基点偏移（例中bottom与right为边界，另两值即为以边界为基础反向偏移） */</span>\n<span class="hljs-attribute">background-position</span>: bottom <span class="hljs-number">10px</span> right <span class="hljs-number">20px</span>;\n<span class="hljs-attribute">background-position</span>: right <span class="hljs-number">3em</span> bottom <span class="hljs-number">10px</span>;\n<span class="hljs-attribute">background-position</span>: bottom <span class="hljs-number">10px</span> right;\n<span class="hljs-attribute">background-position</span>: top right <span class="hljs-number">10px</span>;\n\n<span class="hljs-comment">/* 全局值 */</span>\n<span class="hljs-attribute">background-position</span>: inherit;\n<span class="hljs-attribute">background-position</span>: initial;\n<span class="hljs-attribute">background-position</span>: unset;\n</code></pre><pre><code class="language-css"><span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&#39;https://developer.mozilla.org/samples/cssref/images/startransparent.gif&#39;</span>),\n\t<span class="hljs-built_in">url</span>(<span class="hljs-string">&#39;https://mdn.mozillademos.org/files/7693/catfront.png&#39;</span>);\n<span class="hljs-attribute">background-position</span>: <span class="hljs-number">0px</span> <span class="hljs-number">0px</span>, center;\n</code></pre><ol><li>关键字 center，用来居中背景图片。</li><li>关键字 top, left, bottom, right 中的一个。用来指定把这个项目（原文为 item）放在哪一个边缘。另一个维度被设置成 50%，所以这个项目（原文为 item）被放在指定边缘的中间位置。</li><li><code>&lt;length&gt;</code> 或 <code>&lt;percentage&gt;</code>。指定相对于左边缘的 x 坐标，y 坐标被设置成 50%。</li><li>如果一个值是 top 或 bottom，那么另一个值不应该是 top 或 bottom。</li><li>如果一个值是 left 或 right，那么另一个值不应该是 left 或 right 。</li><li>+50px（将图片的左边界对齐容器的中线）</li><li>0px（图片的左边界与容器左边界重合）</li><li>-100px（将图片相对容器左移 100px，这意味着图片中部的 100px 内容将出现在容器中）</li><li>-200px（将图片相对容器左移 200px，这意味着图片右部分的 100px 内容将出现在容器中）</li><li>-250px（将图片相对容器左移 250px，这意味着图片的右边界对齐容器的中线）</li><li>百分比值的偏移指定图片的相对位置和容器的相对位置重合。值 0%代表图片的左边界（或上边界）和容器的左边界（上边界）重合。值 100%代表图片的右边界（或下边界）和容器的右边界（或下边界）重合。值 50%则代表图片的中点和容器的中点重合。</li></ol><h3>background-size 背景大小</h3><p>background-size 属性常用来调整背景图片的大小，主要用于设定图片本身。有以下可能的属性：</p><ol><li>background-size: contain; 缩小图片以适合元素（维持像素长宽比）</li><li>background-size: cover; 扩展元素以填补元素（维持像素长宽比）</li><li>background-size: 100px 100px; 缩小图片至指定的大小</li><li>background-size: 50% 100%; 缩小图片至指定的大小，百分比是相对包含元素的尺寸。</li></ol><h3>background-break 背景跨盒显示</h3><p>CSS3 中，元素可以被分成几个独立的盒子（如使内联元素 span 跨越多行），background-break 属性用来控制背景怎样在这些不同的盒子中显示。</p><ol><li>background-break: continuous; 默认值。忽略盒之间的距离（也就是像元素没有分成多个盒子，依然是一个整体一样）</li><li>background-break: bounding-box; 把盒之间的距离计算在内；</li><li>background-break: each-box; 为每个盒子单独重绘背景。</li></ol></body></html>',1),o=[c];function r(s,a){return Object(t["z"])(),Object(t["h"])("section",p,o)}var i=n("6b0d"),h=n.n(i);const d={},j=h()(d,[["render",r]]);a["default"]=j},"1b4d":function(s,a,n){"use strict";n.r(a);var t=n("7a23"),l={class:"markdown-body"},e=Object(t["j"])('<html><head></head><body><h1>JS 用到的浏览器缓存</h1><h2>cookie</h2><p>JavaScript 可以使用 document.cookie 属性来创建 、读取、及删除 cookie。</p><p><code>document.cookie=&quot;username=John Doe&quot;;</code></p><p>还可以为 cookie 添加一个过期时间（以 UTC 或 GMT 时间）。默认情况下，cookie 在浏览器关闭时删除：</p><p><code>document.cookie=&quot;username=John Doe; expires=Thu, 18 Dec 2043 12:00:00 GMT&quot;;</code></p><p>您可以使用 path 参数告诉浏览器 cookie 的路径。默认情况下，cookie 属于当前页面。</p><p><code>document.cookie=&quot;username=John Doe; expires=Thu, 18 Dec 2043 12:00:00 GMT; path=/&quot;;</code></p><p>读取 cookie：</p><p><code>var x = document.cookie;</code></p><p>删除 cookie，将时间设为以前即可：</p><p><code>document.cookie = &quot;username=; expires=Thu, 01 Jan 1970 00:00:00 GMT&quot;;</code></p><h3>cookie 特性</h3><p>cookie 虽然在持久保存客户端数据提供了方便，分担了服务器存储的负担，但还是有很多局限性的。</p><ol><li>IE6 或更低版本最多 20 个 cookie</li><li>IE7 和之后的版本最后可以有 50 个 cookie。</li><li>Firefox 最多 50 个 cookie</li><li>chrome 和 Safari 没有做硬性限制。</li></ol><p>IE 和 Opera 会清理近期最少使用的 cookie，Firefox 会随机清理 cookie。</p><p>cookie 的最大大约为 4096 字节，为了兼容性，一般不能超过 4095 字节。</p><p>IE 提供了一种存储可以持久化用户数据，叫做 userData，从 IE5.0 就开始支持。每个数据最多 128K，每个域名下最多 1M。这个持久化数据放在缓存中，如果缓存没有清理，那么会一直存在。</p><h3>cookie 的优点 极高的扩展性和可用性</h3><ol><li>通过良好的编程，控制保存在 cookie 中的 session 对象的大小。</li><li>通过加密和安全传输技术（SSL），减少 cookie 被破解的可能性。</li><li>只在 cookie 中存放不敏感数据，即使被盗也不会有重大损失。</li><li>控制 cookie 的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的 cookie。</li></ol><h3>cookie 的缺点</h3><ol><li>有长度和数量的限制 每个 domain 最多只能有 20 条 cookie，每个 cookie 长度不能超过 4KB，否则会被截掉。</li><li>安全性问题。如果 cookie 被人拦截了，那人就可以取得所有的 session 信息。即使加密也与事无补，因为拦截者并不需要知道 cookie 的意义，他只要原样转发 cookie 就可以达到目的了。</li><li>有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。</li></ol><h2>浏览器缓存</h2><p>在较高版本的浏览器中，js 提供了 sessionStorage 和 globalStorage。在 HTML5 中提供了 localStorage 来取代 globalStorage。</p><p>html5 中的 Web Storage 包括了两种存储方式：sessionStorage 和 localStorage。</p><p>sessionStorage 用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此 sessionStorage 不是一种持久化的本地存储，仅仅是会话级别的存储。</p><p>而 localStorage 用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。 使用方法：</p><pre><code class="language-js">sessionStorage.setItem(key, value); <span class="hljs-comment">//设置值</span>\nsessionStorage.getItem(key); <span class="hljs-comment">//获取值</span>\nsessionStorage.length; <span class="hljs-comment">//键值对数量</span>\nsessionStorage.clear(); <span class="hljs-comment">//清空</span>\nsessionStorage.key(index); <span class="hljs-comment">//获取对应index的key</span>\n</code></pre><h3>webStorage 与 cookie 的区别</h3><p>Web Storage 的概念和 cookie 相似，区别是它是为了更大容量存储设计的。Cookie 的大小是受限的，并且每次你请求一个新的页面的时候 Cookie 都会被发送过去，这样无形中浪费了带宽，另外 cookie 还需要指定作用域，不可以跨域调用。</p><p>除此之外，Web Storage 拥有 setItem,getItem,removeItem,clear 等方法，不像 cookie 需要前端开发者自己封装 setCookie，getCookie。</p><p><code>但是Cookie也是不可以或缺的：Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生</code></p><p>浏览器的支持除了 IE ７及以下不支持外，其他标准浏览器都完全支持(ie 及 FF 需在 web 服务器里运行)，值得一提的是 IE 总是办好事，例如 IE7、IE6 中的 UserData 其实就是 javascript 本地存储的解决方案。通过简单的代码封装可以统一到所有的浏览器都支持 web storage。</p><p>localStorage 和 sessionStorage 都具有相同的操作方法，例如 setItem、getItem 和 removeItem 等。</p></body></html>',1),p=[e];function c(s,a){return Object(t["z"])(),Object(t["h"])("section",l,p)}var o=n("6b0d"),r=n.n(o);const i={},h=r()(i,[["render",c]]);a["default"]=h},"1fa6":function(s,a,n){"use strict";n("11ac")},"1fa9":function(s,a,n){"use strict";var t=n("7a23");function l(s,a,n,l,e,p){var c=Object(t["H"])("ShutBWrapper");return Object(t["z"])(),Object(t["f"])(c,{class:Object(t["s"])(["shut-b-mask",s.maskClass]),style:Object(t["t"])(s.maskStyle)},{default:Object(t["Q"])((function(){return[Object(t["G"])(s.$slots,"default",{},void 0,!0)]})),_:3},8,["class","style"])}n("caad"),n("a9e3");var e=n("fc61"),p=function(s){var a={backgroundColor:s.backgroundColor||"#fff",opacity:s.opacity,zIndex:99},n=Object(t["D"])(a);return Object(t["P"])((function(){n.backgroundColor="light"===s.type?"#fff":"#000",s.backgroundColor&&(n.backgroundColor=String(s.backgroundColor)),n.opacity=s.opacity})),{maskStyle:n}},c=Object(t["m"])({name:"ShutBMask",components:{ShutBWrapper:e["a"]},props:{type:{type:String,default:"light",description:"蒙板类型",validator:function(s){return["light","dark"].includes(String(s))}},backgroundColor:{type:String,default:""},opacity:{type:Number,default:.15},visible:{type:Boolean,default:!0}},setup:function(s){var a=p(s),n=a.maskStyle,l={},e=Object(t["D"])(l);return Object(t["P"])((function(){e.unVisible=!s.visible})),{maskStyle:n,maskClass:e}}}),o=(n("1565"),n("6b0d")),r=n.n(o);const i=r()(c,[["render",l],["__scopeId","data-v-21cb9f28"]]);a["a"]=i},2040:function(s,a,n){"use strict";n.r(a);var t=n("7a23"),l={class:"markdown-body"},e=Object(t["j"])('<html><head></head><body><h1>Git-revert</h1><p>用于回退提交，与 reset 不同的是 revert 可以生成新的 commit 记录对应的回退结果，而 reset 则是清空回退路径上的所有提交记录。</p><h2>指定需要回退的提交记录 Id</h2><pre><code class="language-sh">git revert 1234i21738947sdfasf31234213\n</code></pre><h2>根据指定的 Id 往回相对查找</h2><pre><code class="language-sh">git revert 1234i21738947sdfasf31234213~1 <span class="hljs-comment"># 从该id往回第一条，即上一条</span>\ngit revert HEAD~2 <span class="hljs-comment"># 往回第二条</span>\n</code></pre><h2>根据一个范围进行回退</h2><p>从 id1 到 id2 之间的所有提交，<strong>依时间顺序从后到先依次回退</strong></p><pre><code class="language-sh">git revert id1..id2 <span class="hljs-comment"># 不包括id1</span>\ngit revert id1^..id2 <span class="hljs-comment"># id1也会被回退</span>\n</code></pre><h2>参数 <code>--continue --abort --quit --skip</code></h2><p>同时回滚多条提交时若因某些问题导致中断（如冲突处理，或者 commit）的话，这些参数会用于对暂停的过程进行处理</p><ul><li>continue 继续过程，执行下一条</li><li>skip 跳过下一条并继续（若队列完成则终止）</li><li>quit 放弃回退过程并保留工作区状态</li><li>abort 放弃回退过程并返回执行回退命令之前的状态（HEAD）</li></ul><h2>参数 <code>--no-edit</code></h2><p>若该次回退没有产生冲突，则自动生成提交记录，<code>不需要唤起vim</code>，若有多条回退，也不会因此中断过程。</p><h2>参数 <code>-m --mainline</code></h2><p>若是要回退一个 merge 提交，由于 merge 是将两条分支的提交进行重现合并，因此需要通过该参数<code>指定要保留哪一方</code>（<code>1</code>为 base 分支<code>2</code>为被 merge 分支）。</p><pre><code class="language-sh"><span class="hljs-comment"># 若我将有问题的代码发布到了prod分支，线上发现该需求功能异常需要回退。</span>\n<span class="hljs-comment"># 发布到prod分支时的指令为</span>\ngit merge feat/my_feat --no-ff\n<span class="hljs-comment"># 该指令会生成一条merge commit记录</span>\n<span class="hljs-comment"># 回退的指令如下</span>\ngit revert commit-id -m 1 <span class="hljs-comment"># -m 1 表示保留prod原本的内容</span>\n</code></pre></body></html>',1),p=[e];function c(s,a){return Object(t["z"])(),Object(t["h"])("section",l,p)}var o=n("6b0d"),r=n.n(o);const i={},h=r()(i,[["render",c]]);a["default"]=h},2184:function(s,a,n){"use strict";n.r(a);var t=n("7a23"),l=n("8617"),e=n.n(l),p={class:"markdown-body"},c=Object(t["j"])('<html><head></head><body><h1>JS 事件队列</h1><h2>宏任务 微任务</h2><p>宏任务是 JS 事件循环的主体，即 JS 脚本执行的主体，如 JS 脚本文件执行路线以及 setTimeout 等异步的回调。 微任务是宏任务执行完成导致当前宏任务过程清空，并进行下一次宏任务执行之前执行的代码。</p><p>&lt;style&gt; img{ width: 70%; padding-left: 15%; } &lt;/style&gt;</p><h2>事件队列流程</h2><p><img src="'+e.a+'" alt="事件循环"></p><h2>代码示例</h2><h3>示例 1</h3><pre><code class="language-javascript">setImmediate(<span class="hljs-function">(<span class="hljs-params"><span class="hljs-comment">/* 回调1 */</span></span>) =&gt;</span> {\n\t<span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);\n\t<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {\n\t\t<span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>);\n\t}, <span class="hljs-number">100</span>);\n\tsetImmediate(<span class="hljs-function">() =&gt;</span> {\n\t\t<span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>);\n\t});\n\tprocess.nextTick(<span class="hljs-function">() =&gt;</span> {\n\t\t<span class="hljs-built_in">console</span>.log(<span class="hljs-number">4</span>);\n\t});\n});\nprocess.nextTick(<span class="hljs-function">(<span class="hljs-params"><span class="hljs-comment">/* 回调2 */</span></span>) =&gt;</span> {\n\t<span class="hljs-built_in">console</span>.log(<span class="hljs-number">5</span>);\n\t<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {\n\t\t<span class="hljs-built_in">console</span>.log(<span class="hljs-number">6</span>);\n\t}, <span class="hljs-number">100</span>);\n\tsetImmediate(<span class="hljs-function">() =&gt;</span> {\n\t\t<span class="hljs-built_in">console</span>.log(<span class="hljs-number">7</span>);\n\t});\n\tprocess.nextTick(<span class="hljs-function">() =&gt;</span> {\n\t\t<span class="hljs-built_in">console</span>.log(<span class="hljs-number">8</span>);\n\t});\n});\n<span class="hljs-built_in">console</span>.log(<span class="hljs-number">9</span>);\n<span class="hljs-comment">/*输出\n9\n5\n8\n1\n7\n4\n3\n6\n2\n*/</span>\n</code></pre><p>输出解析：</p><ul><li>将回调 1 放入 immediate 队列，将回调 2 放入 microTask 队列，输出：9。 <ul><li>主线程结束，清空 microTask 队列，执行回调 2，输出：5；延时 100ms 将 6 放入 timer 队列，将 7 放入 immediate 队列（与回调 1 同轮），将 8 放入 microTask 队列。 <ul><li>切换阶段，先清空 microTask 队列，输出：8。</li></ul></li></ul></li><li>切换阶段至 timer，由于不足 100ms，timer 为空。</li><li>切换至 immediate 阶段，内容为回调 1 和数字 7，执行回调 1，输出：1；延时 100ms 将 2 放入 timer 队列，将 3 放入下一轮 immediate 队列，将 4 放入 microTask 队列。</li><li>immediate 中还有 7，执行输出：7。 <ul><li>切换阶段，先清空 microTask 队列，输出：4。</li></ul></li><li>切换至 timer，未满 100ms，timer 为空。</li><li>切换至 immediate，输出：3。</li><li>等待满足时间后，6、2 依次放入 timer 队列，先后输出：6、2。</li></ul><h3>示例 2</h3><pre><code class="language-javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#39;fs&#39;</span>);\n<span class="hljs-keyword">const</span> promise = <span class="hljs-built_in">Promise</span>.resolve();\n\nfs.readFile(<span class="hljs-string">&#39;testjs.js&#39;</span>, <span class="hljs-function">() =&gt;</span> {\n\t<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#39;file&#39;</span>);\n\t<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {\n\t\t<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#39;timeout1&#39;</span>);\n\t\t<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {\n\t\t\t<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#39;timeout2&#39;</span>);\n\t\t}, <span class="hljs-number">0</span>);\n\t}, <span class="hljs-number">0</span>);\n\tsetImmediate(<span class="hljs-function">() =&gt;</span> {\n\t\t<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#39;immediate1&#39;</span>);\n\t\tsetImmediate(<span class="hljs-function">() =&gt;</span> {\n\t\t\t<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#39;immediate2&#39;</span>);\n\t\t});\n\t});\n\tpromise.then(<span class="hljs-function">() =&gt;</span> {\n\t\t<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#39;promise1&#39;</span>);\n\t});\n\tprocess.nextTick(<span class="hljs-function">() =&gt;</span> {\n\t\t<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#39;nextTick1&#39;</span>);\n\t});\n});\n<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {\n\t<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#39;timeout3&#39;</span>);\n\t<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {\n\t\t<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#39;timeout4&#39;</span>);\n\t}, <span class="hljs-number">0</span>);\n}, <span class="hljs-number">0</span>);\nsetImmediate(<span class="hljs-function">() =&gt;</span> {\n\t<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#39;immediate3&#39;</span>);\n\tsetImmediate(<span class="hljs-function">() =&gt;</span> {\n\t\t<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#39;immediate4&#39;</span>);\n\t});\n});\npromise.then(<span class="hljs-function">() =&gt;</span> {\n\t<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#39;promise2&#39;</span>);\n});\nprocess.nextTick(<span class="hljs-function">() =&gt;</span> {\n\t<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#39;nextTick2&#39;</span>);\n});\n<span class="hljs-comment">/*输出\nnextTick2\npromise2\ntimeout3\nimmediate3\ntimeout4//timeout4和immediate4顺序不定\nimmediate4//\nfile\nnextTick1\npromise1\nimmediate1\ntimeout1\nimmediate2\ntimeout2\n*/</span>\n</code></pre><p>输出解析：</p><ul><li>执行主线程，readFile、将 timeout3 加入 timer 队列，immediate3 加入 immediate 队列，将 promise2、nextTick2 加入 microTask 队列。 <ul><li>切换阶段，清空 microTask 队列，其中<code>nextTick2</code>优先级更高，然后是<code>promise2</code>。</li></ul></li><li>进入 timer 阶段，执行<code>timeout3</code>，将 timeout4 加入下一轮 timer 队列。</li><li>进入 immediate 阶段，执行<code>immediate3</code>，将 immediate4 加入下一轮 immediate 队列。</li><li>进入下一轮 timer 阶段，由于 setTimeout 强制的 1ms 时延，此时有两种情况： <ol><li>加载本轮 timer 较慢，加载好时 timeout4 已经放入本轮的 timer 队列，即执行<code>timeout4</code>，然后变换阶段并执行<code>immediate4</code>。</li><li>加载本轮 timer 较快，加载好时 timeout4 还未放入 timer 队列，即跳过并执行<code>immediate4</code>，<code>timeout4</code>留到下一轮 timer 阶段执行。</li></ol></li><li>IO 请求得到返回调用，输出<code>file</code>（当前阶段为 IO callback），将 timeout1 加入 timer 队列，将 immediate1 放入 immediate 队列，将 promise1 和 nextTick1 放入 microTask 队列。 <ul><li>切换阶段，清空 microTask 队列，输出<code>nextTick1</code>，<code>promise1</code>。</li></ul></li><li>切换阶段，由于之前在 IO callback 阶段，因此之后是 immediate 阶段，执行<code>immediate1</code>，将 immediate2 放入下一轮的 immediate 队列。</li><li>切换阶段至 timer，输出<code>timeout1</code>，将 timeout2 放入下一轮的 timer 队列。</li><li>切换阶段至 immediate，输出<code>immediate2</code>。</li><li>切换阶段至 timer，输出<code>timeout2</code>。</li></ul><h3>示例 3</h3><p>利用事件队列方式在 js 文件中对 html 中引入并使用 jQuery</p><pre><code class="language-javascript"><span class="hljs-keyword">let</span> jq = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#39;script&#39;</span>);\njq.type = <span class="hljs-string">&#39;text/javascript&#39;</span>;\njq.src = <span class="hljs-string">&#39;jquery.js&#39;</span>; <span class="hljs-comment">//jq文件路径</span>\n<span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">&#39;head&#39;</span>)[<span class="hljs-number">0</span>].appendChild(jq);\n\n<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {\n\t$(<span class="hljs-built_in">document</span>).ready(<span class="hljs-function">() =&gt;</span> {\n\t\t<span class="hljs-comment">//do somethings</span>\n\t});\n}, <span class="hljs-number">50</span>);\n</code></pre><p>在这种情况下，setTimeout 中的代码将会被放入 Timer 任务队列，等待 html 中直接引入的 js 代码执行完成后再开始检查回调队列。</p><h3>示例 4</h3><pre><code class="language-html"><span class="hljs-comment">&lt;!-- index.html --&gt;</span>\n<span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span>\n\n<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>\n\t<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;test.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n\t<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;test2.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>\n</code></pre><pre><code class="language-javascript"><span class="hljs-comment">//test.js</span>\n<span class="hljs-keyword">const</span> jq = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#39;script&#39;</span>);\njq.type = <span class="hljs-string">&#39;text/javascript&#39;</span>;\njq.src = <span class="hljs-string">&#39;jquery-3.4.1.js&#39;</span>;\n<span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">&#39;head&#39;</span>)[<span class="hljs-number">0</span>].appendChild(jq);\n\n<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#39;1&#39;</span>);\n\n<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {\n\t$(<span class="hljs-built_in">document</span>).ready(<span class="hljs-function">() =&gt;</span> {\n\t\t<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#39;OK1&#39;</span>);\n\t});\n}, <span class="hljs-number">50</span>);\n</code></pre><pre><code class="language-javascript"><span class="hljs-comment">//test2.js</span>\n<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#39;2&#39;</span>);\n\n<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {\n\t$(<span class="hljs-built_in">document</span>).ready(<span class="hljs-function">() =&gt;</span> {\n\t\t<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#39;OK2&#39;</span>);\n\t});\n}, <span class="hljs-number">50</span>);\n</code></pre><p>页面加载结果：1,2,OK1,OK2</p></body></html>',1),o=[c];function r(s,a){return Object(t["z"])(),Object(t["h"])("section",p,o)}var i=n("6b0d"),h=n.n(i);const d={},j=h()(d,[["render",r]]);a["default"]=j},"22f4":function(s,a,n){"use strict";n.r(a),n.d(a,"createLoadingDirective",(function(){return k})),n.d(a,"createGlobalLoader",(function(){return w})),n.d(a,"install",(function(){return v}));n("4ec9"),n("d3b7"),n("3ca3"),n("ddb0"),n("b0c0");var t=n("7a23"),l=n("ce7b"),e=n.n(l),p=function(s){return Object(t["C"])("data-v-6c47009c"),s=s(),Object(t["A"])(),s},c=p((function(){return Object(t["i"])("img",{src:e.a},null,-1)})),o={key:0,class:"msg"};function r(s,a,n,l,e,p){var r=Object(t["H"])("ShutBMask"),i=Object(t["H"])("ShutBTransition");return Object(t["z"])(),Object(t["f"])(i,{name:"fade",duration:500},{default:Object(t["Q"])((function(){return[Object(t["R"])(Object(t["l"])(r,{class:"shut-b-loading",opacity:.5,style:Object(t["t"])(s.customStyle)},{default:Object(t["Q"])((function(){return[Object(t["G"])(s.$slots,"default",{},(function(){return[c,s.msg?(Object(t["z"])(),Object(t["h"])("div",o,Object(t["K"])(s.msg),1)):Object(t["g"])("",!0)]}),!0)]})),_:3},8,["opacity","style"]),[[t["N"],s.visible]])]})),_:3})}var i=n("1fa9"),h=n("4ce0"),d=function(){var s=Object(t["E"])(!1),a=Object(t["E"])("");function n(n){a.value=n||"",Object(t["r"])((function(){s.value=!0}))}function l(){s.value=!1}return{visible:s,msg:a,show:n,hide:l}},j=Object(t["m"])({name:"shutBLoading",components:{ShutBTransition:h["a"],ShutBMask:i["a"]},props:{customStyle:{type:Object,default:function(){return{}}}},setup:function(){var s=d(),a=s.visible,n=s.msg,t=s.show,l=s.hide;return{visible:a,msg:n,show:t,hide:l}}}),u=(n("a603"),n("3832"),n("6b0d")),m=n.n(u);const b=m()(j,[["render",r],["__scopeId","data-v-6c47009c"]]);var g=b,f=new Map,y=function(s,a){var n=document.createElement("div");console.log(getComputedStyle(s).getPropertyValue("position")),"static"===getComputedStyle(s).getPropertyValue("position")&&(s.style.position="relative"),n.classList.add("shut-b-loading--wrapper");var l=Object(t["e"])(g,{customStyle:a}).mount(n);s.appendChild(n);var e={inst:l,wrapper:n};return f.set(s,e),e},A=function(s,a){var n=f.get(s);n||(n=y(s,{})),a?(n.inst.show(),Object(t["r"])((function(){n&&n.wrapper&&(n.wrapper.style.display="block")}))):(n.inst.hide(),Object(t["r"])((function(){n&&n.wrapper&&(n.wrapper.style.display="none")})))},k=function(){var s=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},a={mounted:function(a,n){y(a,s),A(a,!!n.value)},updated:function(s,a){A(s,!!a.value)}};return a},w=function(){var s=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},a=y(document.querySelector("body"),s);return a},v=function(s){s.component(g.name,g),s.directive("loading",k())};a["default"]={install:v}},2800:function(s,a,n){"use strict";n.r(a);var t=n("7a23"),l={class:"markdown-body"},e=Object(t["j"])("<html><head></head><body><h1>JS 模块化</h1><h2>CommonJS 模块</h2><p>NodeJS 的标准模块规范，使用 <code>require</code> 用于引入其他模块代码，<code>module.exports</code> 导出模块自身内容。<strong>在 require 同时目标模块内代码会先执行。</strong></p><h2>ESModule 模块</h2><p>ES6 模块规范，使用 <code>import</code> 语法引入其他模块，<code>export</code> 用于导出自身内容。<strong>import 语句会自动提升到模块代码顶部，即最先执行。会将当前模块的所有引入内容先执行后再执行自身内容。</strong></p><h2>CommonJS 与 ESModule 的区别</h2><h3>引入值</h3><ul><li>CommonJS 引入内容即 <code>module.exports</code> 对象本身的引用，外部可以做任何操作。</li><li>ESModule 不能修改引用（<code>import a</code> 则 a 不能做其他赋值）。</li></ul><h3>执行顺序</h3><ul><li>CommonJS 引入的模块会在 <code>require</code> 语句处执行，模块执行完成后主体再继续执行。</li><li>ESModule <code>import</code> 语句会提升到顶部，模块执行完成后主体开始执行。</li></ul><h3>重复引入和循环引入</h3><ul><li>CommonJS 已经引入的模块会做缓存，模块执行完成或执行暂停（又 <code>require</code> 了其他模块）时对当前执行结果进行暂存。之后若又引入该模块则直接取缓存。</li><li>ESModule 若模块已经经过预处理，却没有执行（即循环 <code>import</code>），则模块内预处理的 export 信息全部为<code>&lt;Uninitialized&gt;</code>，访问即报错未初始化。</li></ul></body></html>",1),p=[e];function c(s,a){return Object(t["z"])(),Object(t["h"])("section",l,p)}var o=n("6b0d"),r=n.n(o);const i={},h=r()(i,[["render",c]]);a["default"]=h},"2a96":function(s,a,n){"use strict";n.r(a);var t=n("7a23"),l=n("acbc"),e=n.n(l),p={class:"markdown-body"},c=Object(t["j"])('<html><head></head><body><h1>VSCode 插件编写</h1><h2>开发及发布过程</h2><h3>新建项目</h3><pre><code class="language-sh">npm install -g yo generator-code yo code\nyo code\n</code></pre><h3>发布项目</h3><pre><code class="language-sh">npm install -g vsce <span class="hljs-comment"># 安装发布工具</span>\nvsce create-publisher publisher name <span class="hljs-comment"># 创建发布人</span>\n</code></pre><p><img src="'+e.a+'" alt="获取发布Token"></p><pre><code class="language-sh">vsce login <span class="hljs-comment"># 登陆并输入获取的Token</span>\nvsce publish <span class="hljs-comment"># 发布</span>\n</code></pre><h2>通过 TS 解析语法树的 Vue 插件。</h2><p><a href="https://github.com/czzczz/helpue">helpue</a></p></body></html>',1),o=[c];function r(s,a){return Object(t["z"])(),Object(t["h"])("section",p,o)}var i=n("6b0d"),h=n.n(i);const d={},j=h()(d,[["render",r]]);a["default"]=j},"2b1c":function(s,a,n){"use strict";n.r(a);var t=n("7a23"),l={class:"markdown-body"},e=Object(t["j"])('<html><head></head><body><h1>Promise</h1><h2>Promise 特性分析</h2><p>详见 外部的 Promise 特性分析 <a href="/#/notes/javascript/Promise.md">Promise 特性分析</a></p><h2>Promise then catch 代码实现</h2><p><strong>由于异步通过 nextTick 等功能实现，因此 MyPromise 可以跟 Promise 混用，但是执行顺序有一定区别</strong></p><pre><code class="language-js">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">w</span>) </span>{\n\t<span class="hljs-keyword">var</span> PENDING = <span class="hljs-string">&#39;pending&#39;</span>, <span class="hljs-comment">// 挂起状态</span>\n\t\tFULLFILLED = <span class="hljs-string">&#39;fullfilled&#39;</span>, <span class="hljs-comment">// 已接受</span>\n\t\tREJECTED = <span class="hljs-string">&#39;rejected&#39;</span>; <span class="hljs-comment">//已拒绝</span>\n\n\t<span class="hljs-keyword">var</span> nextTick = (<span class="hljs-built_in">this</span>.process &amp;&amp; <span class="hljs-built_in">this</span>.process.nextTick) || <span class="hljs-built_in">this</span>.queueMicrotask;\n\n\t<span class="hljs-keyword">var</span> statusSymbol = <span class="hljs-built_in">this</span>.Symbol ? <span class="hljs-built_in">this</span>.Symbol(<span class="hljs-string">&#39;myPromiseStatus&#39;</span>) : <span class="hljs-string">&#39;myPromiseStatus&#39;</span>,\n\t\tvalueSymbol = <span class="hljs-built_in">this</span>.Symbol ? <span class="hljs-built_in">this</span>.Symbol(<span class="hljs-string">&#39;myPromiseValue&#39;</span>) : <span class="hljs-string">&#39;myPromiseValue&#39;</span>,\n\t\tonFullfilledCallbackSymbol = <span class="hljs-built_in">this</span>.Symbol ? <span class="hljs-built_in">this</span>.Symbol(<span class="hljs-string">&#39;onFullfilledCallback&#39;</span>) : <span class="hljs-string">&#39;onFullfilledCallback&#39;</span>,\n\t\tonRejectedCallbackSymbol = <span class="hljs-built_in">this</span>.Symbol ? <span class="hljs-built_in">this</span>.Symbol(<span class="hljs-string">&#39;onRejectedCallback&#39;</span>) : <span class="hljs-string">&#39;onRejectedCallback&#39;</span>;\n\n\tw.MyPromise = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyPromise</span>(<span class="hljs-params">executor</span>) </span>{\n\t\t<span class="hljs-built_in">this</span>[statusSymbol] = PENDING; <span class="hljs-comment">// 状态位</span>\n\t\t<span class="hljs-built_in">this</span>[valueSymbol] = <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// 结果</span>\n\t\t<span class="hljs-built_in">this</span>[onFullfilledCallbackSymbol] = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 接收态回调</span>\n\t\t<span class="hljs-built_in">this</span>[onRejectedCallbackSymbol] = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 拒绝态回调</span>\n\n\t\t<span class="hljs-keyword">var</span> _this = <span class="hljs-built_in">this</span>;\n\t\t<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolve</span>(<span class="hljs-params">value</span>) </span>{\n\t\t\t<span class="hljs-comment">//用于传给executor的接收函数</span>\n\t\t\t<span class="hljs-keyword">if</span> (_this[statusSymbol] !== PENDING) <span class="hljs-keyword">return</span>;\n\t\t\t_this[statusSymbol] = FULLFILLED;\n\t\t\t_this[valueSymbol] = value;\n\t\t\t<span class="hljs-keyword">if</span> (_this[onFullfilledCallbackSymbol]) _this[onFullfilledCallbackSymbol]();\n\t\t}\n\t\t<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reject</span>(<span class="hljs-params">reason</span>) </span>{\n\t\t\t<span class="hljs-comment">//用于传给executor的拒绝函数</span>\n\t\t\t<span class="hljs-keyword">if</span> (_this[statusSymbol] !== PENDING) <span class="hljs-keyword">return</span>;\n\t\t\t_this[statusSymbol] = REJECTED;\n\t\t\t_this[valueSymbol] = reason;\n\t\t\t<span class="hljs-keyword">if</span> (_this[onRejectedCallbackSymbol]) _this[onRejectedCallbackSymbol]();\n\t\t\t<span class="hljs-keyword">else</span> <span class="hljs-keyword">throw</span> reason;\n\t\t}\n\n\t\t<span class="hljs-keyword">try</span> {\n\t\t\texecutor(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>{\n\t\t\t\t<span class="hljs-comment">// 递归处理嵌套 PromiseLike 值</span>\n\t\t\t\tresolvePromise(_this, value, resolve, reject);\n\t\t\t}, reject);\n\t\t} <span class="hljs-keyword">catch</span> (e) {\n\t\t\treject(e);\n\t\t}\n\t};\n\n\tMyPromise.prototype.then = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">onFullfilled, onRejected</span>) </span>{\n\t\tonFullfilled = <span class="hljs-comment">// 填充默认值，没有接收直接往下一次then传递</span>\n\t\t\t<span class="hljs-keyword">typeof</span> onFullfilled === <span class="hljs-string">&#39;function&#39;</span>\n\t\t\t\t? onFullfilled\n\t\t\t\t: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">v</span>) </span>{\n\t\t\t\t\t\t<span class="hljs-keyword">return</span> v;\n\t\t\t\t  };\n\t\tonRejected = <span class="hljs-comment">// 填充默认值，没有接收直接往下一次then传递</span>\n\t\t\t<span class="hljs-keyword">typeof</span> onRejected === <span class="hljs-string">&#39;function&#39;</span>\n\t\t\t\t? onRejected\n\t\t\t\t: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">r</span>) </span>{\n\t\t\t\t\t\t<span class="hljs-keyword">throw</span> r;\n\t\t\t\t  };\n\t\t<span class="hljs-keyword">var</span> _this = <span class="hljs-built_in">this</span>;\n\t\t<span class="hljs-keyword">var</span> promise2 = <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>{\n\t\t\t<span class="hljs-comment">// 新的Promise</span>\n\t\t\t<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callFn</span>(<span class="hljs-params">cb</span>) </span>{\n\t\t\t\t<span class="hljs-comment">// 调用then的回调</span>\n\t\t\t\tnextTick(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{\n\t\t\t\t\t<span class="hljs-comment">// 异步调用</span>\n\t\t\t\t\t<span class="hljs-keyword">try</span> {\n\t\t\t\t\t\t<span class="hljs-keyword">var</span> x = cb(_this[valueSymbol]); <span class="hljs-comment">// 获取回调返回值</span>\n\t\t\t\t\t\tresolvePromise(promise2, x, resolve, reject);\n\t\t\t\t\t} <span class="hljs-keyword">catch</span> (e) {\n\t\t\t\t\t\treject(e);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\t<span class="hljs-keyword">if</span> (_this[statusSymbol] === FULLFILLED) callFn(onFullfilled);\n\t\t\t<span class="hljs-comment">// 判断状态是否已经变化</span>\n\t\t\t<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (_this[statusSymbol] === REJECTED) callFn(onRejected);\n\t\t\t<span class="hljs-keyword">else</span> {\n\t\t\t\t<span class="hljs-comment">// 状态还没变化，先注册回调</span>\n\t\t\t\t_this[onFullfilledCallbackSymbol] = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{\n\t\t\t\t\tcallFn(onFullfilled);\n\t\t\t\t};\n\t\t\t\t_this[onRejectedCallbackSymbol] = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{\n\t\t\t\t\tcallFn(onRejected);\n\t\t\t\t};\n\t\t\t}\n\t\t});\n\t\t<span class="hljs-keyword">return</span> promise2;\n\t};\n\tMyPromise.prototype.catch = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">onRejected</span>) </span>{\n\t\t<span class="hljs-comment">// then 语法糖</span>\n\t\t<span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.then(<span class="hljs-literal">null</span>, onRejected);\n\t};\n\n\tMyPromise.prototype.finally = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">onFinally</span>) </span>{\n\t\t<span class="hljs-comment">// then 语法糖</span>\n\t\t<span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.then(onFinally, onFinally);\n\t};\n\n\t<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolvePromise</span>(<span class="hljs-params">promise2, x, resolve, reject</span>) </span>{\n\t\t<span class="hljs-comment">// 判断 then 回调返回结果的函数</span>\n\t\t<span class="hljs-keyword">if</span> (promise2 === x) <span class="hljs-keyword">throw</span> <span class="hljs-string">&#39;Promise2 cannot be x&#39;</span>; <span class="hljs-comment">// 不可链式的把已定义的 Promise 作为 then 的返回值</span>\n\n\t\t<span class="hljs-keyword">var</span> called = <span class="hljs-literal">false</span>; <span class="hljs-comment">// flag判断，resolve和reject不可重复执行</span>\n\n\t\t<span class="hljs-keyword">if</span> ((<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#39;object&#39;</span> &amp;&amp; x !== <span class="hljs-literal">null</span>) || <span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#39;function&#39;</span>) {\n\t\t\t<span class="hljs-comment">// 判断PromiseLike，是则递归then，不是则直接resolve</span>\n\t\t\t<span class="hljs-keyword">try</span> {\n\t\t\t\t<span class="hljs-keyword">var</span> then = x.then;\n\t\t\t\t<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> then === <span class="hljs-string">&#39;function&#39;</span>) {\n\t\t\t\t\t<span class="hljs-comment">//判断PromiseLike</span>\n\t\t\t\t\tthen.call(\n\t\t\t\t\t\tx,\n\t\t\t\t\t\t<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">y</span>) </span>{\n\t\t\t\t\t\t\t<span class="hljs-keyword">if</span> (called) <span class="hljs-keyword">return</span>;\n\t\t\t\t\t\t\t<span class="hljs-comment">// 递归.then直到获取到非PromiseLike值</span>\n\t\t\t\t\t\t\tcalled = <span class="hljs-literal">true</span>;\n\t\t\t\t\t\t\tresolvePromise(promise2, y, resolve, reject);\n\t\t\t\t\t\t},\n\t\t\t\t\t\t<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">r</span>) </span>{\n\t\t\t\t\t\t\t<span class="hljs-keyword">if</span> (called) <span class="hljs-keyword">return</span>;\n\t\t\t\t\t\t\tcalled = <span class="hljs-literal">true</span>;\n\t\t\t\t\t\t\treject(r);\n\t\t\t\t\t\t},\n\t\t\t\t\t);\n\t\t\t\t} <span class="hljs-keyword">else</span> resolve(x);\n\t\t\t} <span class="hljs-keyword">catch</span> (e) {\n\t\t\t\t<span class="hljs-keyword">if</span> (called) <span class="hljs-keyword">return</span>;\n\t\t\t\tcalled = <span class="hljs-literal">true</span>;\n\t\t\t\treject(e);\n\t\t\t}\n\t\t} <span class="hljs-keyword">else</span> resolve(x);\n\t}\n})(<span class="hljs-built_in">window</span>);\n</code></pre><h2>Promise.resolve（rejecct）</h2><pre><code class="language-js">MyPromise.resolve = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>{\n\t<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>) </span>{\n\t\tresolve(value);\n\t});\n};\nMyPromise.reject = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">reason</span>) </span>{\n\t<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>{\n\t\treject(reason);\n\t});\n};\n</code></pre><h2>Promise.all</h2><pre><code class="language-js">MyPromise.all = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">iterable</span>) </span>{\n\t<span class="hljs-keyword">var</span> _len = iterable.length, <span class="hljs-comment">// 数组长度</span>\n\t\t_endCount = <span class="hljs-number">0</span>, <span class="hljs-comment">// 记录整个数组处理完成的数量</span>\n\t\t_res = []; <span class="hljs-comment">// 结果</span>\n\t<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>{\n\t\t<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> p = <span class="hljs-number">0</span>; p &lt; _len; p++) {\n\t\t\t(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">idx, el</span>) </span>{\n\t\t\t\t<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolveEl</span>(<span class="hljs-params">el, resolve, reject</span>) </span>{\n\t\t\t\t\t<span class="hljs-comment">// 递归获取PromiseLike的值</span>\n\t\t\t\t\t<span class="hljs-keyword">try</span> {\n\t\t\t\t\t\t<span class="hljs-keyword">if</span> (\n\t\t\t\t\t\t\t((<span class="hljs-keyword">typeof</span> el === <span class="hljs-string">&#39;object&#39;</span> &amp;&amp; el !== <span class="hljs-literal">null</span>) || <span class="hljs-keyword">typeof</span> el === <span class="hljs-string">&#39;function&#39;</span>) &amp;&amp;\n\t\t\t\t\t\t\t<span class="hljs-keyword">typeof</span> el.then === <span class="hljs-string">&#39;function&#39;</span>\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tel.then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">y</span>) </span>{\n\t\t\t\t\t\t\t\tresolveEl(y, resolve, reject);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} <span class="hljs-keyword">else</span> resolve(el);\n\t\t\t\t\t} <span class="hljs-keyword">catch</span> (e) {\n\t\t\t\t\t\treject(e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tresolveEl(\n\t\t\t\t\tel,\n\t\t\t\t\t<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>) </span>{\n\t\t\t\t\t\t_res[idx] = res;\n\t\t\t\t\t\t_endCount++;\n\t\t\t\t\t\t<span class="hljs-keyword">if</span> (_endCount === _len) resolve(_res); <span class="hljs-comment">// 整个数组都处理完成了，all resolve</span>\n\t\t\t\t\t},\n\t\t\t\t\t<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">r</span>) </span>{\n\t\t\t\t\t\treject(r); <span class="hljs-comment">// 任意一个成员处理失败，抛出异常</span>\n\t\t\t\t\t},\n\t\t\t\t);\n\t\t\t})(p, iterable[p]); <span class="hljs-comment">// 作用域隔离</span>\n\t\t}\n\t});\n};\n\nMyPromise.all([\n\t<span class="hljs-number">1</span>,\n\t<span class="hljs-number">2</span>,\n\t<span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> resolve(<span class="hljs-number">3</span>)),\n\t<span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> resolve(<span class="hljs-number">4</span>)),\n\t<span class="hljs-comment">// new MyPromise((resolve, reject) =&gt; reject(5)),</span>\n]).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> {\n\t<span class="hljs-built_in">console</span>.log(res);\n});\n</code></pre></body></html>',1),p=[e];function c(s,a){return Object(t["z"])(),Object(t["h"])("section",l,p)}var o=n("6b0d"),r=n.n(o);const i={},h=r()(i,[["render",c]]);a["default"]=h},"2c28":function(s,a,n){"use strict";n.r(a);var t=n("7a23"),l={class:"markdown-body"},e=Object(t["j"])('<html><head></head><body><h1>深拷贝实现</h1><h2>es6</h2><p>要处理循环引用，同时要继承对应原型。</p><p>es6 处理循环引用可以不借助数组，而借助 <code>WeakMap</code> 对引用进行保存，保证内存健康</p><pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myDeepCopy</span>(<span class="hljs-params">target</span>) </span>{\n\t<span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>();\n\t<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isArr</span>(<span class="hljs-params">tar</span>) </span>{\n\t\t<span class="hljs-comment">// 判断数组</span>\n\t\t<span class="hljs-keyword">return</span> {}.toString.call(tar) === <span class="hljs-string">&#39;[object Array]&#39;</span>;\n\t}\n\t<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myDeepCopyInner</span>(<span class="hljs-params">target</span>) </span>{\n\t\t<span class="hljs-comment">// 基本类型直接返回对应的值</span>\n\t\t<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> target !== <span class="hljs-string">&#39;object&#39;</span> || target == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> target;\n\t\t<span class="hljs-comment">// 一些特殊的类型，可以直接借助构造器进行深拷贝</span>\n\t\t<span class="hljs-keyword">if</span> (target <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Date</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(target);\n\t\t<span class="hljs-keyword">if</span> (target <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">RegExp</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(target);\n\n\t\t<span class="hljs-comment">// 若有对应的引用记录，说明该引用的对象已经进行过深拷贝，返回对应的结果</span>\n\t\t<span class="hljs-keyword">if</span> (map.get(target)) <span class="hljs-keyword">return</span> map.get(target);\n\n\t\t<span class="hljs-comment">// 引用型的值，偷懒可以直接调用其构造器，不过不保证构造器不会报错</span>\n\t\t<span class="hljs-keyword">let</span> result;\n\t\t<span class="hljs-keyword">try</span> {\n\t\t\tresult = <span class="hljs-keyword">new</span> target.constructor();\n\t\t} <span class="hljs-keyword">catch</span> {\n\t\t\tresult = isArr(target) ? [] : {};\n\t\t}\n\t\t<span class="hljs-comment">// 记录深拷贝结果</span>\n\t\tmap.set(target, result);\n\t\t<span class="hljs-keyword">for</span> (k <span class="hljs-keyword">in</span> target) {\n\t\t\t<span class="hljs-comment">// 遍历成员变量进行递归</span>\n\t\t\t<span class="hljs-keyword">if</span> ({}.hasOwnProperty.call(target, k)) {\n\t\t\t\tresult[k] = myDeepCopyInner(target[k]);\n\t\t\t}\n\t\t}\n\t\t<span class="hljs-keyword">return</span> result;\n\t}\n\t<span class="hljs-keyword">return</span> myDeepCopyInner(target);\n}\n</code></pre><h2>es5</h2><h3>处理循环引用</h3><p>处理循环引用的手段是<code>利用引用型变量的特点，用数组记录已经被深拷贝过的变量及其结果</code></p><p>在下一次发现数组中的引用又被要求拷贝的时候，直接返回其结果的引用。</p><p>其中的重点在于数组中记录的是引用，<code>不可等成员都deepCopy结束再放入数组，而应该在其之前</code>。否则成员变量中又有上层节点的引用的话 deepCopy 就会调用栈溢出了</p><pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myDeepCopy</span>(<span class="hljs-params">target</span>) </span>{\n\t<span class="hljs-keyword">var</span> copiedArrSource = []; <span class="hljs-comment">// 记录已经进行过深拷贝的对象引用</span>\n\t<span class="hljs-keyword">var</span> copiedArrTarget = []; <span class="hljs-comment">// 记录已经进行过深拷贝的结果对象引用</span>\n\t<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isArr</span>(<span class="hljs-params">tar</span>) </span>{\n\t\t<span class="hljs-comment">// 判断数组</span>\n\t\t<span class="hljs-keyword">return</span> {}.toString.call(tar) === <span class="hljs-string">&#39;[object Array]&#39;</span>;\n\t}\n\t<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myDeepCopyInner</span>(<span class="hljs-params">target</span>) </span>{\n\t\t<span class="hljs-comment">// 基本类型直接返回对应的值</span>\n\t\t<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> target !== <span class="hljs-string">&#39;object&#39;</span> || target == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> target;\n\n\t\t<span class="hljs-comment">// 若有对应的引用记录，说明该引用的对象已经进行过深拷贝，返回对应的结果</span>\n\t\t<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; copiedArrSource.length; i++) {\n\t\t\t<span class="hljs-keyword">if</span> (copiedArrSource[i] === target) <span class="hljs-keyword">return</span> copiedArrTarget[i];\n\t\t}\n\n\t\t<span class="hljs-comment">// 引用型的值，区分数组和对象</span>\n\t\t<span class="hljs-keyword">var</span> result = isArr(target) ? [] : {};\n\t\t<span class="hljs-comment">// 记录深拷贝结果，防止循环引用，必须在递归前写入数组</span>\n\t\tcopiedArrSource.push(target);\n\t\tcopiedArrTarget.push(result);\n\t\t<span class="hljs-keyword">for</span> (k <span class="hljs-keyword">in</span> target) {\n\t\t\t<span class="hljs-comment">// 遍历成员变量进行递归</span>\n\t\t\t<span class="hljs-keyword">if</span> ({}.hasOwnProperty.call(target, k)) {\n\t\t\t\tresult[k] = myDeepCopyInner(target[k]);\n\t\t\t}\n\t\t}\n\t\t<span class="hljs-keyword">return</span> result;\n\t}\n\t<span class="hljs-keyword">return</span> myDeepCopyInner(target);\n}\n</code></pre><h3>不处理循环引用</h3><p>不处理循环引用的话非常简单</p><pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isArr</span>(<span class="hljs-params">tar</span>) </span>{\n\t<span class="hljs-keyword">return</span> {}.toString.call(tar) === <span class="hljs-string">&#39;[object Array]&#39;</span>;\n}\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myDeepCopy</span>(<span class="hljs-params">target</span>) </span>{\n\t<span class="hljs-comment">// 基本类型直接返回对应的值</span>\n\t<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> target !== <span class="hljs-string">&#39;object&#39;</span> || target == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> target;\n\t<span class="hljs-comment">// 引用型的值，区分数组和对象</span>\n\t<span class="hljs-keyword">var</span> result = isArr(target) ? [] : {};\n\t<span class="hljs-keyword">for</span> (k <span class="hljs-keyword">in</span> target) {\n\t\t<span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.prototype.hasOwnProperty.call(target, k)) {\n\t\t\tresult[k] = myDeepCopy(target[k]);\n\t\t}\n\t}\n\t<span class="hljs-keyword">return</span> result;\n}\n</code></pre></body></html>',1),p=[e];function c(s,a){return Object(t["z"])(),Object(t["h"])("section",l,p)}var o=n("6b0d"),r=n.n(o);const i={},h=r()(i,[["render",c]]);a["default"]=h},"2cce":function(s,a,n){"use strict";n("c658")},3168:function(s,a,n){"use strict";n.r(a);var t=n("7a23"),l={class:"markdown-body"},e=Object(t["j"])('<html><head></head><body><h1>编译器复习，the-super-tiny-compiler 源码中文注释</h1><p>编译过程主要内容</p><ol><li>词法分析，将源代码字符串拆分为<code>token</code>列表。</li><li>语法分析，通过对<code>token列表</code>进行遍历，构筑成可以描述源代码语义的<code>抽象语法树（AST）</code>。</li><li>AST 变换，通过遍历 AST 树，对 AST 树进行语义上的理解和结构上的调整及转换</li><li>目标代码生成，也可作为 3 中的一部分。通过遍历 AST 树通过对 AST 结构的解析拼接出最终的目标代码。</li></ol><p><a href="https://github.com/czzczz/the-super-tiny-compiler">仓库地址</a></p><h2>实战</h2><p>Vue 用的 VSCode 插件。内部使用<code>自建Vue模板编译器</code>以及 <code>TS Compiler</code> 对 Vue 单文件组件进行解析并实现其他功能</p><ol><li>通过模板编译收集模板内的作用域变量、CSS 内的 class 变量，通过<code>TS Compiler</code>收集<code>script</code>中的变量，以此实现对应的定义跳转。</li><li>通过<code>TS Compiler</code>生成 AST 树，解析函数 Node 节点信息以 <code>自动生成 JSDOC 注释</code></li></ol><p><a href="https://github.com/czzczz/helpue">Helpue</a></p></body></html>',1),p=[e];function c(s,a){return Object(t["z"])(),Object(t["h"])("section",l,p)}var o=n("6b0d"),r=n.n(o);const i={},h=r()(i,[["render",c]]);a["default"]=h},"326e":function(s,a,n){},"32f5":function(s,a,n){"use strict";n.r(a);var t=n("7a23"),l={class:"markdown-body"},e=Object(t["j"])('<html><head></head><body><h1>ts 类型断言</h1><p>通过<code>as</code>关键字可以强制指定某个变量的类型，以此来避免类型检查带来的必须对逻辑进行修改的情况。</p><pre><code class="language-ts"><span class="hljs-keyword">interface</span> Foo {\n\t<span class="hljs-attr">bar</span>: <span class="hljs-built_in">number</span>;\n\tbas: <span class="hljs-built_in">string</span>;\n}\n\n<span class="hljs-keyword">const</span> foo = {} <span class="hljs-keyword">as</span> Foo;\nfoo.bar = <span class="hljs-number">123</span>;\nfoo.bas = <span class="hljs-string">&#39;hello&#39;</span>;\n</code></pre><p>若不进行断言，上述代码对空对象的再次赋值将会报错，这种情况在 js 迁移到 ts 时可能会遇到。</p><h2>类型断言被认为是有害的</h2><p>如果没有按约定添加属性，TypeScript 编译器并不会对此发出错误警告。</p><pre><code class="language-ts"><span class="hljs-keyword">interface</span> Foo {\n\t<span class="hljs-attr">bar</span>: <span class="hljs-built_in">number</span>;\n\tbas: <span class="hljs-built_in">string</span>;\n}\n\n<span class="hljs-keyword">const</span> foo = {} <span class="hljs-keyword">as</span> Foo;\n\n<span class="hljs-comment">// ahhh, 忘记了什么？</span>\n</code></pre><pre><code class="language-ts"><span class="hljs-keyword">interface</span> Foo {\n\t<span class="hljs-attr">bar</span>: <span class="hljs-built_in">number</span>;\n\tbas: <span class="hljs-built_in">string</span>;\n}\n\n<span class="hljs-keyword">const</span> foo: Foo = {\n\t<span class="hljs-comment">// 编译器将会提供 Foo 属性的代码提示</span>\n};\n</code></pre><h2>双重断言</h2><p>当使用者了解传入参数更具体的类型时，类型断言能按预期工作:</p><pre><code class="language-ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handler</span>(<span class="hljs-params">event: Event</span>) </span>{\n\t<span class="hljs-keyword">const</span> mouseEvent = event <span class="hljs-keyword">as</span> MouseEvent;\n}\n</code></pre><p>然而，如下例子中的代码将会报错，尽管使用者已经使用了类型断言</p><pre><code class="language-ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handler</span>(<span class="hljs-params">event: Event</span>) </span>{\n\t<span class="hljs-keyword">const</span> element = event <span class="hljs-keyword">as</span> HTMLElement; <span class="hljs-comment">// Error: &#39;Event&#39; 和 &#39;HTMLElement&#39; 中的任何一个都不能赋值给另外一个</span>\n}\n</code></pre><p>这时，可以先断言为 any，再断言为另一个：</p><pre><code class="language-ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handler</span>(<span class="hljs-params">event: Event</span>) </span>{\n\t<span class="hljs-keyword">const</span> element = (event <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>) <span class="hljs-keyword">as</span> HTMLElement; <span class="hljs-comment">// ok</span>\n}\n</code></pre><h3>TypeScript 是怎么确定单个断言是否足够</h3><p>当 S 类型是 T 类型的子集，或者 T 类型是 S 类型的子集时，S 能被成功断言成 T。这是为了在进行类型断言时提供额外的安全性，完全毫无根据的断言是危险的，如果你想这么做，你可以使用 any。</p></body></html>',1),p=[e];function c(s,a){return Object(t["z"])(),Object(t["h"])("section",l,p)}var o=n("6b0d"),r=n.n(o);const i={},h=r()(i,[["render",c]]);a["default"]=h},3488:function(s,a,n){"use strict";n.r(a);var t=n("7a23"),l={class:"markdown-body"},e=Object(t["j"])('<html><head></head><body><h1>uni-app cli</h1><p>通过 cli 版创建项目依赖于<a href="https://cli.vuejs.org/zh/">vue-cli</a>。</p><pre><code class="language-bash">npm install -g @vue/cli\nvue create -p dcloudio/uni-preset-vue my-project-name\n</code></pre><h2>常用插件</h2><p>uni-app 的 cli 版要安装插件须自行通过 npm 安装对应的包。且由于 uni-app 本身依赖的 node 版本较低，所以需要调整 node 版本的同时再安装依赖。</p><pre><code class="language-bash"><span class="hljs-comment"># 安装nvm</span>\ncurl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.38.0/install.sh | bash\n<span class="hljs-comment"># 重启终端</span>\n<span class="hljs-comment"># 安装并使用node8</span>\nnvm install v8.17.0\nnvm use v8.17.0\n</code></pre><h3>less-loader</h3><p>uni-app 使用的 less-loader 版本须为<code>less4</code>与<code>less-loader7</code>（node8 环境，<code>20210421可用</code>）。</p><pre><code class="language-json">{\n\t<span class="hljs-attr">&quot;less&quot;</span>: <span class="hljs-string">&quot;^4.1.1&quot;</span>,\n\t<span class="hljs-attr">&quot;less-loader&quot;</span>: <span class="hljs-string">&quot;^7.3.0&quot;</span>\n}\n</code></pre><h3>scss-loader</h3><p>uni-app 使用的 sass-loader 版本须为<code>node-sass4</code>与<code>sass-loader8</code>（node8 环境，<code>20210421可用</code>）。</p><pre><code class="language-json">{\n\t<span class="hljs-attr">&quot;node-sass&quot;</span>: <span class="hljs-string">&quot;^4.14.1&quot;</span>,\n\t<span class="hljs-attr">&quot;sass-loader&quot;</span>: <span class="hljs-string">&quot;^8.0.2&quot;</span>\n}\n</code></pre><h4>别用 node-sass 是更优方案的样子</h4><pre><code class="language-json">{\n\t<span class="hljs-attr">&quot;sass&quot;</span>: <span class="hljs-string">&quot;^1.34.1&quot;</span>,\n\t<span class="hljs-attr">&quot;sass-loader&quot;</span>: <span class="hljs-string">&quot;^8.0.2&quot;</span>\n}\n</code></pre><p>然后配置 vue.config.js</p><pre><code class="language-js"><span class="hljs-built_in">exports</span>.css = {\n\t<span class="hljs-attr">loaderOptions</span>: {\n\t\t<span class="hljs-attr">sass</span>: {\n\t\t\t<span class="hljs-attr">implementation</span>: <span class="hljs-built_in">require</span>(<span class="hljs-string">&#39;sass&#39;</span>), <span class="hljs-comment">// 重新指定dart-sass为sass-loader的sdk源</span>\n\t\t},\n\t},\n};\n</code></pre></body></html>',1),p=[e];function c(s,a){return Object(t["z"])(),Object(t["h"])("section",l,p)}var o=n("6b0d"),r=n.n(o);const i={},h=r()(i,[["render",c]]);a["default"]=h},"35b4":function(s,a,n){s.exports=n.p+"img/径向渐变.c8d511c3.png"},3832:function(s,a,n){"use strict";n("e0c1")},"3bdc":function(s,a,n){"use strict";n("de73")},"3c26":function(s,a,n){},"3e03":function(s,a,n){},"3f28":function(s,a,n){"use strict";n.r(a);var t=n("7a23"),l={class:"markdown-body"},e=Object(t["j"])('<html><head></head><body><h1>JS 遍历</h1><h2>对于对象的遍历</h2><h3>for...in</h3><p>通过获取对象的全部 key 对对象进行遍历，以任意顺序遍历一个对象的除<code>Symbol</code>以外的<code>可枚举属性</code></p><ul><li>遍历的 key 顺序不定</li><li>全部 key 包括原型链上继承的 key</li><li>若传入的的目标为基础数据类型，不会执行内部语句，<strong>若目标为 string，string 会被作为字符数组遍历（即获取 index）</strong></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Enumerability_and_ownership_of_properties">可枚举</a></li></ul><pre><code class="language-js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> target) {\n\t<span class="hljs-built_in">console</span>.log(key, target[key]);\n}\n</code></pre><h3>Object.keys</h3><p>接收一个参数并返回该参数的除<code>Symbol</code>以外的<code>可枚举属性</code></p><ul><li>遍历的 key 顺序不定</li><li>全部 key 只包括对象自身的，不包括继承的</li><li>若传入的的目标为基础数据类型，返回空数组，<strong>若目标为 null 或 undefined 会报 TypeError</strong></li></ul><pre><code class="language-js"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.keys(target));\n</code></pre><h3>Reflect.ownKeys</h3><p>返回一个由目标对象自身的属性键组成的数组。它的返回值等同于<code>Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target))</code>。</p><p>忽略 enumerable 描述符</p><h3>Object.getOwnProperties</h3><p>接收一个参数并返回该参数的除<code>Symbol</code>以外的属性，忽略 enumerable 描述符</p><pre><code class="language-js"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.getOwnProperties(target));\n</code></pre><h3>for...of</h3><p>根据<code>可迭代协议</code>对对象进行迭代。</p><ul><li>须目标符合可迭代协议，否则报 TypeError。</li></ul><pre><code class="language-js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> val <span class="hljs-keyword">of</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]) {\n\t<span class="hljs-built_in">console</span>.log(val);\n}\n</code></pre><h3>for await (val of target)</h3><p>for await...of 与 for...of 类似，须配合<code>异步迭代协议</code>，同时<code>与 await 语句一样只能在 async 函数中使用</code>。</p><ul><li>本身遍历对象跟 await 一样可以是同步对象也可以是 PromiseLike 异步<a href="/#/notes/javascript/Promise.md">async,await</a></li><li>若为 <code>PromiseLike</code> 其后跟随的代码块内容会在 <code>resolve之后</code> 执行</li></ul><h3>for (var i = 0; i &lt; max; i++) {}</h3><p>基本 for 循环。需要注意的是若 i 通过 var 定义，会作为外部变量，因此代码块内存在异步代码需要对该情况作处理</p><pre><code class="language-js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(i)); <span class="hljs-comment">// 打印结果并非0-9，而是10个10</span>\n</code></pre><p>let 声明会生成块级作用域解决此问题</p><p>若无法使用 let 也可使用立即执行函数（当然也可是普通函数，我在放屁）覆盖外部作用域的 i</p><pre><code class="language-js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)\n\t(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">i</span>) </span>{\n\t\t<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(i));\n\t})(i);\n</code></pre><h2>数组</h2><p>JS 内置的引用类型，可用于存放一组结构化的数据</p><ol><li>含有属性 length 以及其它原型上的属性及方法。</li><li>toString 行为默认为：对内部所有元素执行一次 toString 后将结果用<code>&quot;,&quot;</code>拼接。</li><li>数组 length 是一个可写的属性，通过设置 length 属性将改变数据实际长度（数组的长度重定义有兼容区别，IE9） <ul><li>若 length 设置的长度比原值小，数据将被裁剪，后边的元素会被抛弃。</li><li>若比原值大，那么数组将被填充。新增的位置视为 <code>empty 值</code>。</li></ul></li><li>数组的 <code>empty 值</code>并非实际的数据值，而是描述<strong>数组长度覆盖了该键的位置但数组并不拥有该键</strong>，hasOwnProperty 会返回 false。</li><li>数组可以直接通过访问键的方式设置不同位置的值。 <ul><li>若设置值的键名为自然数（大于等于 0 且是整数）且超出当前数组长度，数组的 length 将会被改写，当然其它位置会被填充为 empty。</li></ul></li></ol><h3>数组扩展方法</h3><p>数组的遍历除了使用对象通用方式进行外，还可使用<a href="/#/notes/javascript/implementation/array/%E6%95%B0%E7%BB%84%E6%89%A9%E5%B1%95%E6%96%B9%E6%B3%95.md">数组的扩展方法</a>，不过兼容问题比较严重。</p><h2>类数组</h2><p>结构和字段类似数组的其它对象统称为类数组（<code>arrayLike</code>）</p><h3>Array.from</h3><p>可以将类数组以及可迭代对象转为数组。 参数：</p><ul><li>arrayLike，目标对象遵循一些条件 <ol><li>不能是 null,undefined,number,boolean。</li><li>string 会作为迭代目标将每个字符转为数组的一项。</li><li>目标对象没有 length，或 length 不是自然数，length 被置为 0，即必定返回空数组。</li><li>目标对应位置没有属性不会作为 <code>empty 值</code>，而会被填充 <code>undefined</code>。</li><li>符合迭代协议的对象即遵循迭代遍历规范依次放入数组。</li></ol></li><li>mapFn，map 的回调，可以对每个元素执行 map 回调后再转为新数组</li><li>thisArg，map 回调的 this 指向</li></ul></body></html>',1),p=[e];function c(s,a){return Object(t["z"])(),Object(t["h"])("section",l,p)}var o=n("6b0d"),r=n.n(o);const i={},h=r()(i,[["render",c]]);a["default"]=h},4357:function(s,a,n){s.exports=n.p+"img/outline.a8406093.png"},4607:function(s,a,n){"use strict";n.r(a);var t=n("7a23"),l={class:"markdown-body"},e=Object(t["j"])('<html><head></head><body><h1>对构造函数的 new 操作实现</h1><h2>new 的特点</h2><ol><li>接收一个构造器以及对应构造器的若干参数</li><li>会返回一个 new 的结果对象，该对象是经过构造器处理过的</li><li>若构造器返回一个自定义的引用型变量，则 new 的结果也是该变量，否则才是 new 中指定的带有原型链的对象（传给构造器的 this）</li></ol><pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myNew</span>(<span class="hljs-params">con, args</span>) </span>{\n\t<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> con !== <span class="hljs-string">&#39;function&#39;</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&#39;con is not a constructor&#39;</span>);\n\t<span class="hljs-keyword">if</span> (args == <span class="hljs-literal">null</span>) args = [];\n\t<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ({}.toString.call(args) !== <span class="hljs-string">&#39;[object Array]&#39;</span>) args = [args];\n\t<span class="hljs-keyword">var</span> _this = {\n\t\t<span class="hljs-attr">__proto__</span>: con.prototype, <span class="hljs-comment">// 继承原型</span>\n\t};\n\t<span class="hljs-keyword">var</span> _newObj = con.apply(_this, args); <span class="hljs-comment">// 把 this 替换成新对象调用目标构造器</span>\n\t<span class="hljs-comment">// 若构造器返回了一个引用型变量则直接将该对象作为 new 的结果</span>\n\t<span class="hljs-keyword">if</span> ((<span class="hljs-keyword">typeof</span> _newObj === <span class="hljs-string">&#39;object&#39;</span> &amp;&amp; _newObj != <span class="hljs-literal">null</span>) || <span class="hljs-keyword">typeof</span> _newObj === <span class="hljs-string">&#39;function&#39;</span>) <span class="hljs-keyword">return</span> _newObj;\n\t<span class="hljs-keyword">return</span> _this; <span class="hljs-comment">// 否则返回构造器处理过的 _this 对象</span>\n}\n</code></pre></body></html>',1),p=[e];function c(s,a){return Object(t["z"])(),Object(t["h"])("section",l,p)}var o=n("6b0d"),r=n.n(o);const i={},h=r()(i,[["render",c]]);a["default"]=h},"47c0":function(s,a,n){"use strict";n("0dbe")},"4b77":function(s,a,n){"use strict";var t=n("7a23");function l(s,a,n,l,e,p){return Object(t["z"])(),Object(t["f"])(t["b"],Object(t["L"])(s.on),{default:Object(t["Q"])((function(){return[Object(t["G"])(s.$slots,"default",{},void 0,!0)]})),_:3},16)}var e=Object(t["m"])({name:"ShutBCollapseTransition",setup:function(){var s={paddingTop:"",paddingBottom:"",overflowY:"",height:""},a={beforeEnter:function(s){s.classList.add("shut-b-collapse-transition")},enter:function(a){a.style.height="0px";var n=window.getComputedStyle(a);s.paddingTop=n.paddingTop,s.paddingBottom=n.paddingBottom,s.overflowY=n.overflowY,a.style.paddingTop=a.style.paddingBottom="0",a.style.overflowY="hidden",a.style.height=a.scrollHeight+"px"},afterEnter:function(a){a.classList.remove("shut-b-collapse-transition"),s.height=a.style.height,a.style.height="",a.style.overflowY=s.overflowY||""},beforeLeave:function(s){s.classList.add("shut-b-collapse-transition")},leave:function(a){a.style.transitionProperty="height",a.style.paddingTop=s.paddingTop||"",a.style.paddingBottom=s.paddingBottom||"",a.style.overflowY="hidden",a.style.height=s.height||"",a.offsetHeight,a.style.height="0px"},afterLeave:function(a){a.classList.remove("shut-b-collapse-transition"),a.style.height="",a.style.overflowY=s.overflowY||""}};return{on:a}}}),p=(n("1fa6"),n("6b0d")),c=n.n(p);const o=c()(e,[["render",l],["__scopeId","data-v-cfd9bfdc"]]);a["a"]=o},"4ce0":function(s,a,n){"use strict";var t=n("7a23");function l(s,a,n,l,e,p){return Object(t["z"])(),Object(t["h"])(t["a"],null,[s.group?Object(t["g"])("",!0):(Object(t["z"])(),Object(t["f"])(t["b"],Object(t["q"])({key:0},s.attrs,Object(t["L"])(s.hooks)),{default:Object(t["Q"])((function(){return[Object(t["G"])(s.$slots,"default",{},void 0,!0)]})),_:3},16)),s.group?(Object(t["z"])(),Object(t["f"])(t["c"],Object(t["q"])({key:1},s.attrs,Object(t["L"])(s.hooks)),{default:Object(t["Q"])((function(){return[Object(t["G"])(s.$slots,"default",{},void 0,!0)]})),_:3},16)):Object(t["g"])("",!0)],64)}n("a9e3");var e=function(s,a){var n=function(a){a.style.transitionDuration="".concat(s.duration,"ms")},l=function(s){s.style.transitionDuration=""},e=function(s,n){a(s,n)},p=function(s){n(s),e("beforeEnter",s)},c=function(s){n(s),e("beforeLeave",s)},o=function(s){e("enter",s)},r=function(s){e("leave",s)},i=function(s){e("appear",s)},h=function(s){l(s),e("afterEnter",s)},d=function(s){l(s),e("afterLeave",s)},j=function(s){e("afterAppear",s)},u=Object(t["d"])((function(){return{beforeEnter:p,beforeLeave:c,enter:o,leave:r,appear:i,afterEnter:h,afterLeave:d,afterAppear:j}}));return{hooks:u}},p=Object(t["m"])({name:"ShutBTransition",setup:function(s,a){var n=a.attrs,t=a.emit,l=e(s,t),p=l.hooks;return{attrs:n,emit:t,hooks:p}},props:{group:{type:Boolean,default:!1},duration:{type:Number,default:300}},emits:{beforeEnter:function(s){return!!s},beforeLeave:function(s){return!!s},enter:function(s){return!!s},leave:function(s){return!!s},appear:function(s){return!!s},afterEnter:function(s){return!!s},afterLeave:function(s){return!!s},afterAppear:function(s){return!!s}}}),c=(n("2cce"),n("6b0d")),o=n.n(c);const r=o()(p,[["render",l],["__scopeId","data-v-c92bf9ba"]]);a["a"]=r},"50e1":function(s,a,n){"use strict";n.r(a);var t=n("7a23"),l={class:"markdown-body"},e=Object(t["j"])('<html><head></head><body><h1>TS 的高级类型应用</h1><p>通过 ts 语法让编译器自行推断变量类型</p><h2>交叉和联合</h2><h3>交叉类型</h3><pre><code class="language-ts"><span class="hljs-keyword">type</span> B = A &amp; C;\n</code></pre><p>B 将会拥有 A 和 C 的所有类型及成员，<code>若A和C存在两个同名但是不同类型的成员，则该成员的类型也会进行对应的交叉</code></p><h3>联合类型</h3><pre><code class="language-ts"><span class="hljs-keyword">type</span> B = A | C;\n</code></pre><p>B 既可以是 A 类型也可以是 C 类型，在接收不定类型参数时常常会用到</p><h3>针对联合类型的类型保护和区分</h3><p>对应基本类型如<code>number</code>及<code>string</code>等，可以直接用<code>typeof</code>进行类型区分 但是如果是一个自定义的复杂类型，需要定义一个类型保护函数（近似于 js 里根据是否存在某个成员来区分对象属性） 之后便可通过该函数来区分一个联合类型，ts 可以对其进行正确的类型推断</p><pre><code class="language-ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isFish</span>(<span class="hljs-params">pet: Fish | Bird</span>): <span class="hljs-title">pet</span> <span class="hljs-title">is</span> <span class="hljs-title">Fish</span> </span>{\n\t<span class="hljs-keyword">return</span> (&lt;Fish&gt;pet).swim !== <span class="hljs-literal">undefined</span>;\n}\n\n<span class="hljs-keyword">if</span> (isFish(pet)) pet.swim();\n<span class="hljs-keyword">else</span> pet.fly();\n</code></pre><h2>常用的内置高级类型</h2><h3>Record</h3><p>将 K 中的每个属性(类型为 K，若为字符串字面量就只有对应的一个属性)，都转为 T 类型</p><pre><code class="language-ts"><span class="hljs-keyword">type</span> Record&lt;K <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>, T&gt; = {\n\t[P <span class="hljs-keyword">in</span> K]: T;\n};\n\n<span class="hljs-keyword">type</span> BB = Record&lt;<span class="hljs-built_in">string</span>, MayBe&gt;;\n</code></pre><h3>Pick</h3><p>取出 T 中的对应的 key 构成新类型</p><pre><code class="language-ts"><span class="hljs-keyword">type</span> Pick&lt;T, K <span class="hljs-keyword">extends</span> keyof T&gt; = {\n\t[P <span class="hljs-keyword">in</span> K]: T[P];\n};\n\n<span class="hljs-keyword">type</span> BB = Pick&lt;May, <span class="hljs-string">&#39;data&#39;</span> | <span class="hljs-string">&#39;dataKey&#39;</span>&gt;;\n</code></pre><h3>Omit</h3><p>去除类型中的对应成员</p><pre><code class="language-ts"><span class="hljs-comment">// 用Exclude取出T中没有在K存在的成员，然后用Pick取出其对应类型生成新的类型</span>\n<span class="hljs-keyword">type</span> Omit&lt;T, K <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span> | symbol&gt; = Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;;\n\n<span class="hljs-keyword">type</span> AA = {\n\t<span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>;\n\tname: <span class="hljs-built_in">string</span>;\n\tvalue?: <span class="hljs-built_in">number</span>;\n};\n<span class="hljs-keyword">type</span> CC = Omit&lt;AA, <span class="hljs-string">&#39;id&#39;</span> | <span class="hljs-string">&#39;value&#39;</span>&gt;; <span class="hljs-comment">// { name: string }</span>\n</code></pre><h3>Readonly</h3><p>将一个类型的所有成员转变为只读的</p><pre><code class="language-ts"><span class="hljs-keyword">type</span> Readonly&lt;T&gt; = {\n\t<span class="hljs-keyword">readonly</span> [P <span class="hljs-keyword">in</span> keyof T]: T[P];\n};\n</code></pre><h3>Partial</h3><p>将一个类型的所有成员转变为可选的</p><pre><code class="language-ts"><span class="hljs-keyword">type</span> Partial&lt;T&gt; = {\n\t[P <span class="hljs-keyword">in</span> keyof T]?: T[P];\n};\n</code></pre><h2>常用的条件类型</h2><h3>Exclude&lt;T, U&gt;</h3><p>用于从类型 T 中去除不在 U 类型中的成员，<code>即取A对B的差集</code></p><pre><code class="language-ts"><span class="hljs-keyword">type</span> AA = <span class="hljs-number">1</span> | <span class="hljs-number">2</span> | <span class="hljs-number">3</span> | <span class="hljs-number">4</span>;\n<span class="hljs-keyword">type</span> BB = <span class="hljs-number">1</span> | <span class="hljs-number">2</span> | <span class="hljs-number">5</span>;\n<span class="hljs-keyword">type</span> CC = Exclude&lt;AA, BB&gt;; <span class="hljs-comment">// 3 | 4</span>\n</code></pre><h3>Extract&lt;T, U&gt;</h3><p>用于从类型 T 中取出可分配给 U 类型的成员，<code>即取二者交集</code></p><pre><code class="language-ts"><span class="hljs-keyword">type</span> AA = <span class="hljs-number">1</span> | <span class="hljs-number">2</span> | <span class="hljs-number">3</span> | <span class="hljs-number">4</span>;\n<span class="hljs-keyword">type</span> BB = <span class="hljs-number">1</span> | <span class="hljs-number">2</span> | <span class="hljs-number">5</span>;\n<span class="hljs-keyword">type</span> CC = Extract&lt;AA, BB&gt;; <span class="hljs-comment">// 1 | 2</span>\n</code></pre><h3>NonNullable&lt;T&gt;</h3><p>用于从类型 T（联合类型） 中去除 undefined 和 null 类型</p><pre><code class="language-ts"><span class="hljs-keyword">type</span> AA = <span class="hljs-number">1</span> | <span class="hljs-number">2</span> | <span class="hljs-number">3</span> | <span class="hljs-number">4</span> | <span class="hljs-literal">undefined</span> | <span class="hljs-literal">null</span>;\n<span class="hljs-keyword">type</span> CC = NonNullable&lt;AA&gt;; <span class="hljs-comment">// 1 | 2 | 3 | 4</span>\n</code></pre><h3>ReturnType&lt;T&gt;</h3><p>获取函数类型的返回类型</p><pre><code class="language-ts"><span class="hljs-keyword">type</span> AA = <span class="hljs-function">(<span class="hljs-params">data: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">number</span>;\n<span class="hljs-keyword">type</span> CC = ReturnType&lt;AA&gt;; <span class="hljs-comment">// number</span>\n</code></pre><h3>InstanceType&lt;T&gt;</h3><p>获取构造函数的实例类型</p><pre><code class="language-ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AA</span> </span>{}\n<span class="hljs-keyword">type</span> CC = InstanceType&lt;<span class="hljs-keyword">typeof</span> AA&gt;; <span class="hljs-comment">// AA</span>\n</code></pre></body></html>',1),p=[e];function c(s,a){return Object(t["z"])(),Object(t["h"])("section",l,p)}var o=n("6b0d"),r=n.n(o);const i={},h=r()(i,[["render",c]]);a["default"]=h},"523d":function(s,a,n){"use strict";n.r(a);var t=n("7a23"),l={class:"markdown-body"},e=Object(t["i"])("html",null,[Object(t["i"])("head"),Object(t["i"])("body",null,[Object(t["i"])("h1",null,"link VS import"),Object(t["i"])("ol",null,[Object(t["i"])("li",null,"link 属于 HTML 标签，而@import 是 CSS 提供的;"),Object(t["i"])("li",null,"页面被加载的时，link 会同时被加载，而@import 引用的 CSS 会等到页面被加载完再加载;"),Object(t["i"])("li",null,"import 只在 IE5 以上才能识别，而 link 是 HTML 标签，无兼容问题;")])])],-1),p=[e];function c(s,a){return Object(t["z"])(),Object(t["h"])("section",l,p)}var o=n("6b0d"),r=n.n(o);const i={},h=r()(i,[["render",c]]);a["default"]=h},5379:function(s,a){s.exports="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAqMAAAERCAYAAABPda6LAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAAEnQAABJ0Ad5mH3gAAAWgSURBVHhe7dgxTtxQFEDRMV0EBUJCstxY2U+WNzuBJcw2JlGapEBCaZLWYMtiB8xF4Zzmv/9WcPWGcZqXw6vbu/v1AV79eX46fLm+2X8AwHu52l8AALi4t8vo+XTcFgAAcCkuowAAZMQoAAAZMQoAQEaMAgCQEaMAAGTEKAAAGTEKAEBGjAIAkBGjAABkxCgAABkxCgBARowCAJARowAAZMQoAAAZMQoAQEaMAgCQEaMAAGTEKAAAGTEKAEBGjAIAkBGjAABkxCgAABkxCgBARowCAJARowAAZMQoAAAZMQoAQEaMAgCQEaMAAGTEKAAAGTEKAEBGjAIAkBGjAABkxCgAABkxCgBARowCAJARowAAZIZxmpd1OJ+O2+KjuP76bZ/4LP7+eNwnAOCzcBkFACAjRgEAyIhRAAAyYhQAgIwYBQAgI0YBAMiIUQAAMmIUAICMGAUAICNGAQDIiFEAADJiFACAjBgFACAjRgEAyIhRAAAyYhQAgIwYBQAgI0YBAMiIUQAAMmIUAICMGAUAICNGAQDIiFEAADJiFACAjBgFACAjRgEAyIhRAAAyYhQAgIwYBQAgI0YBAMiIUQAAMmIUAICMGAUAICNGAQDIiFEAADJiFACAjBgFACAjRgEAyIhRAAAyYhQAgIwYBQAgI0YBAMiIUQAAMmIUAICMGAUAICNGAQDIiFEAADJiFACAjBgFACAjRgEAyIhRAAAyYhQAgIwYBQAgI0YBAMiIUQAAMmIUAICMGAUAICNGAQDIiFEAADJiFACAjBgFACAjRgEAyIhRAAAyYhQAgIwYBQAgI0YBAMiIUQAAMmIUAICMGAUAICNGAQDIiFEAADJiFACAjBgFACAjRgEAyIhRAAAyYhQAgIwYBQAgI0YBAMiIUQAAMmIUAICMGAUAICNGAQDIiFEAADJiFACAjBgFACAjRgEAyIhRAAAyYhQAgIwYBQAgI0YBAMiIUQAAMmIUAICMGAUAICNGAQDIiFEAADJiFACAjBgFACAjRgEAyIhRAAAyYhQAgIwYBQAgI0YBAMiIUQAAMmIUAICMGAUAICNGAQDIiFEAADJiFACAjBgFACAjRgEAyIhRAAAyYhQAgIwYBQAgI0YBAMiIUQAAMmIUAICMGAUAICNGAQDIiFEAADJiFACAjBgFACAjRgEAyIhRAAAyYhQAgMwwTvOyDufTcVsAAMCluIwCAJARowAAZMQoAAAZMQoAQEaMAgCQEaMAAGTEKAAAGTEKAEBGjAIAkBGjAABkxCgAABkxCgBARowCAJARowAAZMQoAAAZMQoAQEaMAgCQEaMAAGTEKAAAGTEKAEBGjAIAkBGjAABkxCgAABkxCgBARowCAJARowAAZMQoAAAZMQoAQEaMAgCQEaMAAGTEKAAAGTEKAEBGjAIAkBGjAABkxCgAABkxCgBAZhineVmH379+bgv+f/++P+wTAEDLZRQAgIwYBQAgI0YBAMiIUQAAMmIUAICMGAUAICNGAQDIiFEAADJiFACAjBgFACAjRgEAyIhRAAAyYhQAgIwYBQAgI0YBAMiIUQAAMmIUAICMGAUAICNGAQDIiFEAADJiFACAjBgFACAjRgEAyIhRAAAyYhQAgIwYBQAgI0YBAMiIUQAAMmIUAICMGAUAICNGAQDIiFEAADJiFACAjBgFACAjRgEAyIhRAAAyYhQAgIwYBQAgI0YBAMiIUQAAMmIUAICMGAUAICNGAQDIiFEAADJiFACAjBgFACAjRgEAyIhRAAAyYhQAgIwYBQAgI0YBAMiIUQAAMmIUAICMGAUAICNGAQDIiFEAADJiFACAjBgFACAjRgEAyIhRAAAyYhQAgIwYBQAgM4zTvKzD7d39tgAAgEtxGQUAICNGAQDIiFEAADJiFACAjBgFACAjRgEAyIhRAAAih8MLFRYcKKhGvnMAAAAASUVORK5CYII="},5490:function(s,a,n){"use strict";n.r(a);var t=n("7a23"),l=n("b014"),e=n.n(l),p={class:"markdown-body"},c=Object(t["j"])('<html><head></head><body><h1>script 标签的 async 与 defer</h1><p>二者都可以使 script 异步执行</p><p><img src="'+e.a+'" alt="async与defer"></p><ul><li><p>若 script 没有这两个标签，dom 解析到 script 标签会暂停执行解析，转而下载资源文件并执行。</p></li><li><p>若 script 有 async，dom 继续解析的同时进行下载，下载完成后 dom 暂停解析并执行 js。</p></li><li><p>若 script 有 defer，下载时继续解析 dom，dom 解析完成后（<code>DOMContentLoaded</code>前）再<strong>顺序</strong>执行 js。</p></li></ul><p>关于 DomContentLoaded 与 onload 的区别。前者代表 dom tree 解析完成，后者则是需要所有图片及 iframe 等子内容加载完成。</p></body></html>',1),o=[c];function r(s,a){return Object(t["z"])(),Object(t["h"])("section",p,o)}var i=n("6b0d"),h=n.n(i);const d={},j=h()(d,[["render",r]]);a["default"]=j},5593:function(s,a,n){"use strict";n.r(a);var t=n("7a23"),l={class:"markdown-body"},e=Object(t["j"])('<html><head></head><body><h1>JS 面向对象</h1><p>JS 的面向对象是基于<code>原型</code>的面向对象，继承关系基于<code>原型链</code>。</p><ul><li><code>prototype</code>：JavaScript 中每个函数都有一个 prototype 属性，此属性指向了该函数的原型对象。</li><li><code>__proto__</code>：JavaScript 中每一个对象（null 除外），包括函数创建的对象、函数自身、原型对象，都有一个<strong>proto</strong>属性，指向了创建该对象的函数的原型。</li><li><code>constructor</code>：该属性属于原型对象，指向相关的构造函数。</li></ul><h2>JS 函数对象</h2><pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F</span>(<span class="hljs-params"></span>) </span>{}\n<span class="hljs-keyword">var</span> f = <span class="hljs-keyword">new</span> F();\nF.prototype; <span class="hljs-comment">// {constructor: ƒ}</span>\nf.__proto__; <span class="hljs-comment">// {constructor: ƒ}</span>\nF.prototype === f.__proto__; <span class="hljs-comment">// true</span>\nF.prototype.constructor === F; <span class="hljs-comment">// true</span>\n\nF.__proto__; <span class="hljs-comment">// ƒ () { [native code] }</span>\nF.prototype.__proto__; <span class="hljs-comment">// {constructor: ƒ, __defineGetter__: ƒ, __defineSetter__: ƒ, hasOwnProperty: ƒ, __lookupGetter__: ƒ, …}</span>\nF.__proto__ === <span class="hljs-built_in">Function</span>.prototype; <span class="hljs-comment">// true</span>\nF.prototype.__proto__ === <span class="hljs-built_in">Object</span>.prototype; <span class="hljs-comment">// true</span>\n<span class="hljs-built_in">Object</span>.prototype.__proto__; <span class="hljs-comment">// null</span>\n</code></pre><p>首先，F 作为一个函数的同时它也是对象，所以它拥有属性<strong>proto</strong>指向了 Function.prototype，因为所有的函数都可以理解为 Function 的实例；</p><p>同样的，F.prototype 作为一个对象，它的<strong>proto</strong>指向 Object.prototype，因为它是对象且没有指明的构造函数，所以它直接是 Object 函数生成的实例，自然<strong>proto</strong>就指向 Object.prototype。</p><h2>继承实例</h2><pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fa</span>(<span class="hljs-params"></span>) </span>{\n\t<span class="hljs-built_in">this</span>.a = <span class="hljs-string">&#39;a&#39;</span>;\n}\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fb</span>(<span class="hljs-params"></span>) </span>{\n\t<span class="hljs-built_in">this</span>.b = <span class="hljs-string">&#39;b&#39;</span>;\n}\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fc</span>(<span class="hljs-params"></span>) </span>{\n\t<span class="hljs-built_in">this</span>.c = <span class="hljs-string">&#39;c&#39;</span>;\n}\nfb.prototype = <span class="hljs-keyword">new</span> fa();\nfc.prototype = <span class="hljs-keyword">new</span> fa();\n<span class="hljs-keyword">let</span> b = <span class="hljs-keyword">new</span> fb();\n<span class="hljs-keyword">let</span> c = <span class="hljs-keyword">new</span> fc();\n<span class="hljs-built_in">console</span>.log(b.a, c.a); <span class="hljs-comment">// a a</span>\nb.__proto__.a = <span class="hljs-string">&#39;ba&#39;</span>;\n<span class="hljs-built_in">console</span>.log(b.a, c.a); <span class="hljs-comment">// ba a</span>\nfc.prototype = fb.prototype;\n<span class="hljs-built_in">console</span>.log(b.a, c.a); <span class="hljs-comment">// ba a</span>\n<span class="hljs-built_in">console</span>.log(b.__proto__ === fb.prototype); <span class="hljs-comment">//true</span>\n<span class="hljs-built_in">console</span>.log(c.__proto__ === fc.prototype); <span class="hljs-comment">//false</span>\nc = <span class="hljs-keyword">new</span> fc();\nb.a = <span class="hljs-string">&#39;bba&#39;</span>;\n<span class="hljs-built_in">console</span>.log(b.a, c.a, b.__proto__, b.__proto__ === c.__proto__); <span class="hljs-comment">//bba ba fa { a: &#39;ba&#39; } true</span>\n</code></pre><h1>Object.create</h1><p>将提供的参数作为创建对象的原型并创建一个新的对象</p><p>参数：</p><ol><li>proto，原型对象，会被直接用作新对象的<strong>proto</strong>；</li><li>propertiesObject，属性对象，上面的属性会成为新对象的属性。</li></ol><p><strong>若 proto 为 null，那么新创建的 Object 将没有原型，<code>这也是唯一的创建无原型对象的方法</code></strong></p></body></html>',1),p=[e];function c(s,a){return Object(t["z"])(),Object(t["h"])("section",l,p)}var o=n("6b0d"),r=n.n(o);const i={},h=r()(i,[["render",c]]);a["default"]=h},"55d8":function(s,a,n){var t={"./README.md":"ebed","./css/CSS3动画.md":"bc01","./css/CSS样式初始化.md":"64e4","./css/CSS样式继承.md":"9f28","./css/CSS选择器.md":"7e15","./css/background.md":"da65","./css/css3文本效果.md":"9ac4","./css/css3盒模型.md":"9ad7","./css/css3背景渐变色.md":"92a2","./css/css3边框特效.md":"1a22","./css/css常用元素居中方法.md":"68ce","./css/css的link与import.md":"523d","./css/css的position.md":"f100","./git/cherry-pick.md":"9eef","./git/fetch.md":"04f5","./git/log.md":"ef90","./git/revert.md":"2040","./javascript/Generator.md":"7277","./javascript/Iterator.md":"7fb8","./javascript/JS事件队列.md":"2184","./javascript/JS数据、存取描述符.md":"a468","./javascript/JS数据类型.md":"a23a","./javascript/JS模块.md":"2800","./javascript/JS正则表达式.md":"edc9","./javascript/JS箭头函数.md":"689d","./javascript/JS缓存.md":"1b4d","./javascript/JS遍历.md":"3f28","./javascript/JS闭包.md":"0c37","./javascript/JS防抖和节流.md":"aeb8","./javascript/JS面向对象.md":"5593","./javascript/Promise.md":"8c77","./javascript/async与defer标签.md":"5490","./javascript/implementation/Promise.md":"2b1c","./javascript/implementation/array/数组扩展方法.md":"0529","./javascript/implementation/function/call，apply和bind.md":"6429","./javascript/implementation/function/new.md":"4607","./javascript/implementation/object/深拷贝deepCopy.md":"2c28","./javascript/implementation/readme.md":"c618","./javascript/react/create-react-app配置.md":"b905","./javascript/react/reactHook.md":"b14d","./javascript/react/react生命周期.md":"0ffa","./javascript/react/新建react-typescript-webpack项目.md":"9238","./javascript/try-catch-finally.md":"89be","./javascript/uni-app/cli创建项目.md":"3488","./javascript/uni-app/微信小程序.md":"9023","./javascript/vue/key的作用.md":"13bc","./javascript/vue/vuex/$store注入原理.md":"a3da","./javascript/vue/vuex/单向流动原理.md":"a350","./javascript/vue/vue生命周期.md":"f482","./javascript/vue/动态组件.md":"b3c3","./javascript/webpack/loader.md":"7fda","./javascript/webpack/plugin.md":"cc48","./javascript/webpack/工作流程.md":"f4fa","./javascript/with语句.md":"d8f1","./javascript/网络请求.md":"f277","./javascript/解构赋值.md":"ce23","./projects/NpmCli工具包.md":"faec","./projects/VSCode插件.md":"2a96","./projects/前端错误上报.md":"94f6","./projects/源码阅读/the-super-tiny-compiler.md":"3168","./projects/源码阅读/vue3.md":"6f4a","./python/Python装饰器.md":"b973","./python/Python迭代器.md":"0997","./python/Python闭包.md":"e0c0","./python/Python面向对象.md":"cd44","./typescript/ts类型断言.md":"32f5","./typescript/ts高级类型.md":"50e1","./typescript/unknown.md":"9e26"};function l(s){var a=e(s);return n(a)}function e(s){if(!n.o(t,s)){var a=new Error("Cannot find module '"+s+"'");throw a.code="MODULE_NOT_FOUND",a}return t[s]}l.keys=function(){return Object.keys(t)},l.resolve=e,s.exports=l,l.id="55d8"},5869:function(s,a,n){var t={"./Button/index.ts":"1882","./Icon/index.ts":"b148","./Layout/index.ts":"9745","./Loading/index.ts":"22f4","./Mask/index.ts":"f40e","./Popup/index.ts":"0a76","./Transition/index.ts":"d836","./Tree/index.ts":"9e53","./Wrapper/index.ts":"0273"};function l(s){var a=e(s);return n(a)}function e(s){if(!n.o(t,s)){var a=new Error("Cannot find module '"+s+"'");throw a.code="MODULE_NOT_FOUND",a}return t[s]}l.keys=function(){return Object.keys(t)},l.resolve=e,s.exports=l,l.id="5869"},"5c98":function(s,a,n){"use strict";n("03e3")},"5fd2":function(s,a,n){"use strict";n.d(a,"a",(function(){return t})),n.d(a,"b",(function(){return e})),n.d(a,"d",(function(){return p})),n.d(a,"c",(function(){return i}));n("d3b7"),n("159b"),n("b64b");var t={textColor:"#666",borderColor:"#ccc",borderColorDeep:"#999",primaryLighter:"#269ce7",primary:"#0181c9",primaryDeeper:"#006399",success:"#76ee65",info:"#8e8b8b",warning:"#eeb96e",error:"#ef5858"},l=!1,e=function(){var s=arguments.length>0&&void 0!==arguments[0]?arguments[0]:t,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:document.body,n=!0;if(l)return!0;var e=getComputedStyle(a);return Object.keys(s).forEach((function(s){e.getPropertyValue("--".concat(s))||(n=!1)})),n&&(l=!0),n},p=function(){var s=arguments.length>0&&void 0!==arguments[0]?arguments[0]:t,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:document.body,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];Object.keys(s).forEach((function(n){a.style.setProperty("--".concat(n),s[n],"important")})),n&&(l=!0)},c=(n("ac1f"),n("466d"),n("4de4"),n("1da1"),n("5530")),o=(n("96cf"),n("e9c4"),n("a15b"),n("d81d"),n("caad"),n("5319"),n("3410"),n("2909")),r=(n("99af"),n("6062"),n("3ca3"),n("ddb0"),{"Content-Type":"application/json; charset=UTF-8"}),i=(Object(c["a"])({},r),function(){var s=arguments.length>0&&void 0!==arguments[0]?arguments[0]:5e3,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1e5,n=s;return Object(o["a"])(document.querySelectorAll("body > *")).forEach((function(s){var t=+getComputedStyle(s).zIndex||0;t>n&&t<=a&&(n=t)})),n+1})},6402:function(s,a,n){"use strict";n("6936")},6429:function(s,a,n){"use strict";n.r(a);var t=n("7a23"),l={class:"markdown-body"},e=Object(t["j"])('<html><head></head><body><h1>函数方法 call、apply、bind</h1><h2>call</h2><ol><li>call 可以接收若干个参数。第一个为 thisArg，后续其他为函数本身的参数列表。</li><li>若没有指定 thisArg，默认为 window，若为基础类型则要用包装类包裹。</li></ol><p><strong>实现方案：利用 js 的函数在何处执行则 this 指向何处的特性，把目标函数放到对应的 thisArg 对象上执行，执行后删除</strong></p><pre><code class="language-js"><span class="hljs-built_in">Function</span>.prototype.myCall = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{\n\t<span class="hljs-keyword">var</span> _ctx = <span class="hljs-built_in">arguments</span>.length &gt; <span class="hljs-number">0</span> ? <span class="hljs-built_in">Object</span>(<span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>]) : <span class="hljs-built_in">window</span>, <span class="hljs-comment">// 如果是基础类型做this，必须用包装类</span>\n\t\t_args = [];\n\t<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">arguments</span>.length; i++) {\n\t\t<span class="hljs-comment">// eval 执行js字符串时要用的参数</span>\n\t\t_args.push(<span class="hljs-string">&#39;arguments[&#39;</span> + i + <span class="hljs-string">&#39;]&#39;</span>);\n\t}\n\t_ctx.__proto__._myCallFn = <span class="hljs-built_in">this</span>;\n\t<span class="hljs-keyword">var</span> _res = <span class="hljs-built_in">eval</span>(<span class="hljs-string">&#39;_ctx._myCallFn(&#39;</span> + _args + <span class="hljs-string">&#39;)&#39;</span>);\n\t<span class="hljs-keyword">delete</span> _ctx.__proto__._myCallFn;\n\t<span class="hljs-keyword">return</span> _res;\n};\n</code></pre><h2>apply</h2><p>apply 的实现大体与 call 相同，但是由于接受的不是参数列表而是一个数组作为参数，所以 apply 需要对参数做检查</p><ol><li>args 为空的话视为参数为空，但是不会报错</li><li>args 为非引用变量需要抛出异常</li><li>args 为引用型变量但是不是数组，视为参数为空</li></ol><pre><code class="language-js"><span class="hljs-built_in">Function</span>.prototype.myApply = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ctx, args</span>) </span>{\n\t<span class="hljs-keyword">var</span> _ctx = ctx ? <span class="hljs-built_in">Object</span>(ctx) : <span class="hljs-built_in">window</span>,\n\t\t_args = [];\n\t<span class="hljs-keyword">if</span> (args == <span class="hljs-literal">null</span>)\n\t\t<span class="hljs-comment">// 参数为空，不会报错</span>\n\t\targs = [];\n\t<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> args !== <span class="hljs-string">&#39;object&#39;</span> &amp;&amp; <span class="hljs-keyword">typeof</span> args !== <span class="hljs-string">&#39;function&#39;</span>)\n\t\t<span class="hljs-comment">// 基础类型需要抛出异常</span>\n\t\t<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&#39;CreateListFromArrayLike called on non-object&#39;</span>);\n\t<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ({}.toString.call(args) !== <span class="hljs-string">&#39;[object Array]&#39;</span>)\n\t\t<span class="hljs-comment">// 为对象或其他引用变量，不接受</span>\n\t\targs = [];\n\t<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; args.length; i++) {\n\t\t_args.push(<span class="hljs-string">&#39;args[&#39;</span> + i + <span class="hljs-string">&#39;]&#39;</span>);\n\t}\n\t_ctx.__proto__._myCallFn = <span class="hljs-built_in">this</span>;\n\t<span class="hljs-keyword">var</span> _res = <span class="hljs-built_in">eval</span>(<span class="hljs-string">&#39;_ctx._myCallFn(&#39;</span> + _args + <span class="hljs-string">&#39;)&#39;</span>);\n\t<span class="hljs-keyword">delete</span> _ctx.__proto__._myCallFn;\n\t<span class="hljs-keyword">return</span> _res;\n};\n</code></pre><h2>bind</h2><ol><li>ctx 为空，则设置为 window，否则对该值的包装对象</li><li>返回一个新的函数</li><li>新的函数内部已经用闭包记录了 bind 时预先填充的参数</li><li>新的函数可被正常的用作构造器，且原型继承自原函数</li></ol><pre><code class="language-js"><span class="hljs-built_in">Function</span>.prototype.myBind = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ctx</span>) </span>{\n\t<span class="hljs-keyword">var</span> _ctx = ctx != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">Object</span>(ctx) : <span class="hljs-built_in">window</span>,\n\t\t_fn = <span class="hljs-built_in">this</span>, <span class="hljs-comment">// 记录原函数</span>\n\t\t_argsPrev = [].slice.apply(<span class="hljs-built_in">arguments</span>, [<span class="hljs-number">1</span>]); <span class="hljs-comment">// 记录 bind 的参数</span>\n\t<span class="hljs-keyword">var</span> _newFn = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{\n\t\t<span class="hljs-keyword">var</span> _trueCtx =\n\t\t\t\t<span class="hljs-built_in">this</span> <span class="hljs-keyword">instanceof</span> _newFn <span class="hljs-comment">// 判断 this 是否是结果函数的实例</span>\n\t\t\t\t\t? <span class="hljs-built_in">this</span> <span class="hljs-comment">// 当前正在进行 new 操作，需要传递正确的 this 指向</span>\n\t\t\t\t\t: _ctx, <span class="hljs-comment">// 普通调用，直接使用 bind 的 this 指向</span>\n\t\t\t_args = _argsPrev.concat([].slice.apply(<span class="hljs-built_in">arguments</span>)); <span class="hljs-comment">// 拼接 bind 过程与调用过程的参数</span>\n\t\t<span class="hljs-keyword">return</span> _fn.apply(_trueCtx, _args);\n\t};\n\t<span class="hljs-comment">// 使用同样的原型</span>\n\t_newFn.prototype = <span class="hljs-built_in">Object</span>.create(_fn.prototype);\n\t<span class="hljs-keyword">return</span> _newFn;\n};\n</code></pre></body></html>',1),p=[e];function c(s,a){return Object(t["z"])(),Object(t["h"])("section",l,p)}var o=n("6b0d"),r=n.n(o);const i={},h=r()(i,[["render",c]]);a["default"]=h},"64e4":function(s,a,n){"use strict";n.r(a);var t=n("7a23"),l={class:"markdown-body"},e=Object(t["j"])('<html><head></head><body><h1>样式初始化</h1><p>目的：由于各浏览器中对详细标签的默认实现不一致，可能会导致样式显示 bug，因此通过样式初始化将浏览器标签的默认样式全部消除，样式由程序员自己设计，减小不同浏览器可能带来的 bug。</p><p>简易版：</p><pre><code class="language-css"><span class="hljs-selector-tag">body</span> {\n\t<span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;\n\t<span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;\n}\n</code></pre><p>豪华版：</p><pre><code class="language-css"><span class="hljs-selector-tag">body</span>,\n<span class="hljs-selector-tag">h1</span>,\n<span class="hljs-selector-tag">h2</span>,\n<span class="hljs-selector-tag">h3</span>,\n<span class="hljs-selector-tag">h4</span>,\n<span class="hljs-selector-tag">h5</span>,\n<span class="hljs-selector-tag">h6</span>,\nhr,\n<span class="hljs-selector-tag">p</span>,\n<span class="hljs-selector-tag">blockquote</span>,\n<span class="hljs-selector-tag">dl</span>,\n<span class="hljs-selector-tag">dt</span>,\n<span class="hljs-selector-tag">dd</span>,\n<span class="hljs-selector-tag">ul</span>,\n<span class="hljs-selector-tag">ol</span>,\n<span class="hljs-selector-tag">li</span>,\npre,\n<span class="hljs-selector-tag">form</span>,\n<span class="hljs-selector-tag">fieldset</span>,\n<span class="hljs-selector-tag">legend</span>,\n<span class="hljs-selector-tag">button</span>,\n<span class="hljs-selector-tag">input</span>,\n<span class="hljs-selector-tag">textarea</span>,\n<span class="hljs-selector-tag">th</span>,\n<span class="hljs-selector-tag">td</span> {\n\t<span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;\n\t<span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;\n}\n<span class="hljs-selector-tag">body</span>,\n<span class="hljs-selector-tag">button</span>,\n<span class="hljs-selector-tag">input</span>,\nselect,\n<span class="hljs-selector-tag">textarea</span> {\n\t<span class="hljs-attribute">font</span>: <span class="hljs-number">12px</span>/<span class="hljs-number">1.5</span>tahoma, arial, \\<span class="hljs-number">5</span>b8b\\<span class="hljs-number">4</span>f53;\n}\n<span class="hljs-selector-tag">h1</span>,\n<span class="hljs-selector-tag">h2</span>,\n<span class="hljs-selector-tag">h3</span>,\n<span class="hljs-selector-tag">h4</span>,\n<span class="hljs-selector-tag">h5</span>,\n<span class="hljs-selector-tag">h6</span> {\n\t<span class="hljs-attribute">font-size</span>: <span class="hljs-number">100%</span>;\n}\n<span class="hljs-selector-tag">address</span>,\n<span class="hljs-selector-tag">cite</span>,\n<span class="hljs-selector-tag">dfn</span>,\n<span class="hljs-selector-tag">em</span>,\n<span class="hljs-selector-tag">var</span> {\n\t<span class="hljs-attribute">font-style</span>: normal;\n}\n<span class="hljs-selector-tag">code</span>,\n<span class="hljs-selector-tag">kbd</span>,\npre,\n<span class="hljs-selector-tag">samp</span> {\n\t<span class="hljs-attribute">font-family</span>: couriernew, courier, monospace;\n}\nsmall {\n\t<span class="hljs-attribute">font-size</span>: <span class="hljs-number">12px</span>;\n}\n<span class="hljs-selector-tag">ul</span>,\n<span class="hljs-selector-tag">ol</span> {\n\t<span class="hljs-attribute">list-style</span>: none;\n}\n<span class="hljs-selector-tag">a</span> {\n\t<span class="hljs-attribute">text-decoration</span>: none;\n}\n<span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> {\n\t<span class="hljs-attribute">text-decoration</span>: underline;\n}\n<span class="hljs-selector-tag">sup</span> {\n\t<span class="hljs-attribute">vertical-align</span>: text-top;\n}\nsub {\n\t<span class="hljs-attribute">vertical-align</span>: text-bottom;\n}\n<span class="hljs-selector-tag">legend</span> {\n\t<span class="hljs-attribute">color</span>: <span class="hljs-number">#000</span>;\n}\n<span class="hljs-selector-tag">fieldset</span>,\n<span class="hljs-selector-tag">img</span> {\n\t<span class="hljs-attribute">border</span>: <span class="hljs-number">0</span>;\n}\n<span class="hljs-selector-tag">button</span>,\n<span class="hljs-selector-tag">input</span>,\nselect,\n<span class="hljs-selector-tag">textarea</span> {\n\t<span class="hljs-attribute">font-size</span>: <span class="hljs-number">100%</span>;\n}\n<span class="hljs-selector-tag">table</span> {\n\t<span class="hljs-attribute">border-collapse</span>: collapse;\n\t<span class="hljs-attribute">border-spacing</span>: <span class="hljs-number">0</span>;\n}\n</code></pre></body></html>',1),p=[e];function c(s,a){return Object(t["z"])(),Object(t["h"])("section",l,p)}var o=n("6b0d"),r=n.n(o);const i={},h=r()(i,[["render",c]]);a["default"]=h},"689d":function(s,a,n){"use strict";n.r(a);var t=n("7a23"),l={class:"markdown-body"},e=Object(t["j"])('<html><head></head><body><h1>JS 箭头函数与 this</h1><h2>JS 中的 this</h2><p>this 是一个特殊的对象，由函数调用时传入</p><pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>) </span>{\n\t<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);\n}\n\n<span class="hljs-keyword">let</span> obj = {\n\t<span class="hljs-attr">id</span>: <span class="hljs-number">1</span>,\n};\n\na(); <span class="hljs-comment">//输出window对象，是默认传入的</span>\na.call(obj); <span class="hljs-comment">//输出obj对象</span>\n</code></pre><pre><code class="language-js"><span class="hljs-keyword">let</span> obj = {\n\t<span class="hljs-attr">id</span>: <span class="hljs-number">1</span>,\n\t<span class="hljs-function"><span class="hljs-title">a</span>(<span class="hljs-params"></span>)</span> {\n\t\t<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);\n\t},\n};\n\nobj.a(); <span class="hljs-comment">//输出obj</span>\na.call(obj); <span class="hljs-comment">//输出obj</span>\n</code></pre><p>当函数为对象的某个变量时，函数调用将默认传入直接包含该函数的对象。</p><h2>箭头函数</h2><p>箭头函数的 this 将会固定为上层作用域的 this，无法修改。</p><pre><code class="language-js"><span class="hljs-keyword">let</span> obj = {\n\t<span class="hljs-function"><span class="hljs-title">f</span>(<span class="hljs-params"></span>)</span> {\n\t\t<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);\n\t\t<span class="hljs-keyword">let</span> a = <span class="hljs-function">() =&gt;</span> {\n\t\t\t<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);\n\t\t};\n\t\ta();\n\t},\n};\n\nobj.f();\n<span class="hljs-comment">/*输出\n{ f: [Function: f] }\n{ f: [Function: f] }\n*/</span>\n</code></pre><pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{\n\t<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#39;1&#39;</span>, <span class="hljs-built_in">this</span>.id);\n\t<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{\n\t\t<span class="hljs-comment">// 用的是这一层的this，如果是多层箭头函数，就是最外层的this</span>\n\t\t<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#39;2&#39;</span>, <span class="hljs-built_in">this</span>.id);\n\t\t{\n\t\t\t<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#39;3&#39;</span>, <span class="hljs-built_in">this</span>.id);\n\t\t\t<span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {\n\t\t\t\t<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#39;4&#39;</span>, <span class="hljs-built_in">this</span>.id);\n\t\t\t};\n\t\t}\n\t};\n}\nfoo.call({ <span class="hljs-attr">id</span>: <span class="hljs-number">2</span> }).call({ <span class="hljs-attr">id</span>: <span class="hljs-number">1</span> })();\n<span class="hljs-comment">/*输出\n1 2\n2 1\n3 1\n4 1\n*/</span>\n</code></pre><p>通过<code>call</code>调用<code>foo</code>，因此<code>this</code>指向 2 的对象，<code>foo</code>返回的函数被<code>call</code>调用并传入 1 的对象，代码块的块级作用域只影响<code>let</code>和<code>const</code>，对<code>this</code>无影响，所以箭头函数的<code>this</code>为 1 的对象。</p></body></html>',1),p=[e];function c(s,a){return Object(t["z"])(),Object(t["h"])("section",l,p)}var o=n("6b0d"),r=n.n(o);const i={},h=r()(i,[["render",c]]);a["default"]=h},"68ce":function(s,a,n){"use strict";n.r(a);var t=n("7a23"),l={class:"markdown-body"},e=Object(t["j"])('<html><head></head><body><h1>CSS 元素居中方法</h1><h2>display:flex;</h2><pre><code class="language-css"><span class="hljs-selector-class">.parent</span> {\n\t<span class="hljs-attribute">display</span>: flex;\n\t<span class="hljs-attribute">justify-content</span>: center;\n\t<span class="hljs-attribute">align-items</span>: center;\n}\n</code></pre><h2>transform + position</h2><pre><code class="language-css"><span class="hljs-selector-class">.parent</span> {\n\t<span class="hljs-attribute">position</span>: relative;\n}\n<span class="hljs-selector-class">.child</span> {\n\t<span class="hljs-attribute">position</span>: absolute;\n\t<span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;\n\t<span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;\n\t<span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(-<span class="hljs-number">50%</span>, -<span class="hljs-number">50%</span>);\n}\n</code></pre><p>具体原理为先用 left 和 top 将子元素的左上顶点置于父元素中心，transform: translate 参数如果为百分比形式，将根据元素本身的宽和高作为基准将元素进行移动本身宽和高的 50%，得以居中。</p><h2>内联元素（文字）水平居中</h2><pre><code class="language-css"><span class="hljs-selector-class">.parent</span> {\n\t<span class="hljs-attribute">text-align</span>: center;\n}\n</code></pre><h2>内联元素（文字）垂直居中</h2><pre><code class="language-css"><span class="hljs-selector-class">.parent</span> {\n\t<span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;\n\t<span class="hljs-attribute">line-height</span>: <span class="hljs-number">100px</span>;\n}\n</code></pre></body></html>',1),p=[e];function c(s,a){return Object(t["z"])(),Object(t["h"])("section",l,p)}var o=n("6b0d"),r=n.n(o);const i={},h=r()(i,[["render",c]]);a["default"]=h},6936:function(s,a,n){},"696a":function(s,a,n){"use strict";n("9073")},"6b7d":function(s,a,n){"use strict";n("326e")},"6c37":function(s,a,n){},"6f4a":function(s,a,n){"use strict";n.r(a);var t=n("7a23"),l={class:"markdown-body"},e=Object(t["j"])('<html><head></head><body><h1>Vue3 源码阅读。</h1><p>专门 Fork 一份仓库用于打注释。</p><p>Vue3 源码阅读 3 步：</p><ol><li>reactivity。响应式代理核心，同时代码量少，只需关注核心逻辑及原理即可。<strong>Done</strong></li><li>compile，模板编译 compiler-sfc，compiler-core，针对单文件组件模板的编译包，编译过程的影响因素很多，感觉还是需要结合 runtime 一起看才行。<strong>Done</strong></li><li>runtime，运行时主体。<strong>Ing</strong></li></ol><p><a href="https://github.com/czzczz/vue-next">仓库地址</a></p></body></html>',1),p=[e];function c(s,a){return Object(t["z"])(),Object(t["h"])("section",l,p)}var o=n("6b0d"),r=n.n(o);const i={},h=r()(i,[["render",c]]);a["default"]=h},7277:function(s,a,n){"use strict";n.r(a);var t=n("7a23"),l={class:"markdown-body"},e=Object(t["j"])('<html><head></head><body><h1>Generator 生成器</h1><h2>generator function(function* 语法)</h2><p>定义一个生成器函数。 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/function*">function*</a></p><ul><li>生成器函数内直接 return 的话会直接把生成器状态置为 done</li><li>生成器函数不可作为构造器，会报 TypeError</li></ul><pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">generator</span>(<span class="hljs-params">i</span>) </span>{\n\t<span class="hljs-keyword">yield</span> i;\n\t<span class="hljs-keyword">yield</span> i + <span class="hljs-number">10</span>;\n}\n\n<span class="hljs-keyword">const</span> gen = generator(<span class="hljs-number">10</span>);\n\n<span class="hljs-built_in">console</span>.log(gen.next().value);\n<span class="hljs-comment">// expected output: 10</span>\n\n<span class="hljs-built_in">console</span>.log(gen.next().value);\n<span class="hljs-comment">// expected output: 20</span>\n</code></pre><h2>Generator 对象</h2><p>生成器对象，同时也是符合迭代器规范的对象</p><ul><li>next 方法与标准的迭代器 next 不同，可以接收一个参数作为<code>上一次yeild语句的值</code>。即该参数会被赋给上一次 yeild 语句的左值（若有的话）</li></ul><pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">gen</span>(<span class="hljs-params"></span>) </span>{\n\t<span class="hljs-keyword">yield</span> <span class="hljs-number">10</span>;\n\tx = <span class="hljs-keyword">yield</span> <span class="hljs-string">&#39;foo&#39;</span>;\n\t<span class="hljs-keyword">yield</span> x;\n}\n\n<span class="hljs-keyword">var</span> gen_obj = gen();\n<span class="hljs-built_in">console</span>.log(gen_obj.next()); <span class="hljs-comment">// 执行 yield 10，返回 10</span>\n<span class="hljs-built_in">console</span>.log(gen_obj.next()); <span class="hljs-comment">// 执行 yield &#39;foo&#39;，返回 &#39;foo&#39;</span>\n<span class="hljs-built_in">console</span>.log(gen_obj.next(<span class="hljs-number">100</span>)); <span class="hljs-comment">// 将 100 赋给上一条 yield &#39;foo&#39; 的左值，即执行 x=100，返回 100</span>\n<span class="hljs-built_in">console</span>.log(gen_obj.next()); <span class="hljs-comment">// 执行完毕，value 为 undefined，done 为 true</span>\n</code></pre><h2>yeild* 语句</h2><p>yeild*语句代表<code>当前迭代目标会暂停</code>，将迭代过程<code>移交</code>给后面跟随的表达式</p><ul><li>后面跟随的表达式必须可迭代</li></ul><pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">anotherGenerator</span>(<span class="hljs-params">i</span>) </span>{\n\t<span class="hljs-keyword">yield</span> i + <span class="hljs-number">1</span>;\n\t<span class="hljs-keyword">yield</span> i + <span class="hljs-number">2</span>;\n\t<span class="hljs-keyword">yield</span> i + <span class="hljs-number">3</span>;\n}\n\n<span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">generator</span>(<span class="hljs-params">i</span>) </span>{\n\t<span class="hljs-keyword">yield</span> i;\n\t<span class="hljs-keyword">yield</span>* anotherGenerator(i); <span class="hljs-comment">// 移交执行权</span>\n\t<span class="hljs-keyword">yield</span> i + <span class="hljs-number">10</span>;\n}\n\n<span class="hljs-keyword">var</span> gen = generator(<span class="hljs-number">10</span>);\n<span class="hljs-built_in">console</span>.log(gen.next().value); <span class="hljs-comment">// 10</span>\n<span class="hljs-built_in">console</span>.log(gen.next().value); <span class="hljs-comment">// 11</span>\n<span class="hljs-built_in">console</span>.log(gen.next().value); <span class="hljs-comment">// 12</span>\n<span class="hljs-built_in">console</span>.log(gen.next().value); <span class="hljs-comment">// 13</span>\n<span class="hljs-built_in">console</span>.log(gen.next().value); <span class="hljs-comment">// 20</span>\n</code></pre><p>通过 yeild*来对多维数组进行平铺</p><pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">iterArr</span>(<span class="hljs-params">arr</span>) </span>{\n\t<span class="hljs-comment">// 依然是数组，递归</span>\n\t<span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(arr)) {\n\t\t<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) {\n\t\t\t<span class="hljs-keyword">yield</span>* iterArr(arr[i]); <span class="hljs-comment">// (*)递归</span>\n\t\t}\n\t} <span class="hljs-keyword">else</span> {\n\t\t<span class="hljs-comment">// 直接返回</span>\n\t\t<span class="hljs-keyword">yield</span> arr;\n\t}\n}\n<span class="hljs-keyword">var</span> arr = [<span class="hljs-string">&#39;a&#39;</span>, [<span class="hljs-string">&#39;b&#39;</span>, <span class="hljs-string">&#39;c&#39;</span>], [[<span class="hljs-string">&#39;d&#39;</span>, <span class="hljs-string">&#39;d2&#39;</span>], <span class="hljs-string">&#39;e&#39;</span>]];\n<span class="hljs-keyword">var</span> gen = iterArr(arr);\narr = [...gen];\n<span class="hljs-built_in">console</span>.log(arr); <span class="hljs-comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;d2&quot;, &quot;e&quot;]</span>\n</code></pre></body></html>',1),p=[e];function c(s,a){return Object(t["z"])(),Object(t["h"])("section",l,p)}var o=n("6b0d"),r=n.n(o);const i={},h=r()(i,[["render",c]]);a["default"]=h},7289:function(s,a,n){"use strict";n("f0b8")},"72bc":function(s,a,n){s.exports=n.p+"img/卡券缺口特效.6f5f6896.png"},7439:function(s,a,n){},7779:function(s,a){s.exports="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAqMAAADNCAYAAACM/nlrAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAAEnQAABJ0Ad5mH3gAAARoSURBVHhe7dgxSuVgFIDRl+lECxGEkCa4n1meO9EluA1HbLQYGKZx2owJwR34PvGd0/w3t0r5cYdxmpfDu8ur6/UB3v398/twdn6xfwEAn+XH/gIAwNF9XEZfX563Bd/fv193+wQA0HIZBQAgI0YBAMiIUQAAMmIUAICMGAUAICNGAQDIiFEAADJiFACAjBgFACAjRgEAyIhRAAAyYhQAgIwYBQAgI0YBAMiIUQAAMmIUAICMGAUAICNGAQDIiFEAADJiFACAjBgFACAjRgEAyIhRAAAyYhQAgIwYBQAgI0YBAMiIUQAAMmIUAICMGAUAICNGAQDIiFEAADJiFACAjBgFACAjRgEAyIhRAAAyYhQAgIwYBQAgM4zTvKzD68vztvgqhmX7LU7I29P9PgEAp8JlFACAjBgFACAjRgEAyIhRAAAyYhQAgIwYBQAgI0YBAMiIUQAAMmIUAICMGAUAICNGAQDIiFEAADJiFACAjBgFACAjRgEAyIhRAAAyYhQAgIwYBQAgI0YBAMiIUQAAMmIUAICMGAUAICNGAQDIiFEAADLDOM3LOjw+3G6Lr+L85uc+cSrenu73CQA4FS6jAABkxCgAABkxCgBARowCAJARowAAZMQoAAAZMQoAQEaMAgCQEaMAAGTEKAAAGTEKAEBGjAIAkBGjAABkxCgAABkxCgBARowCAJARowAAZMQoAAAZMQoAQEaMAgCQEaMAAGTEKAAAGTEKAEBGjAIAkBGjAABkxCgAABkxCgBARowCAJARowAAZMQoAAAZMQoAQEaMAgCQEaMAAGTEKAAAGTEKAEBGjAIAkBGjAABkxCgAABkxCgBARowCAJARowAAZMQoAAAZMQoAQEaMAgCQEaMAAGTEKAAAGTEKAEBGjAIAkBGjAABkxCgAABkxCgBARowCAJARowAAZMQoAAAZMQoAQEaMAgCQEaMAAGTEKAAAGTEKAEBGjAIAkBGjAABkxCgAABkxCgBARowCAJARowAAZMQoAAAZMQoAQEaMAgCQEaMAAGTEKAAAGTEKAEBGjAIAkBGjAABkxCgAABkxCgBARowCAJARowAAZMQoAAAZMQoAQEaMAgCQEaMAAGTEKAAAGTEKAEBGjAIAkBGjAABkxCgAABkxCgBARowCAJARowAAZMQoAAAZMQoAQEaMAgCQEaMAAGTEKAAAGTEKAEBGjAIAkBGjAABkxCgAABkxCgBAZhineVmHx4fbbQEAAMfiMgoAQEaMAgCQEaMAAGTEKAAAGTEKAEBGjAIAkBGjAABkxCgAABkxCgBARowCAJARowAAZMQoAAAZMQoAQEaMAgCQEaMAAGTEKAAAGTEKAEBGjAIAkBGjAABkxCgAABkxCgBARowCAJARowAAZMQoAAAZMQoAQEaMAgCQEaMAAGTEKAAAGTEKAEBGjAIAkBGjAABkxCgAABkxCgBARowCAJARowAAZMQoAACZYZzmZR0ur663BQAAHIvLKAAAGTEKAEDkcPgPUFsgoMMtLO4AAAAASUVORK5CYII="},"7e15":function(s,a,n){"use strict";n.r(a);var t=n("7a23"),l={class:"markdown-body"},e=Object(t["j"])("<html><head></head><body><h1>CSS 选择器</h1><h2>选择器类型</h2><ol><li>id 选择器(# myid) 根据 id 来选择</li><li>类选择器(.myclassname) 根据类名选择</li><li>标签选择器(div, h1, p) 根据标签名选择</li><li>相邻选择器(h1 + p) 选择每个跟在 h1 后面的 p</li><li>子选择器(ul &gt; li) 选择 ul 的直接子元素（第一层）</li><li>后代选择器(li a) 选择 li 内部的所有 a（不论是否是第一层）</li><li>通配符选择器( * ) 匹配所用选择器</li><li>属性选择器(a[rel = &quot;external&quot;]) 根据属性来选择（CSS3 新增）</li><li>伪类选择器(a: hover, li:nth-child) 根据一定的条件来选择</li></ol><h2>CSS3 新增选择器</h2><ol><li>element1~element2: 选择前面有 element1 元素的每个 element2 元素。</li></ol><h3>属性选择器</h3><ol><li><code>[attribute^=value]</code>: 选择某元素 attribute 属性是以 value 开头的。</li><li><code>[attribute$=value]</code>: 选择某元素 attribute 属性是以 value 结尾的。</li><li><code>[attribute*=value]</code>: 选择某元素 attribute 属性包含 value 字符串的。</li></ol><h3>伪类</h3><ol><li><code>E:first-of-type</code>: 选择属于其父元素的首个 E 元素的每个 E 元素。</li><li><code>E:last-of-type</code>: 选择属于其父元素的最后 E 元素的每个 E 元素。</li><li><code>E:only-of-type</code>: 选择属于其父元素唯一的 E 元素的每个 E 元素。</li><li><code>E:only-child</code>: 选择属于其父元素的唯一子元素的每个 E 元素。</li><li><code>E:nth-child(n)</code>: 选择属于其父元素的第 n 个子元素的每个 E 元素。</li><li><code>E:nth-last-child(n)</code>: 选择属于其父元素的倒数第 n 个子元素的每个 E 元素。</li><li><code>E:nth-of-type(n)</code>: 选择属于其父元素第 n 个 E 元素的每个 E 元素。</li><li><code>E:nth-last-of-type(n)</code>: 选择属于其父元素倒数第 n 个 E 元素的每个 E 元素。</li><li><code>E:last-child</code>: 选择属于其父元素最后一个子元素每个 E 元素。</li><li><code>:root</code>: 选择文档的根元素。</li><li><code>E:empty</code>: 选择没有子元素的每个 E 元素（包括文本节点)。</li><li><code>E:target</code>: 选择当前活动的 E 元素。</li><li><code>E:enabled</code>: 选择每个启用的 E 元素。</li><li><code>E:disabled</code>: 选择每个禁用的 E 元素。</li><li><code>E:checked</code>: 选择每个被选中的 E 元素。</li><li><code>E:not(selector)</code>: 选择非 selector 元素的每个元素。</li><li><code>E::selection</code>: 选择被用户选取的元素部分。</li></ol><h2>选择器优先级</h2><ol><li>优先级就近原则，同权重情况下样式定义最近者为准;</li><li>载入样式以最后载入的定位为准;</li><li>!important &gt; id &gt; class &gt; tag</li><li>important 比 内联优先级高，但内联比 id 要高</li></ol></body></html>",1),p=[e];function c(s,a){return Object(t["z"])(),Object(t["h"])("section",l,p)}var o=n("6b0d"),r=n.n(o);const i={},h=r()(i,[["render",c]]);a["default"]=h},"7fb8":function(s,a,n){"use strict";n.r(a);var t=n("7a23"),l={class:"markdown-body"},e=Object(t["j"])('<html><head></head><body><h1>Iterator 迭代器</h1><p>迭代器用于自定义一个可被 <code>for...of</code> 遍历的的对象。其需要遵守两个协议 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols#iterable">可迭代协议(iterable)</a> 与 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols#iterator">迭代器协议</a></p><h2>可迭代协议</h2><p>一个对象要符合可迭代协议，需要本身实现<code>@@iterator</code>方法，可通过<code>[Symbol.iterator]</code>访问。该方法<strong>没有参数</strong>，同时返回一个满足<code>迭代器协议</code>的对象</p><p>当 JS 通过<code>for...of</code>遍历一个对象时，不带参数调用对应的<code>@@iterator</code>方法，并获取对应的迭代器对象来处理数据。</p><ul><li><code>@@iterator</code>方法可以是普通方法也可以是生成器(Generator)方法</li><li>函数内部的 this 指向对象本身，依旧遵守谁调用 this 就是谁的策略</li></ul><h2>异步可迭代协议</h2><p>对应属性<code>[Symbol.asyncIterator]</code>，支持 async 函数，其特性与可迭代协议基本一致，不过须配合<code>for await...of</code>使用</p><h2>迭代器协议</h2><p>迭代器定义了遍历过程中一个<code>任意对象</code>生成一组系列值用于引擎读取的标准规范。若系列值为有限个数，那么迭代完成后会返回一个默认值(<code>{ done: true, value: undefined }</code>)。</p><p>实现迭代器需要对象本身拥有<code>next</code>方法</p><ol><li>next 为无参函数</li><li>next 须返回一个带有<code>done</code>和<code>value</code>字段的对象（done 为 true 时 value 可以省略），否则遍历会抛出 TypeError 异常</li><li>若对象迭代已经完成为 true，否则为 false</li><li>遍历方法取到的值，可为任意 JS 值</li></ol></body></html>',1),p=[e];function c(s,a){return Object(t["z"])(),Object(t["h"])("section",l,p)}var o=n("6b0d"),r=n.n(o);const i={},h=r()(i,[["render",c]]);a["default"]=h},"7fda":function(s,a,n){"use strict";n.r(a);var t=n("7a23"),l={class:"markdown-body"},e=Object(t["i"])("html",null,[Object(t["i"])("head"),Object(t["i"])("body",null,[Object(t["i"])("h1",null,"Webpack Loader"),Object(t["i"])("p",null,"Webpack 将不同类型的文件加载为可识别模块的中间件"),Object(t["i"])("p",null,[Object(t["i"])("a",{href:"https://github.com/czzczz/md-loader-for-doc"},"markdown-loader-for-doc")])])],-1),p=[e];function c(s,a){return Object(t["z"])(),Object(t["h"])("section",l,p)}var o=n("6b0d"),r=n.n(o);const i={},h=r()(i,[["render",c]]);a["default"]=h},"83c8":function(s,a,n){},8617:function(s,a,n){s.exports=n.p+"img/事件循环顺序.54b4b28c.png"},"89be":function(s,a,n){"use strict";n.r(a);var t=n("7a23"),l={class:"markdown-body"},e=Object(t["j"])('<html><head></head><body><h1>JS 中的 Try-Catch-Finally</h1><h2>基本使用</h2><p>try...catch 语句标记要尝试的语句块，并指定一个出现异常时抛出的响应。</p><p>若 try 中的代码抛出异常，则 catch 中的代码将会执行</p><pre><code class="language-js"><span class="hljs-keyword">try</span> {\n\t<span class="hljs-comment">// doSth</span>\n} <span class="hljs-keyword">catch</span> (e) {\n\t<span class="hljs-built_in">console</span>.log(e);\n\t<span class="hljs-comment">// 万一这里又异常，那么需要嵌套try</span>\n}\n</code></pre><h2>finally</h2><p>与 Promise 的 <code>finally</code> 类似。不论 try 中的代码是否执行成功，finally 中的代码均会在 try 执行完成后执行。</p><p>** 若同时有 catch 代码要执行，那么 finally 最后执行 **</p><pre><code class="language-js"><span class="hljs-keyword">try</span> {\n\t<span class="hljs-comment">// doSth</span>\n} <span class="hljs-keyword">catch</span> (e) {\n\t<span class="hljs-built_in">console</span>.log(e);\n} <span class="hljs-keyword">finally</span> {\n\t<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#39;finally&#39;</span>);\n}\n</code></pre><h2>try 代码块嵌套</h2><p><strong>任何给定的异常只会被离它最近的封闭 catch 块捕获一次。</strong></p><pre><code class="language-js"><span class="hljs-keyword">try</span> {\n\t<span class="hljs-keyword">try</span> {\n\t\t<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#39;oops&#39;</span>);\n\t} <span class="hljs-keyword">finally</span> {\n\t\t<span class="hljs-comment">// 如果这里catch了，外部catch不到，如果这里catch了但catch内部又异常，外部可catch到</span>\n\t\t<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#39;finally&#39;</span>);\n\t}\n} <span class="hljs-keyword">catch</span> (ex) {\n\t<span class="hljs-built_in">console</span>.error(<span class="hljs-string">&#39;outer&#39;</span>, ex.message);\n}\n<span class="hljs-comment">// Output:</span>\n<span class="hljs-comment">// &quot;finally&quot;</span>\n<span class="hljs-comment">// &quot;outer&quot; &quot;oops&quot;</span>\n</code></pre><h2>try-catch-finally 中 的 return</h2><p>如果是函数中的 try 代码块中有 return，那么遵循以下的优先度返回</p><ol><li>若 finally 中有 return，等<code>try-catch-finally</code>中所有代码执行完成后函数返回</li><li>若 catch 中有 return，等<code>try-catch-finally</code>中所有代码执行完成后函数返回</li><li>若 try 中有 return，等<code>try-catch-finally</code>中所有代码执行完成后函数返回</li></ol><pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>) </span>{\n\t<span class="hljs-keyword">try</span> {\n\t\t<span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);\n\t\t<span class="hljs-keyword">return</span> b();\n\t} <span class="hljs-keyword">catch</span> {\n\t\t<span class="hljs-built_in">console</span>.log(<span class="hljs-number">5</span>);\n\t\t<span class="hljs-keyword">return</span> <span class="hljs-number">6</span>;\n\t} <span class="hljs-keyword">finally</span> {\n\t\t<span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>);\n\t}\n}\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">b</span>(<span class="hljs-params"></span>) </span>{\n\t<span class="hljs-built_in">console</span>.log(<span class="hljs-number">4</span>);\n\t<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-number">2</span>);\n}\n<span class="hljs-comment">// 1,4,5,3</span>\n<span class="hljs-comment">// 函数返回： 6</span>\n</code></pre></body></html>',1),p=[e];function c(s,a){return Object(t["z"])(),Object(t["h"])("section",l,p)}var o=n("6b0d"),r=n.n(o);const i={},h=r()(i,[["render",c]]);a["default"]=h},"8c77":function(s,a,n){"use strict";n.r(a);var t=n("7a23"),l={class:"markdown-body"},e=Object(t["j"])('<html><head></head><body><h1>JS 中的 Promise，async await</h1><h2>Promise 特性分析</h2><ol><li>Promise 构造函数接收一个函数（executor），该函数接收两个参数 resolve 和 reject 并且在构造器中同步执行</li><li>executor 不应该返回一个 Promise</li><li>executor 中执行的代码如果抛出异常，该异常会被 Promise catch 并转为拒绝态</li><li>Promise 可以通过 then 传入回调函数，该回调函数会在 Promise 状态转换时执行，参数为 Promise resolve 或 reject 的值</li><li>Promise then 注册的回调函数通过微任务异步执行</li><li>Promise 只能进行一次状态转换，从 Pending 转到 Fullfilled 或 Rejected</li><li>Promise then 返回一个新的 Promise，有如下规则 <ul><li>then 的回调返回一个<code>非PromiseLike的值</code> ，则新 Promise 状态为 fullfilled，值为该返回值</li><li>函数没有返回值遵守上一条规则</li><li><code>PromiseLike</code> 指对象或函数有一个 then 成员且 then 成员的规则与 Promise then 一致，<code>并不一定要 instanceof Promise</code></li><li>then 的回调返回一个 fullfilled 的 Promise，则新 Promise 为 fullfilled，value 为返回的 Promise 的 value</li><li>then 的回调返回一个 rejected 的 Promise，则新 Promise 为 rejected，value 为 reject 的 reason</li><li><code>then 的回调返回一个 pending 的 Promise，则新 Promise 为 pending，.then 的链式执行就此中断</code></li><li>then 的回调执行过程出错，则新 Promise 状态为 rejected，value 为 catch 的 error 信息</li></ul></li><li>Promise catch 是 then 的语法糖，完全等价于 then 只传第二个参数</li></ol><p><a href="/#/notes/javascript/implementation/Promise.md">MyPromise 代码实现</a></p><h2>async await 特性分析</h2><ol><li>async 用于修饰函数，使得函数以同步的语法执行 <code>PromiseLike</code> 异步代码</li><li>async 函数返回 Promise，该 Promise 的 value 为 async 函数 return 的值</li><li>若 async 函数 return 语句就是返回的 <code>PromiseLike</code>，则通过 Promise then 的特性取最终值</li><li>await 修饰 js 语句，若该语句值为 <code>PromiseLike</code>，则中止 async 函数执行直到 js 语句的 Promise then 时机触发，若该值一直 pending 那么 async 函数将不会再执行</li></ol></body></html>',1),p=[e];function c(s,a){return Object(t["z"])(),Object(t["h"])("section",l,p)}var o=n("6b0d"),r=n.n(o);const i={},h=r()(i,[["render",c]]);a["default"]=h},9023:function(s,a,n){"use strict";n.r(a);n("b0c0");var t=n("7a23"),l={class:"markdown-body"},e=Object(t["i"])("head",null,null,-1),p=Object(t["j"])('<h1>uni-app 编译到微信小程序</h1><h2>作用域插槽</h2><h3>template 内不要用 for 生成多个根节点</h3><p>该用法会导致<code>slot=body</code>被编译到每个列表元素上，导致组件无法识别插槽元素</p><p>正常情况下多个根节点的编译结果</p><pre><code class="language-vue"><span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">body</span>&gt;</span>\n\t<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n\t<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>\n</code></pre><pre><code><view slot="body">\n\t<view class="_div">1</view>\n\t<view class="_div">2</view>\n</view>\n</code></pre><p>使用 for 生成多个根节点时的编译结果</p>',8),c={class:"language-vue"},o=Object(t["i"])("span",{class:"hljs-tag"},[Object(t["k"])("<"),Object(t["i"])("span",{class:"hljs-name"},"template"),Object(t["k"])(" #"),Object(t["i"])("span",{class:"hljs-attr"},"body"),Object(t["k"])(">")],-1),r=Object(t["k"])("\n\t"),i={class:"hljs-tag"},h=Object(t["k"])("<"),d=Object(t["i"])("span",{class:"hljs-name"},"div",-1),j=Object(t["k"])(),u=Object(t["i"])("span",{class:"hljs-attr"},"v-for",-1),m=Object(t["k"])("="),b=Object(t["i"])("span",{class:"hljs-string"},'"data of list"',-1),g=Object(t["k"])(),f=Object(t["i"])("span",{class:"hljs-attr"},":key",-1),y=Object(t["k"])("="),A={class:"hljs-string"},k=Object(t["k"])("\n\t"),w=Object(t["i"])("view",{data:"{{data}}",slot:"body"},null,-1),v=Object(t["k"])("\n"),_=Object(t["k"])("\n");function O(s,a){var n=Object(t["H"])("block");return Object(t["z"])(),Object(t["h"])("section",l,[Object(t["i"])("html",null,[e,Object(t["i"])("body",null,[p,Object(t["i"])("pre",null,[Object(t["i"])("code",c,[o,r,Object(t["i"])("span",i,[h,d,j,u,m,b,g,f,y,Object(t["i"])("span",A,'"data.id>'+Object(t["K"])(s.data.name)+"</div>\n</template>\n",1)])])]),Object(t["i"])("pre",null,[Object(t["i"])("code",null,[Object(t["l"])(n,{"wx:for":"{{list}}","wx:for-item":"data","wx:for-index":"data.id","wx:key":"data.id"},{default:Object(t["Q"])((function(){return[k,w,v]})),_:1}),_])])])])])}var C=n("6b0d"),x=n.n(C);const I={},E=x()(I,[["render",O]]);a["default"]=E},9073:function(s,a,n){},9238:function(s,a,n){"use strict";n.r(a);var t=n("7a23"),l={class:"markdown-body"},e=Object(t["j"])('<html><head></head><body><h1>React+Webpack+Typescript 项目初始化</h1><h2>项目目录结构</h2><pre><code>├─build\n├─dist\n└─src\n  └─components\n</code></pre><p>build 文件夹存放 webpack 配置相关的文件，dist 用于 webpack 打包。src 文件夹存放项目名源码（react+typescript）。</p><h2>npm init</h2><pre><code class="language-sh">npm init\n</code></pre><p>通过该命令初始化<code>package.json</code>文件。全部默认即可，之后可以随时修改。</p><pre><code class="language-json">{\n\t<span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;test-proj&quot;</span>,\n\t<span class="hljs-attr">&quot;version&quot;</span>: <span class="hljs-string">&quot;1.0.0&quot;</span>,\n\t<span class="hljs-attr">&quot;description&quot;</span>: <span class="hljs-string">&quot;test project&quot;</span>,\n\t<span class="hljs-attr">&quot;main&quot;</span>: <span class="hljs-string">&quot;index.js&quot;</span>,\n\t<span class="hljs-attr">&quot;scripts&quot;</span>: {\n\t\t<span class="hljs-attr">&quot;test&quot;</span>: <span class="hljs-string">&quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;</span>\n\t},\n\t<span class="hljs-attr">&quot;author&quot;</span>: <span class="hljs-string">&quot;czzczz&quot;</span>,\n\t<span class="hljs-attr">&quot;license&quot;</span>: <span class="hljs-string">&quot;ISC&quot;</span>\n}\n</code></pre><h2>安装依赖包</h2><p>安装 webpack</p><pre><code class="language-sh">npm install -g webpack\n</code></pre><p>安装 react 包以及 types 名下的 react 包。</p><pre><code>npm install --save react react-dom @types/react @types/react-dom\n</code></pre><p>安装开发依赖，使得 typescript 正常工作。</p><pre><code>npm install --save-dev typescript awesome-typescript-loader source-map-loader\n</code></pre><h2>TypeScript 配置文件</h2><p>文件名<code>tsconfig.json</code></p><pre><code class="language-json">{\n\t<span class="hljs-attr">&quot;compilerOptions&quot;</span>: {\n\t\t<span class="hljs-attr">&quot;outDir&quot;</span>: <span class="hljs-string">&quot;./dist/&quot;</span>,\n\t\t<span class="hljs-attr">&quot;sourceMap&quot;</span>: <span class="hljs-literal">true</span>,\n\t\t<span class="hljs-attr">&quot;noImplicitAny&quot;</span>: <span class="hljs-literal">true</span>,\n\t\t<span class="hljs-attr">&quot;module&quot;</span>: <span class="hljs-string">&quot;commonjs&quot;</span>,\n\t\t<span class="hljs-attr">&quot;target&quot;</span>: <span class="hljs-string">&quot;es5&quot;</span>,\n\t\t<span class="hljs-attr">&quot;lib&quot;</span>: [<span class="hljs-string">&quot;es6&quot;</span>, <span class="hljs-string">&quot;dom&quot;</span>],\n\t\t<span class="hljs-attr">&quot;jsx&quot;</span>: <span class="hljs-string">&quot;react&quot;</span>\n\t},\n\t<span class="hljs-attr">&quot;include&quot;</span>: [<span class="hljs-string">&quot;./src/**/*&quot;</span>]\n}\n</code></pre><p><code>target</code>为 es6。<code>include</code>中包含所有 tsx、ts 文件的路径。</p><h2>写点示例组件</h2><pre><code class="language-tsx"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#39;react&#39;</span>;\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> AppProps {\n\t<span class="hljs-attr">compiler</span>: <span class="hljs-built_in">string</span>;\n\tframework: <span class="hljs-built_in">string</span>;\n}\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> App = <span class="hljs-function">(<span class="hljs-params">props: AppProps</span>) =&gt;</span> (\n\t<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>\n\t\tHello from {props.compiler} and {props.framework}!\n\t<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>\n);\n</code></pre><pre><code class="language-tsx"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#39;react&#39;</span>;\n<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">&#39;react-dom&#39;</span>;\n\n<span class="hljs-keyword">import</span> { App } <span class="hljs-keyword">from</span> <span class="hljs-string">&#39;./components/App&#39;</span>;\n\nReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> <span class="hljs-attr">compiler</span>=<span class="hljs-string">&quot;TypeScript&quot;</span> <span class="hljs-attr">framework</span>=<span class="hljs-string">&quot;React&quot;</span> /&gt;</span></span>, <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#39;root&#39;</span>));\n</code></pre><h2>根文件<code>index.html</code></h2><pre><code class="language-html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>\n\t<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>\n\t\t<span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span>\n\t\t<span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Hello React!<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>\n\t<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>\n\t<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>\n\t\t<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;root&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n\n\t\t<span class="hljs-comment">&lt;!-- Dependencies --&gt;</span>\n\t\t<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./node_modules/react/umd/react.development.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n\t\t<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./node_modules/react-dom/umd/react-dom.development.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n\n\t\t<span class="hljs-comment">&lt;!-- Main --&gt;</span>\n\t\t<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./dist/bundle.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n\t<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>\n</code></pre><p>bundle.js 的路径记得为你 webpack 打包的输出路径。</p><h2>Webpack.config.js</h2><pre><code class="language-js"><span class="hljs-built_in">module</span>.exports = {\n\t<span class="hljs-attr">entry</span>: <span class="hljs-string">&#39;./src/index.tsx&#39;</span>,\n\t<span class="hljs-attr">output</span>: {\n\t\t<span class="hljs-attr">filename</span>: <span class="hljs-string">&#39;bundle.js&#39;</span>,\n\t\t<span class="hljs-attr">path</span>: __dirname + <span class="hljs-string">&#39;/../dist&#39;</span>,\n\t},\n\n\t<span class="hljs-comment">// Enable sourcemaps for debugging webpack&#39;s output.</span>\n\t<span class="hljs-attr">devtool</span>: <span class="hljs-string">&#39;source-map&#39;</span>,\n\n\t<span class="hljs-attr">resolve</span>: {\n\t\t<span class="hljs-comment">// Add &#39;.ts&#39; and &#39;.tsx&#39; as resolvable extensions.</span>\n\t\t<span class="hljs-attr">extensions</span>: [<span class="hljs-string">&#39;.ts&#39;</span>, <span class="hljs-string">&#39;.tsx&#39;</span>, <span class="hljs-string">&#39;.js&#39;</span>, <span class="hljs-string">&#39;.json&#39;</span>],\n\t},\n\n\t<span class="hljs-attr">module</span>: {\n\t\t<span class="hljs-attr">rules</span>: [\n\t\t\t<span class="hljs-comment">// All files with a &#39;.ts&#39; or &#39;.tsx&#39; extension will be handled by &#39;awesome-typescript-loader&#39;.</span>\n\t\t\t{ <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\\.tsx?$/</span>, loader: <span class="hljs-string">&#39;awesome-typescript-loader&#39;</span> },\n\n\t\t\t<span class="hljs-comment">// All output &#39;.js&#39; files will have any sourcemaps re-processed by &#39;source-map-loader&#39;.</span>\n\t\t\t{ <span class="hljs-attr">enforce</span>: <span class="hljs-string">&#39;pre&#39;</span>, <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\\.js$/</span>, loader: <span class="hljs-string">&#39;source-map-loader&#39;</span> },\n\t\t],\n\t},\n\n\t<span class="hljs-comment">// When importing a module whose path matches one of the following, just</span>\n\t<span class="hljs-comment">// assume a corresponding global variable exists and use that instead.</span>\n\t<span class="hljs-comment">// This is important because it allows us to avoid bundling all of our</span>\n\t<span class="hljs-comment">// dependencies, which allows browsers to cache those libraries between builds.</span>\n\t<span class="hljs-attr">externals</span>: {\n\t\t<span class="hljs-attr">react</span>: <span class="hljs-string">&#39;React&#39;</span>,\n\t\t<span class="hljs-string">&#39;react-dom&#39;</span>: <span class="hljs-string">&#39;ReactDOM&#39;</span>,\n\t},\n};\n</code></pre><p><code>entry</code>为你的 react 入口文件。<code>output.path</code>为<code>bundle.js</code>的输出目录，按照之前 index.html 的引用位置，设置为项目根目录的 dist 文件夹。</p><h2>尝试打包</h2><p>在 package.json 的 script 字段中添加：</p><pre><code class="language-json"><span class="hljs-string">&quot;build&quot;</span>: <span class="hljs-string">&quot;webpack --config build/webpack.config.js&quot;</span>,\n</code></pre><p>打包：</p><pre><code>npm run build\n</code></pre><p>在项目目录中的 dist 文件夹中出现了 bundle.js 以及 bundle.js.map 文件，打包成功，此时用浏览器打开 index.html 可以正常显示示例组件了。</p><h2>通过 webpack-dev-server 启用热更新。</h2><pre><code>npm install --save-dev webpack webpack-cli webpack-dev-server\n</code></pre><h3>在 package.json 的 script 中添加命令</h3><pre><code class="language-json"><span class="hljs-string">&quot;dev&quot;</span>: <span class="hljs-string">&quot;webpack-dev-server --hot --inline --colors --config build/webpack.config.js&quot;</span>,\n</code></pre><h3>修改 webpack.config.js 文件。</h3><p>添加 devServer 字段与 plugins 字段：</p><pre><code class="language-js"><span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#39;webpack&#39;</span>);\n\n<span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#39;path&#39;</span>);\n\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolve</span>(<span class="hljs-params">name</span>) </span>{\n\t<span class="hljs-keyword">let</span> res = path.join(__dirname, <span class="hljs-string">&#39;..&#39;</span>, name);\n\t<span class="hljs-keyword">return</span> res;\n}\n\n<span class="hljs-built_in">module</span>.exports = {\n\t<span class="hljs-attr">entry</span>: resolve(<span class="hljs-string">&#39;src/index.tsx&#39;</span>),\n\t<span class="hljs-attr">output</span>: {\n\t\t<span class="hljs-attr">filename</span>: <span class="hljs-string">&#39;bundle.js&#39;</span>,\n\t\t<span class="hljs-attr">path</span>: resolve(<span class="hljs-string">&#39;dist/&#39;</span>),\n\t},\n\n\t<span class="hljs-attr">devServer</span>: {\n\t\t<span class="hljs-attr">host</span>: <span class="hljs-string">&#39;localhost&#39;</span>,\n\t\t<span class="hljs-attr">port</span>: <span class="hljs-number">3000</span>,\n\t\t<span class="hljs-attr">historyApiFallback</span>: <span class="hljs-literal">true</span>,\n\t},\n\n\t<span class="hljs-comment">// Enable sourcemaps for debugging webpack&#39;s output.</span>\n\t<span class="hljs-attr">devtool</span>: <span class="hljs-string">&#39;source-map&#39;</span>,\n\n\t<span class="hljs-attr">resolve</span>: {\n\t\t<span class="hljs-comment">// Add &#39;.ts&#39; and &#39;.tsx&#39; as resolvable extensions.</span>\n\t\t<span class="hljs-attr">extensions</span>: [<span class="hljs-string">&#39;.ts&#39;</span>, <span class="hljs-string">&#39;.tsx&#39;</span>, <span class="hljs-string">&#39;.js&#39;</span>, <span class="hljs-string">&#39;.json&#39;</span>],\n\t},\n\n\t<span class="hljs-attr">module</span>: {\n\t\t<span class="hljs-attr">rules</span>: [\n\t\t\t<span class="hljs-comment">// All files with a &#39;.ts&#39; or &#39;.tsx&#39; extension will be handled by &#39;awesome-typescript-loader&#39;.</span>\n\t\t\t{ <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\\.tsx?$/</span>, loader: <span class="hljs-string">&#39;awesome-typescript-loader&#39;</span> },\n\n\t\t\t<span class="hljs-comment">// All output &#39;.js&#39; files will have any sourcemaps re-processed by &#39;source-map-loader&#39;.</span>\n\t\t\t{ <span class="hljs-attr">enforce</span>: <span class="hljs-string">&#39;pre&#39;</span>, <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\\.js$/</span>, loader: <span class="hljs-string">&#39;source-map-loader&#39;</span> },\n\t\t],\n\t},\n\n\t<span class="hljs-comment">// When importing a module whose path matches one of the following, just</span>\n\t<span class="hljs-comment">// assume a corresponding global variable exists and use that instead.</span>\n\t<span class="hljs-comment">// This is important because it allows us to avoid bundling all of our</span>\n\t<span class="hljs-comment">// dependencies, which allows browsers to cache those libraries between builds.</span>\n\t<span class="hljs-attr">externals</span>: {\n\t\t<span class="hljs-attr">react</span>: <span class="hljs-string">&#39;React&#39;</span>,\n\t\t<span class="hljs-string">&#39;react-dom&#39;</span>: <span class="hljs-string">&#39;ReactDOM&#39;</span>,\n\t},\n\t<span class="hljs-attr">plugins</span>: [<span class="hljs-keyword">new</span> webpack.HotModuleReplacementPlugin()],\n};\n</code></pre><h3>修改 html 文件中 bundle 的引用</h3><p>将 index.html 中的 bundle 引用改为引用根目录的文件，因为 webpack-dev-server 并不会根据 output.path 的路径来构建。</p><pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./bundle.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n</code></pre><h3>运行</h3><pre><code>npm run dev\n</code></pre><p>成功启用了热更新！</p><h2>添加 redux 以及 react-router</h2><pre><code>npm install --save redux react-redux @types/redux @types/react-redux\nnpm install --save react-router-dom @types/react-router-dom\n</code></pre><p>然后该咋用咋用。</p><h2>配置 css-modules 和 sass</h2><pre><code>npm install --save-dev css-loader node-sass sass-loader style-loader\n</code></pre><p><code>webpack.config.js</code>的<code>modules.rules</code>中添加两项</p><pre><code class="language-js">            <span class="hljs-comment">// 。。。</span>\n            {\n                <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\\.(sa|sc|c)ss$/</span>,\n                use: [\n                    {\n                        <span class="hljs-attr">loader</span>: <span class="hljs-string">&#39;style-loader&#39;</span>\n                    },\n                    {\n                        <span class="hljs-attr">loader</span>: <span class="hljs-string">&#39;css-loader&#39;</span>\n                    },\n                    {\n                        <span class="hljs-attr">loader</span>: <span class="hljs-string">&#39;sass-loader&#39;</span>,\n                    },\n                ],\n                <span class="hljs-attr">include</span>: [resolve(<span class="hljs-string">&#39;node_modules/&#39;</span>), resolve(<span class="hljs-string">&#39;src/components/style/global&#39;</span>)],\n            },\n            {\n                <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\\.(sa|sc|c)ss$/</span>,\n                use: [\n                    {\n                        <span class="hljs-attr">loader</span>: <span class="hljs-string">&#39;style-loader&#39;</span>\n                    },\n                    {\n                        <span class="hljs-attr">loader</span>: <span class="hljs-string">&#39;css-loader&#39;</span>,\n                        <span class="hljs-attr">options</span>: {\n                            <span class="hljs-attr">modules</span>: {<span class="hljs-comment">//设置css-modules</span>\n                                <span class="hljs-attr">localIdentName</span>: <span class="hljs-string">&quot;[name]__[local]___[hash:base64:5]&quot;</span>,\n                            },\n                        }\n                        <span class="hljs-comment">// loader: &#39;typings-for-css-modules-loader&#39;,</span>\n                        <span class="hljs-comment">// options: {</span>\n                        <span class="hljs-comment">//     modules: true,</span>\n                        <span class="hljs-comment">//     namedExport: true,</span>\n                        <span class="hljs-comment">//     camelCase: true,</span>\n                        <span class="hljs-comment">//     minimize: true,</span>\n                        <span class="hljs-comment">//     localIdentName: &quot;[name]__[local]___[hash:base64:5]&quot;</span>\n                        <span class="hljs-comment">// },</span>\n                    },\n                    {\n                        <span class="hljs-attr">loader</span>: <span class="hljs-string">&#39;sass-loader&#39;</span>,\n                    },\n                ],\n                <span class="hljs-attr">exclude</span>: [resolve(<span class="hljs-string">&#39;node_modules/&#39;</span>), resolve(<span class="hljs-string">&#39;src/components/style/global&#39;</span>)],\n            },\n            <span class="hljs-comment">// 。。。</span>\n</code></pre><p>其中<code>css-loader@3.0.0</code>之后将 modules 从 boolean 换成了对象，localIdentName 属性移入其中。</p><p>如果是普通 js 项目，此时已经配置完成，可以通过<code>import from</code>语法引入相对应的 css-module 文件了。 但如果是 typescript，引入会失败并报错<code>&#39;Cannot find module &#39;./App.css&#39;&#39;</code>，这是由于 typescript 对 import 的特殊封装导致的。</p><h3>css-modules 配合 typescript</h3><p>解决方案 1：</p><pre><code class="language-js"><span class="hljs-keyword">const</span> appStyles = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#39;./App.css&#39;</span>);\n</code></pre><p>较为简单的解决方案，强行绕过 typescript 的 import。</p><p>解决方案 2（完善）：</p><p>通过<code>ts</code>的声明文件<code>d.ts</code>来对模块进行声明。</p><pre><code>npm install --save typings-for-css-modules-loader css-loader@1.0.0\n</code></pre><p>由于该模块只支持<code>css-loader@1.0</code>，所以重新安装<code>css-loader</code>。</p><p>然后修改 webpack 配置的 loader 部分。</p><pre><code class="language-js"><span class="hljs-comment">// loader: &#39;css-loader&#39;,</span>\n<span class="hljs-comment">// options: {</span>\n<span class="hljs-comment">//     modules: {//设置css-modules</span>\n<span class="hljs-comment">//         localIdentName: &quot;[name]__[local]___[hash:base64:5]&quot;,</span>\n<span class="hljs-comment">//     },</span>\n<span class="hljs-comment">// }</span>\n<span class="hljs-attr">loader</span>: <span class="hljs-string">&#39;typings-for-css-modules-loader&#39;</span>,\n<span class="hljs-attr">options</span>: {\n    <span class="hljs-attr">modules</span>: <span class="hljs-literal">true</span>,\n    <span class="hljs-attr">namedExport</span>: <span class="hljs-literal">true</span>,\n    <span class="hljs-attr">camelCase</span>: <span class="hljs-literal">true</span>,\n    <span class="hljs-attr">minimize</span>: <span class="hljs-literal">true</span>,\n    <span class="hljs-attr">localIdentName</span>: <span class="hljs-string">&quot;[name]__[local]___[hash:base64:5]&quot;</span>\n},\n</code></pre><p>此时可以按照 es6 语法来引入 css-module 了，由于 css 打包次序会比 typescript 晚，导致一开始控制台会报错（实际上马上就会打包好，并不影响开发与调试），但是之后就不会了。</p><h3>css-modules, sass 配合 typescript</h3><p>删除<code>typings-for-css-modules-loader</code>依赖，将<code>awesome-typescript-loader</code>依赖更换为<code>ts-loader</code></p><pre><code>npm install --save-dev @types/node-sass css-modules-typescript-loader ts-loader\n</code></pre><p>修改 webpack 设置</p><pre><code class="language-js"><span class="hljs-comment">// 。。。</span>\n{ <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\\.tsx?$/</span>, loader: <span class="hljs-string">&quot;ts-loader&quot;</span> },\n{\n    <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\\.(sa|sc|c)ss$/</span>,\n    use: [\n        {\n            <span class="hljs-attr">loader</span>: <span class="hljs-string">&#39;style-loader&#39;</span>\n        },\n        {\n            <span class="hljs-attr">loader</span>: <span class="hljs-string">&#39;css-loader&#39;</span>\n        },\n        {\n            <span class="hljs-attr">loader</span>: <span class="hljs-string">&#39;sass-loader&#39;</span>,\n        },\n    ],\n    <span class="hljs-attr">include</span>: [resolve(<span class="hljs-string">&#39;node_modules/&#39;</span>), resolve(<span class="hljs-string">&#39;src/components/style/global&#39;</span>)],\n},\n{\n    <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\\.(sa|sc|c)ss$/</span>,\n    use: [\n        {\n            <span class="hljs-attr">loader</span>: <span class="hljs-string">&#39;style-loader&#39;</span>\n        },\n        {\n            <span class="hljs-attr">loader</span>: <span class="hljs-string">&quot;css-modules-typescript-loader&quot;</span>\n        },\n        {\n            <span class="hljs-attr">loader</span>: <span class="hljs-string">&#39;css-loader&#39;</span>,\n            <span class="hljs-attr">options</span>: {\n                <span class="hljs-attr">modules</span>: <span class="hljs-literal">true</span>,\n                <span class="hljs-attr">localIdentName</span>: <span class="hljs-string">&quot;[name]__[local]___[hash:base64:5]&quot;</span>\n            },\n        },\n        {\n            <span class="hljs-attr">loader</span>: <span class="hljs-string">&#39;sass-loader&#39;</span>,\n        },\n    ],\n    <span class="hljs-attr">exclude</span>: [resolve(<span class="hljs-string">&#39;node_modules/&#39;</span>), resolve(<span class="hljs-string">&#39;src/components/style/global&#39;</span>)],\n},\n<span class="hljs-comment">// 。。。</span>\n</code></pre><p>在项目中添加文件<code>declarations.d.ts</code></p><pre><code class="language-ts"><span class="hljs-keyword">declare</span> <span class="hljs-built_in">module</span> <span class="hljs-string">&#39;*.scss&#39;</span>;\n</code></pre></body></html>',1),p=[e];function c(s,a){return Object(t["z"])(),Object(t["h"])("section",l,p)}var o=n("6b0d"),r=n.n(o);const i={},h=r()(i,[["render",c]]);a["default"]=h},"92a2":function(s,a,n){"use strict";n.r(a);var t=n("7a23"),l=n("08f3"),e=n.n(l),p=n("35b4"),c=n.n(p),o=n("72bc"),r=n.n(o),i={class:"markdown-body"},h=Object(t["j"])('<html><head></head><body><h1>css3 背景渐变色</h1><pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">\n\t<span class="hljs-selector-class">.linear</span> {\n\t\t<span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;\n\t\t<span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;\n\t\t<span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;\n\t\t<span class="hljs-attribute">background</span>: <span class="hljs-built_in">linear-gradient</span>(to left top, <span class="hljs-number">#333</span> <span class="hljs-number">50%</span>, <span class="hljs-number">#eee</span> <span class="hljs-number">50%</span>, red <span class="hljs-number">80%</span>, red <span class="hljs-number">80%</span>, green <span class="hljs-number">80%</span>);\n\t}\n</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;linear&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n</code></pre><p><img src="'+e.a+'" alt="线性渐变"></p><p>第一个参数可选，为方向或角度，后面的参数指定渐变的颜色与渐变的点。 方向的可选参数：to top/right/left/bottom/角度(如 90deg)。</p><h2>重复的线性渐变：<code>repeating-linear-gradient</code></h2><h2>径向渐变 <code>radial-gradient</code></h2><h2>径向渐变可用于实现卡片缺口</h2><p><strong>实现的缺口其实是背景图的一部分，因此 box-shadow 不会计算空白区域从而导致阴影位置异常，若需要阴影可能需要再设置两个圆形元素设置颜色来补齐阴影的缺口</strong></p><pre><code class="language-css"><span class="hljs-selector-class">.child</span> {\n\t<span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;\n\t<span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;\n\t<span class="hljs-comment">/*以 21px  22px 的位置一个 20px 15px的椭圆为中心进行渐变*/</span>\n\t<span class="hljs-attribute">background</span>: <span class="hljs-built_in">radial-gradient</span>(ellipse <span class="hljs-number">20px</span> <span class="hljs-number">10px</span> at <span class="hljs-number">21px</span> <span class="hljs-number">22px</span>, , , <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>) <span class="hljs-number">30px</span>, <span class="hljs-number">#fff</span> <span class="hljs-number">30px</span>);\n\t<span class="hljs-attribute">border-radius</span>: <span class="hljs-number">20px</span>;\n}\n</code></pre><pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">\n\t<span class="hljs-selector-class">.linear</span> {\n\t\t<span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;\n\t\t<span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;\n\t\t<span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;\n\t\t<span class="hljs-attribute">background</span>: <span class="hljs-built_in">radial-gradient</span>(circle, <span class="hljs-number">#333</span> <span class="hljs-number">50%</span>, <span class="hljs-number">#eee</span> <span class="hljs-number">50%</span>, red <span class="hljs-number">80%</span>, red <span class="hljs-number">80%</span>, green <span class="hljs-number">80%</span>);\n\t}\n</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;linear&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n</code></pre><p>形状可选 circle 或 ellipse，默认为椭圆 ellipse</p><p><img src="'+c.a+'" alt="径向渐变"></p><h3>径向渐变实现卡券效果（带阴影）</h3><pre><code class="language-css"><span class="hljs-selector-class">.card</span> {\n\t<span class="hljs-attribute">margin</span>: <span class="hljs-number">50px</span>;\n\t<span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;\n\t<span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;\n\t<span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">radial-gradient</span>(circle at left <span class="hljs-number">30%</span>, transparent <span class="hljs-number">10px</span>, red <span class="hljs-number">10px</span>), <span class="hljs-built_in">radial-gradient</span>(circle at right\n\t\t\t\t<span class="hljs-number">30%</span>, transparent <span class="hljs-number">10px</span>, red <span class="hljs-number">10px</span>);\n\t<span class="hljs-attribute">background-position</span>: left <span class="hljs-number">0</span>, right <span class="hljs-number">0</span>;\n\t<span class="hljs-attribute">background-size</span>: <span class="hljs-number">50%</span> <span class="hljs-number">100%</span>, <span class="hljs-number">50%</span> <span class="hljs-number">100%</span>;\n\t<span class="hljs-attribute">background-repeat</span>: no-repeat, no-repeat;\n\t<span class="hljs-attribute">filter</span>: <span class="hljs-built_in">drop-shadow</span>(<span class="hljs-number">3px</span> <span class="hljs-number">5px</span> <span class="hljs-number">4px</span> <span class="hljs-number">#666</span>);\n}\n</code></pre><p><img src="'+r.a+'" alt="卡券缺口特效"></p><h2>重复的径向渐变 <code>repeating-radial-gradient</code></h2></body></html>',1),d=[h];function j(s,a){return Object(t["z"])(),Object(t["h"])("section",i,d)}var u=n("6b0d"),m=n.n(u);const b={},g=m()(b,[["render",j]]);a["default"]=g},"93d2":function(s,a,n){},"93de":function(s,a,n){var t={"./README.md":["ebed",9],"./css/CSS3动画.md":["bc01",9],"./css/CSS样式初始化.md":["64e4",9],"./css/CSS样式继承.md":["9f28",9],"./css/CSS选择器.md":["7e15",9],"./css/background.md":["da65",9],"./css/css3文本效果.md":["9ac4",9],"./css/css3盒模型.md":["9ad7",9],"./css/css3背景渐变色.md":["92a2",9],"./css/css3边框特效.md":["1a22",9],"./css/css常用元素居中方法.md":["68ce",9],"./css/css的link与import.md":["523d",9],"./css/css的position.md":["f100",9],"./css/images/background-clip.jpg":["d963",7],"./css/images/outline.png":["4357",7],"./css/images/writing-mode.jpg":["d4a4",7],"./css/images/卡券缺口特效.png":["72bc",7],"./css/images/径向渐变.png":["35b4",7],"./css/images/浮动-BFC.png":["7779",7],"./css/images/浮动-clear.png":["5379",7],"./css/images/浮动.png":["9484",7],"./css/images/浮动换行遇到margin.png":["e510",7],"./css/images/浮动换行遇到反向margin.png":["b244",7],"./css/images/线性渐变.png":["08f3",7],"./git/cherry-pick.md":["9eef",9],"./git/fetch.md":["04f5",9],"./git/log.md":["ef90",9],"./git/revert.md":["2040",9],"./javascript/Generator.md":["7277",9],"./javascript/Iterator.md":["7fb8",9],"./javascript/JS事件队列.md":["2184",9],"./javascript/JS数据、存取描述符.md":["a468",9],"./javascript/JS数据类型.md":["a23a",9],"./javascript/JS模块.md":["2800",9],"./javascript/JS正则表达式.md":["edc9",9],"./javascript/JS箭头函数.md":["689d",9],"./javascript/JS缓存.md":["1b4d",9],"./javascript/JS遍历.md":["3f28",9],"./javascript/JS闭包.md":["0c37",9],"./javascript/JS防抖和节流.md":["aeb8",9],"./javascript/JS面向对象.md":["5593",9],"./javascript/Promise.md":["8c77",9],"./javascript/async与defer标签.md":["5490",9],"./javascript/images/async与defer.png":["b014",7],"./javascript/images/js数据类型转换.jpg":["fa12",7],"./javascript/images/事件循环顺序.png":["8617",7],"./javascript/implementation/Promise.md":["2b1c",9],"./javascript/implementation/array/数组扩展方法.md":["0529",9],"./javascript/implementation/function/call，apply和bind.md":["6429",9],"./javascript/implementation/function/new.md":["4607",9],"./javascript/implementation/object/深拷贝deepCopy.md":["2c28",9],"./javascript/implementation/readme.md":["c618",9],"./javascript/react/create-react-app配置.md":["b905",9],"./javascript/react/reactHook.md":["b14d",9],"./javascript/react/react生命周期.md":["0ffa",9],"./javascript/react/新建react-typescript-webpack项目.md":["9238",9],"./javascript/try-catch-finally.md":["89be",9],"./javascript/uni-app/cli创建项目.md":["3488",9],"./javascript/uni-app/微信小程序.md":["9023",9],"./javascript/vue/key的作用.md":["13bc",9],"./javascript/vue/vuex/$store注入原理.md":["a3da",9],"./javascript/vue/vuex/单向流动原理.md":["a350",9],"./javascript/vue/vue生命周期.md":["f482",9],"./javascript/vue/动态组件.md":["b3c3",9],"./javascript/webpack/loader.md":["7fda",9],"./javascript/webpack/plugin.md":["cc48",9],"./javascript/webpack/工作流程.md":["f4fa",9],"./javascript/with语句.md":["d8f1",9],"./javascript/网络请求.md":["f277",9],"./javascript/解构赋值.md":["ce23",9],"./projects/NpmCli工具包.md":["faec",9],"./projects/VSCode插件.md":["2a96",9],"./projects/images/AzureToken.png":["acbc",7],"./projects/前端错误上报.md":["94f6",9],"./projects/源码阅读/the-super-tiny-compiler.md":["3168",9],"./projects/源码阅读/vue3.md":["6f4a",9],"./python/Python装饰器.md":["b973",9],"./python/Python迭代器.md":["0997",9],"./python/Python闭包.md":["e0c0",9],"./python/Python面向对象.md":["cd44",9],"./typescript/ts类型断言.md":["32f5",9],"./typescript/ts高级类型.md":["50e1",9],"./typescript/unknown.md":["9e26",9]};function l(s){return Promise.resolve().then((function(){if(!n.o(t,s)){var a=new Error("Cannot find module '"+s+"'");throw a.code="MODULE_NOT_FOUND",a}var l=t[s],e=l[0];return n.t(e,l[1])}))}l.keys=function(){return Object.keys(t)},l.id="93de",s.exports=l},9484:function(s,a){s.exports="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAqEAAAD7CAYAAABaKE3mAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAAEnQAABJ0Ad5mH3gAAAUqSURBVHhe7dgxSkNBGEbRPDvRIgQCIU1aG0tXrruwtLFS0sRCEBttn6CzhVzFnNPM/+3gMtNmu5uXq/UC+PH+9ro4v7gcCwA4hu8IfTnsx+S/+3y6HRcAwO85Gy8AAGREKAAAOREKAEBOhAIAkBOhAADkRCgAADkRCgBAToQCAJAToQAA5EQoAAA5EQoAQE6EAgCQE6EAAOREKAAAOREKAEBOhAIAkBOhAADkRCgAADkRCgBAToQCAJAToQAA5EQoAAA5EQoAQE6EAgCQE6EAAOREKAAAOREKAEBOhAIAkBOhAADkRCgAADkRCgBAToQCAJAToQAA5EQoAAA5EQoAQE6EAgCQE6EAAOSmzXY3vxz2Y/4N0zyPi1Px8Xw3LgDgFPgJBQAgJ0IBAMiJUAAAciIUAICcCAUAICdCAQDIiVAAAHIiFACAnAgFACAnQgEAyIlQAAByIhQAgJwIBQAgJ0IBAMiJUAAAciIUAICcCAUAICdCAQDIiVAAAHIiFACAnAgFACAnQgEAyIlQAAByIhQAgNy02e7m5Wo95t/w+HA/Lk7F1fXNuACAU+AnFACAnAgFACAnQgEAyIlQAAByIhQAgJwIBQAgJ0IBAMiJUAAAciIUAICcCAUAICdCAQDIiVAAAHIiFACAnAgFACAnQgEAyIlQAAByIhQAgJwIBQAgJ0IBAMiJUAAAciIUAICcCAUAICdCAQDIiVAAAHIiFACAnAgFACAnQgEAyIlQAAByIhQAgJwIBQAgJ0IBAMiJUAAAciIUAICcCAUAICdCAQDIiVAAAHIiFACAnAgFACAnQgEAyIlQAAByIhQAgJwIBQAgJ0IBAMiJUAAAciIUAICcCAUAICdCAQDIiVAAAHIiFACAnAgFACAnQgEAyIlQAAByIhQAgJwIBQAgJ0IBAMiJUAAAciIUAICcCAUAICdCAQDIiVAAAHIiFACAnAgFACAnQgEAyIlQAAByIhQAgJwIBQAgJ0IBAMiJUAAAciIUAICcCAUAICdCAQDIiVAAAHIiFACAnAgFACAnQgEAyIlQAAByIhQAgJwIBQAgJ0IBAMiJUAAAciIUAICcCAUAICdCAQDIiVAAAHIiFACAnAgFACAnQgEAyIlQAAByIhQAgJwIBQAgJ0IBAMiJUAAAciIUAICcCAUAICdCAQDIiVAAAHIiFACAnAgFACAnQgEAyE2b7W5ertZjAgDA8fkJBQAgJ0IBAMiJUAAAciIUAICcCAUAICdCAQDIiVAAAHIiFACAnAgFACAnQgEAyIlQAAByIhQAgJwIBQAgJ0IBAMiJUAAAciIUAICcCAUAICdCAQDIiVAAAHIiFACAnAgFACAnQgEAyIlQAAByIhQAgJwIBQAgJ0IBAMiJUAAAciIUAICcCAUAICdCAQDIiVAAAHIiFACAnAgFACAnQgEAyIlQAAByIhQAgJwIBQAgJ0IBAMiJUAAAciIUAICcCAUAICdCAQDIiVAAAHIiFACAnAgFACAnQgEAyIlQAAByIhQAgJwIBQAgJ0IBAMiJUAAAciIUAICcCAUAICdCAQDIiVAAAHIiFACAnAgFACAnQgEAyIlQAAByIhQAgJwIBQAgJ0IBAMiJUAAAciIUAICcCAUAICdCAQDIiVAAAHIiFACAnAgFACAnQgEAyIlQAAByIhQAgJwIBQAgJ0IBAMiJUAAAciIUAICcCAUAICdCAQDIiVAAAHIiFACAnAgFACAnQgEAyIlQAAByIhQAgJwIBQAgJ0IBAIgtFl8zlBt6P+yHmAAAAABJRU5ErkJggg=="},"94f6":function(s,a,n){"use strict";n.r(a);var t=n("7a23"),l={class:"markdown-body"},e=Object(t["i"])("html",null,[Object(t["i"])("head"),Object(t["i"])("body",null,[Object(t["i"])("h1",null,"前端错误上报"),Object(t["i"])("p",null,"sentry"),Object(t["i"])("h2",null,"React"),Object(t["i"])("p",null,"错误边界")])],-1),p=[e];function c(s,a){return Object(t["z"])(),Object(t["h"])("section",l,p)}var o=n("6b0d"),r=n.n(o);const i={},h=r()(i,[["render",c]]);a["default"]=h},9745:function(s,a,n){"use strict";n.r(a),n.d(a,"install",(function(){return j}));n("b0c0"),n("a9e3");var t=n("7a23"),l=Object(t["m"])({name:"ShutBRow",props:{tag:{type:String,default:"div"},type:{type:String,default:"flex"},flexWrap:{type:Boolean,default:!0},justify:{type:String,default:"start"},align:{type:String,default:"top"},gutter:{type:Number,default:0}},setup:function(s,a){var n=a.slots;Object(t["B"])("RowGutter",s.gutter);var l=Object(t["d"])((function(){var a={};return s.gutter&&(a.marginRight=a.marginLeft="-".concat(s.gutter/2,"px")),a}));return function(){var a;return Object(t["o"])(s.tag,{class:["shut-b-row",s.type,"flex"===s.type&&s.flexWrap&&"flex-wrap","justify-".concat(s.justify),"align-".concat(s.align)],style:l.value},null===(a=n.default)||void 0===a?void 0:a.call(n))}}}),e=(n("5c98"),n("6b0d")),p=n.n(e);const c=p()(l,[["__scopeId","data-v-756dba42"]]);var o=c,r=n("53ca"),i=(n("d3b7"),n("99af"),n("159b"),n("b64b"),Object(t["m"])({name:"ShutBCol",props:{span:{type:Number,default:24},offset:{type:Number,default:0},pull:{type:Number,default:0},push:{type:Number,default:0},xs:{type:[Number,Object],default:function(){return{}}},sm:{type:[Number,Object],default:function(){return{}}},md:{type:[Number,Object],default:function(){return{}}},lg:{type:[Number,Object],default:function(){return{}}},xl:{type:[Number,Object],default:function(){return{}}}},setup:function(s,a){var n=a.slots,l=Object(t["p"])("RowGutter",0),e=Object(t["d"])((function(){return l?{display:"block",minHeight:"1px",paddingLeft:l/2+"px",paddingRight:l/2+"px"}:{}})),p=Object(t["d"])((function(){var a=[],n=["span","offset","pull","push"];n.forEach((function(n){var t=s[n];"number"===typeof t&&t>=0&&a.push("span"!==n?"shut-b-col-".concat(n,"-").concat(s[n]):"shut-b-col-".concat(s[n]))}));var t=["xs","sm","md","lg","xl"];return t.forEach((function(n){var t=s[n];"number"===typeof t?a.push("shut-b-col-".concat(n,"-").concat(t)):"object"===Object(r["a"])(t)&&Object.keys(t).forEach((function(s){var l=s;a.push("span"!==s?"shut-b-col-".concat(n,"-").concat(s,"-").concat(t[l]):"shut-b-col-".concat(n,"-").concat(t[l]))}))})),a}));return function(){var s;return Object(t["o"])("div",{class:["shut-b-col",p.value],style:e.value},null===(s=n.default)||void 0===s?void 0:s.call(n))}}}));n("e373");const h=p()(i,[["__scopeId","data-v-26cb1695"]]);var d=h,j=function(s){s.component(o.name,o),s.component(d.name,d)};a["default"]={install:j}},"9ac4":function(s,a,n){"use strict";n.r(a);var t=n("7a23"),l=n("d4a4"),e=n.n(l),p={class:"markdown-body"},c=Object(t["j"])('<html><head></head><body><h1>CSS3 文本效果</h1><h2><code>word-wrap: break-word;</code></h2><p>强制单词换行，遇到长单词会直接切割。</p><h2>text-overflow</h2><p>可选值为<code>clip</code>或<code>ellipsis</code>，用于控制单行文本超出的部分如何显示（直接溢出或者替换省略号）。 使单行文本自动换行的样式组合</p><pre><code class="language-css"><span class="hljs-selector-class">.target</span> {\n\t<span class="hljs-attribute">text-overflow</span>: ellipse;\n\t<span class="hljs-attribute">overflow</span>: hidden;\n\t<span class="hljs-attribute">white-space</span>: nowrap;\n\t<span class="hljs-comment">/* 除了这三个元素外，overflow: hidden; 还需要通过 width 等手段限制该单行文本的最大长度 */</span>\n}\n</code></pre><h2>text-shadow</h2><p>接收参数：</p><ol><li>h-shadow 必需。水平阴影的位置。允许负值。</li><li>v-shadow 必需。垂直阴影的位置。允许负值。</li><li>blur 可选。模糊距离。</li><li>color 可选。阴影的颜色。请参阅 CSS 颜色值。</li></ol><h2>text-decoration</h2><p>可选值：<code>overline | line-through | underline</code>，上划线|删除线|下划线。</p><h2>writing-mode</h2><p>自定义文本在元素里的排列方式（如竖向排列，从右到左放置）</p><p><img src="'+e.a+'" alt="writing-mode"></p><h2>user-select</h2><p>控制用户选择，可通过设置 none 限制用户选择</p></body></html>',1),o=[c];function r(s,a){return Object(t["z"])(),Object(t["h"])("section",p,o)}var i=n("6b0d"),h=n.n(i);const d={},j=h()(d,[["render",r]]);a["default"]=j},"9ad7":function(s,a,n){"use strict";n.r(a);var t=n("7a23"),l=n("9484"),e=n.n(l),p=n("5379"),c=n.n(p),o=n("7779"),r=n.n(o),i=n("e510"),h=n.n(i),d=n("b244"),j=n.n(d),u={class:"markdown-body"},m=Object(t["j"])('<html><head></head><body><h1>盒模型</h1><p>从外层到内层依次<code>margin</code>、<code>border</code>、<code>padding</code>、<code>content</code>组成的嵌套模型，大致分为两种：</p><h2>IE 盒模型</h2><p>IE 的 content 部分包含了 border 和 padding，height 属性也包含这两部分;</p><h2>W3C 标注模型</h2><p>即为标准盒模型。</p><h2>box-sizing 属性</h2><p>设置一个盒的宽度设置方式，若为<code>content-box</code>（默认），设置的宽度为盒子的 content 部分的宽度，盒子的实际宽度将会加上 padding 和 border；若为<code>border-box</code>，设置的宽度为 border+padding+content 的宽度，实际 content 的内容宽度将减去那两部分。</p><p>高度同理。</p><h2>float 浮动</h2><p><code>float: left | right;</code>，将元素脱离文档流靠向 X 轴的左侧或者右侧，脱离文档流的元素将与同父元素内部的非浮动子元素产生重叠（文字将会自动环绕），同样浮动的元素会依次排列，排列不下的将自动换行。由于浮动元素脱离文档流，其内容及 margin 高度将不计入父元素的高度计算。</p><pre><code class="language-html"><span class="hljs-comment">&lt;!-- html --&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;outer&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background: wheat;&quot;</span>&gt;</span>\n\t<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;inner f&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background: aqua;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n\t<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;inner s&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background: red;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n</code></pre><pre><code class="language-css"><span class="hljs-comment">/* css */</span>\n<span class="hljs-selector-tag">body</span> {\n\t<span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;\n\t<span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;\n}\n<span class="hljs-selector-class">.outer</span> {\n}\n<span class="hljs-selector-class">.inner</span> {\n\t<span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;\n\t<span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;\n}\n<span class="hljs-selector-class">.f</span> {\n\t<span class="hljs-attribute">margin</span>: <span class="hljs-number">30px</span>;\n\t<span class="hljs-attribute">float</span>: left;\n}\n<span class="hljs-selector-class">.s</span> {\n\t<span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;\n}\n</code></pre><p>浮动效果： <img src="'+e.a+'" alt="浮动效果"></p><h3>清除浮动的方法</h3><ul><li><code>clear: left | right | both;</code></li></ul><p>在需要清除浮动影响的元素（通常是浮动元素之后的第一个）中设置该属性，可设置该元素的对应方向不应存在浮动元素，若存在则自动下移，同时由于该元素的自动下移，以及该元素还在父元素的文档流中，因此浮动元素的体积即 margin 将计入父元素高度。</p><p><strong>也可通过父元素的 after 来清除浮动</strong></p><pre><code class="language-css"><span class="hljs-comment">/* 其他代码一致 */</span>\n<span class="hljs-selector-class">.s</span> {\n\t<span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;\n\t<span class="hljs-attribute">clear</span>: both;\n}\n</code></pre><p>clear 清除浮动： <img src="'+c.a+'" alt="clear清除浮动"></p><ul><li>将父元素设置为 BFC 块</li></ul><p>该设置会使得父元素计算高度时计入浮动元素的高度及 margin，但不会解决内部浮动元素以及非浮动元素的重叠问题。</p><pre><code class="language-css"><span class="hljs-comment">/* 其他代码保持一致 */</span>\n<span class="hljs-selector-class">.outer</span> {\n\t<span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;\n\t<span class="hljs-attribute">overflow</span>: auto;\n}\n</code></pre><p>BFC 清除浮动： <img src="'+r.a+'" alt="BFC清除浮动"></p><h3>基于浮动的排版</h3><p>同一方向的浮动元素默认会排成一行，若<code>宽度超过了父元素则自动换行</code>。</p><h4>浮动元素的 margin</h4><ul><li>当元素的浮动方向和 margin 的方向相同时，该元素可以覆盖或远离上一个浮动元素。</li><li>当元素的浮动方向和 margin 的方向相反时，该元素不能覆盖上一个浮动元素，最近只能紧贴上一个元素右边。</li></ul><p><a href="https://blog.csdn.net/Liu_yunzhao/article/details/103976547">解析实例</a></p><p><img src="'+h.a+'" alt="浮动排版与同向margin"></p><p><img src="'+j.a+'" alt="浮动排版与反向margin"></p><h4>圣杯布局</h4><p>利用浮动进行自适应布局的经典方案</p><p>主要实现过程</p><ol><li>中间栏设置 width100%表示跟父元素同宽，以此自适应。</li><li>三个元素都同向 float，此时他们是属于同一行的，不过由于中间栏<code>width: 100%</code>他们会被挤成 3 行。</li><li>通过 margin 将元素左移，让他们总宽度等于父元素，他们会排在一排但由于显示宽度导致后元素覆盖前元素。</li><li>对于 left 和 right 使用<code>position: relative</code>使其可以展示。此时虽然覆盖情况被消除但是 left 和 right 会被挤到父元素外部。</li><li>父元素设置 margin 或 padding，将 center 挤小，此时布局完成。</li></ol><p>圣杯布局的特点。</p><ol><li>不需要额外节点</li><li>屏幕宽度过小会导致布局混乱。</li><li>圣杯布局需要设置 body 的最小宽度，否则在 middle 元素小于 left 元素宽度时，布局会混乱。</li></ol><pre><code class="language-css"><span class="hljs-selector-tag">body</span> {\n\t<span class="hljs-attribute">min-width</span>: <span class="hljs-number">600px</span>;\n}\n</code></pre><pre><code class="language-html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>\n\t<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>\n\t\t<span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span>\n\t\t<span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span> /&gt;</span>\n\t\t<span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span>\n\t\t<span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>\n\t\t<span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">\n\t\t\t<span class="hljs-selector-class">.header</span> {\n\t\t\t\t<span class="hljs-attribute">height</span>: <span class="hljs-number">40px</span>;\n\t\t\t\t<span class="hljs-attribute">background</span>: lightblue;\n\t\t\t}\n\t\t\t<span class="hljs-selector-class">.footer</span> {\n\t\t\t\t<span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;\n\t\t\t\t<span class="hljs-attribute">background</span>: lightcoral;\n\t\t\t}\n\t\t\t<span class="hljs-selector-class">.main</span> {\n\t\t\t\t<span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> <span class="hljs-number">300px</span> <span class="hljs-number">0</span> <span class="hljs-number">200px</span>; <span class="hljs-comment">/*挤压父元素，使center宽度正常*/</span>\n\t\t\t}\n\t\t\t<span class="hljs-selector-class">.center</span> {\n\t\t\t\t<span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>; <span class="hljs-comment">/* 中间栏设置width100%表示跟父元素同宽，以此自适应 */</span>\n\t\t\t\t<span class="hljs-attribute">height</span>: <span class="hljs-number">500px</span>;\n\t\t\t\t<span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">200px</span>; <span class="hljs-comment">/*通过margin将元素左移，让他们总宽度等于父元素，他们会排在一排但由于显示宽度导致后元素覆盖前元素*/</span>\n\t\t\t\t<span class="hljs-attribute">float</span>: left; <span class="hljs-comment">/*三个元素均浮动，因此他们在文档流上是一行的*/</span>\n\t\t\t\t<span class="hljs-attribute">background</span>: lightgray;\n\t\t\t}\n\t\t\t<span class="hljs-selector-class">.left</span> {\n\t\t\t\t<span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;\n\t\t\t\t<span class="hljs-attribute">height</span>: <span class="hljs-number">500px</span>;\n\t\t\t\t<span class="hljs-attribute">float</span>: left;\n\t\t\t\t<span class="hljs-attribute">background</span>: lightpink;\n\t\t\t\t<span class="hljs-attribute">position</span>: relative; <span class="hljs-comment">/* 通过相对定位将每个元素显示出来*/</span>\n\t\t\t\t<span class="hljs-attribute">left</span>: -<span class="hljs-number">200px</span>;\n\t\t\t}\n\t\t\t<span class="hljs-selector-class">.right</span> {\n\t\t\t\t<span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;\n\t\t\t\t<span class="hljs-attribute">height</span>: <span class="hljs-number">500px</span>;\n\t\t\t\t<span class="hljs-attribute">float</span>: left;\n\t\t\t\t<span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">300px</span>;\n\t\t\t\t<span class="hljs-attribute">background</span>: lightgreen;\n\t\t\t\t<span class="hljs-attribute">position</span>: relative;\n\t\t\t\t<span class="hljs-attribute">right</span>: -<span class="hljs-number">300px</span>;\n\t\t\t}\n\t\t\t<span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">::after</span> {\n\t\t\t\t<span class="hljs-attribute">content</span>: <span class="hljs-string">&#39;&#39;</span>;\n\t\t\t\t<span class="hljs-attribute">display</span>: block;\n\t\t\t\t<span class="hljs-attribute">clear</span>: both;\n\t\t\t}\n\t\t</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>\n\t<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>\n\t<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>\n\t\t<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;header&quot;</span>&gt;</span>头部<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n\t\t<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;main clearfix&quot;</span>&gt;</span>\n\t\t\t<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span>左列定宽<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n\t\t\t<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span>中间自适应<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n\t\t\t<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span>右列定宽<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n\t\t<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n\t\t<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;footer&quot;</span>&gt;</span>底部<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n\t<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>\n</code></pre><h4>双飞翼布局</h4><p>同样是利用浮动布局。双飞翼布局和圣杯实现思路前面部分是相同的</p><p>实现</p><ol><li>与圣杯一致</li><li>与圣杯一致</li><li>与圣杯一致</li><li>双飞燕没有采用圣杯的方案，通过挤压 center 然后对 left，right 进行位移实现布局，而是<code>直接让left和right在前三步中覆盖center的左右两侧，然后center中增加一层节点center-wrap空出左右两个位置。最后将center真正的内容放到center-wrap中</code>。</li></ol><p>特点：</p><ol><li>优先渲染主内容区域，通用性强，不需要设置 body 最小宽度。</li><li>需要多一个元素节点。</li></ol><pre><code class="language-html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>\n\t<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>\n\t\t<span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span>\n\t\t<span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span> /&gt;</span>\n\t\t<span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span>\n\t\t<span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>\n\t\t<span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">\n\t\t\t<span class="hljs-selector-class">.header</span> {\n\t\t\t\t<span class="hljs-attribute">height</span>: <span class="hljs-number">40px</span>;\n\t\t\t\t<span class="hljs-attribute">background</span>: lightblue;\n\t\t\t}\n\t\t\t<span class="hljs-selector-class">.footer</span> {\n\t\t\t\t<span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;\n\t\t\t\t<span class="hljs-attribute">background</span>: lightcoral;\n\t\t\t}\n\t\t\t<span class="hljs-selector-class">.center</span> {\n\t\t\t\t<span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;\n\t\t\t\t<span class="hljs-attribute">height</span>: <span class="hljs-number">500px</span>;\n\t\t\t\t<span class="hljs-attribute">float</span>: left;\n\t\t\t\t<span class="hljs-attribute">background</span>: lightgray;\n\t\t\t}\n\t\t\t<span class="hljs-selector-class">.center-wrap</span> {\n\t\t\t\t<span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> <span class="hljs-number">300px</span> <span class="hljs-number">0</span> <span class="hljs-number">200px</span>;\n\t\t\t\t<span class="hljs-attribute">height</span>: <span class="hljs-number">500px</span>;\n\t\t\t\t<span class="hljs-attribute">background-color</span>: purple;\n\t\t\t}\n\t\t\t<span class="hljs-selector-class">.left</span> {\n\t\t\t\t<span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;\n\t\t\t\t<span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100%</span>;\n\t\t\t\t<span class="hljs-attribute">float</span>: left;\n\t\t\t\t<span class="hljs-attribute">background</span>: lightpink;\n\t\t\t}\n\t\t\t<span class="hljs-selector-class">.right</span> {\n\t\t\t\t<span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;\n\t\t\t\t<span class="hljs-attribute">height</span>: <span class="hljs-number">500px</span>;\n\t\t\t\t<span class="hljs-attribute">float</span>: left;\n\t\t\t\t<span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">300px</span>;\n\t\t\t\t<span class="hljs-attribute">background</span>: lightgreen;\n\t\t\t}\n\t\t\t<span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">::after</span> {\n\t\t\t\t<span class="hljs-attribute">content</span>: <span class="hljs-string">&#39;&#39;</span>;\n\t\t\t\t<span class="hljs-attribute">display</span>: block;\n\t\t\t\t<span class="hljs-attribute">clear</span>: both;\n\t\t\t}\n\t\t</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>\n\t<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>\n\t<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>\n\t\t<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;header&quot;</span>&gt;</span>头部<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n\t\t<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;main clearfix&quot;</span>&gt;</span>\n\t\t\t<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span>\n\t\t\t\t<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;center-wrap&quot;</span>&gt;</span>中间自适应<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n\t\t\t<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n\t\t\t<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span>左列定宽<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n\t\t\t<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span>右列定宽<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n\t\t<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n\t\t<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;footer&quot;</span>&gt;</span>底部<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n\t<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>\n</code></pre><h2>BFC 规范</h2><p>BFC（Block Formatting Context）格式化上下文，是 Web 页面中盒模型布局的 CSS 渲染模式，指一个独立的渲染区域或者说是一个隔离的独立容器</p><h3>BFC 形成条件</h3><ol><li>浮动元素，float 除 none 以外的值；</li><li>定位元素，position（absolute，fixed）；</li><li>display 为以下其中之一的值 inline-block, table-cell, table-caption, flex, inline-flex；</li><li>overflow 除了 visible 以外的值（hidden，auto，scroll）；</li></ol><h3>BFC 特性</h3><ol><li>内部的 Box 会在垂直方向上一个接一个的放置。</li><li>垂直方向上的距离由 margin 决定</li><li>bfc 的区域不会与 float 的元素区域重叠。</li><li>计算 bfc 的高度时，浮动元素也参与计算</li><li>bfc 就是页面上的一个独立容器，容器里面的子元素不会影响外面元素。</li></ol></body></html>',1),b=[m];function g(s,a){return Object(t["z"])(),Object(t["h"])("section",u,b)}var f=n("6b0d"),y=n.n(f);const A={},k=y()(A,[["render",g]]);a["default"]=k},"9e26":function(s,a,n){"use strict";n.r(a);var t=n("7a23"),l={class:"markdown-body"},e=Object(t["j"])("<html><head></head><body><h1>UnKnown 类型</h1><p>TS 中的<code>unknown</code>类型与<code>any</code>类似是一种顶层的类型，即<code>unknown</code>可用于代表未知类型或所有类型的类型</p><h2>比起 any 更需要 unknowm</h2><p>在功能开发中更鼓励使用类型推断、泛型等手段控制参数及变量类型。但具体开发中总需要一部分方法去接收不可预知的参数。</p><p>若一个参数被定义为 any 类型。那么对该参数做出任何操作都将被 ts 允许，这往往会导致不可预知的类型错误。</p><p>而一个数据若被定义为 unknown，虽然使用者<code>对之赋值时可以像any一样赋予任何类型的值</code>，但若 <strong>要对该数据直接做任何操作（将 unknown 指赋给 unkown 值或 any 值的操作除外），都会导致 TS 报错。 即类型推断会迫使开发者使用类型推断、类型收缩等方式将该数据固定为某个类型时才能进行操作</strong></p><p>类型收缩的方式</p><ul><li>typeof 判断类型</li><li>instanceof 判断类型</li><li>自定义类型保护函数</li></ul></body></html>",1),p=[e];function c(s,a){return Object(t["z"])(),Object(t["h"])("section",l,p)}var o=n("6b0d"),r=n.n(o);const i={},h=r()(i,[["render",c]]);a["default"]=h},"9e53":function(s,a,n){"use strict";n.r(a);n("b0c0");var t=n("7a23"),l=function(s){return Object(t["C"])("data-v-1184d35a"),s=s(),Object(t["A"])(),s},e=l((function(){return Object(t["i"])("div",{class:"empty-box"},"暂无数据",-1)}));function p(s,a,n,l,p,c){var o=Object(t["H"])("ShutBTreeNode"),r=Object(t["H"])("ShutBWrapper");return Object(t["z"])(),Object(t["f"])(r,{class:"shut-b-tree"},{default:Object(t["Q"])((function(){return[(Object(t["z"])(!0),Object(t["h"])(t["a"],null,Object(t["F"])(s.data,(function(a,n){return Object(t["z"])(),Object(t["f"])(o,{key:a[s.dataKey]||n,path:[n],data:a,style:Object(t["t"])({paddingLeft:s.indent/2+"px"})},null,8,["path","data","style"])})),128)),0===s.data.length?Object(t["G"])(s.$slots,"empty",{key:0},(function(){return[e]}),!0):Object(t["g"])("",!0)]})),_:3})}n("a9e3");var c=n("fc61"),o=(n("99af"),{class:"content"}),r={class:"shut-b-tree-children"};function i(s,a,n,l,e,p){var c=Object(t["H"])("ShutBIcon"),i=Object(t["H"])("ShutBTreeNodeContent"),h=Object(t["H"])("ShutBMask"),d=Object(t["H"])("ShutBTreeNode"),j=Object(t["H"])("ShutBCollapseTransition");return Object(t["z"])(),Object(t["h"])("div",{class:"shut-b-tree-node",style:Object(t["t"])({paddingLeft:s.treeCtx.props.indent+"px"})},[Object(t["i"])("div",{class:"shut-b-tree-node-body",onMouseover:a[0]||(a[0]=function(a){return s.toggleHover(!0)}),onMouseleave:a[1]||(a[1]=function(a){return s.toggleHover(!1)}),onClick:a[2]||(a[2]=Object(t["S"])((function(){return s.nodeClick&&s.nodeClick.apply(s,arguments)}),["stop"]))},[Object(t["l"])(c,{class:Object(t["s"])({expand:s.state.expand}),name:"i-chevron_right_24px",visible:0!==(s.data[s.treeCtx.props.childrenKey]||[]).length},null,8,["class","visible"]),Object(t["i"])("div",o,[Object(t["l"])(i,{data:s.data},null,8,["data"])]),Object(t["l"])(h,{backgroundColor:"#000",visible:s.state.hovered},null,8,["visible"])],32),Object(t["l"])(j,null,{default:Object(t["Q"])((function(){return[Object(t["R"])(Object(t["i"])("div",r,[(Object(t["z"])(!0),Object(t["h"])(t["a"],null,Object(t["F"])(s.children,(function(a,n){return Object(t["z"])(),Object(t["f"])(d,{key:a[s.treeCtx.props.dataKey]||n,path:s.path.concat(n),data:a},null,8,["path","data"])})),128))],512),[[t["N"],s.state.expand]])]})),_:1})],4)}var h=n("db95"),d=n("4b77"),j=Object,u=Array,m=Object(t["m"])({name:"ShutBTreeNodeContent",props:{data:{type:j,default:function(){return[]}}},setup:function(s){var a=Object(t["p"])("treeCtx");a||console.error("TreeNode must work in Tree Context");var n=Object(t["d"])((function(){return(null===a||void 0===a?void 0:a.props.labelKey)||"name"}));return function(){var l,e,p=(null===a||void 0===a||null===(l=(e=a.ctx.slots).default)||void 0===l?void 0:l.call(e,{data:s.data}))||[Object(t["o"])("span",{class:"shut-b-tree-node__label"},[s.data[n.value]])];return p}}}),b=(n("a60b"),n("6b0d")),g=n.n(b);const f=g()(m,[["__scopeId","data-v-4ad95c74"]]);var y=f,A=Object(t["m"])({name:"ShutBTreeNode",props:{data:{type:j,default:function(){return[]}},path:{type:Array}},setup:function(s){var a=Object(t["p"])("treeCtx");a||console.error("TreeNode must work in Tree Context");var n=Object(t["D"])({expand:!1,hovered:!1}),l=Object(t["d"])((function(){var n=(null===a||void 0===a?void 0:a.props.childrenKey)||"name",t=s.data;return t[n]||[]})),e=function(){var t;n.expand=!n.expand,null===a||void 0===a||null===(t=a.ctx)||void 0===t||t.emit("nodeClick",s.data,{path:s.path,state:n})},p=function(){var s=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];n.hovered=s};return{treeCtx:a,state:n,children:l,nodeClick:e,toggleHover:p}},components:{ShutBIcon:h["a"],ShutBTreeNodeContent:y,ShutBCollapseTransition:d["a"]}});n("7289");const k=g()(A,[["render",i],["__scopeId","data-v-2ff11aed"]]);var w=k,v=Object(t["m"])({name:"ShutBTree",props:{data:{type:u,default:function(){return[]}},dataKey:{type:String,default:"id"},childrenKey:{type:String,default:"child"},labelKey:{type:String,default:"name"},indent:{type:Number,default:18}},setup:function(s,a){return Object(t["B"])("treeCtx",Object(t["D"])({props:s,ctx:a})),{}},components:{ShutBWrapper:c["a"],ShutBTreeNode:w}});n("f38b");const _=g()(v,[["render",p],["__scopeId","data-v-1184d35a"]]);var O=_,C=function(s){s.component(O.name,O)};a["default"]={install:C}},"9eef":function(s,a,n){"use strict";n.r(a);var t=n("7a23"),l={class:"markdown-body"},e=Object(t["j"])('<html><head></head><body><h1>Git Cherry-Pick</h1><p>按照提交 id 将某提交或某段提交重现到当前分支</p><pre><code class="language-sh">git cherry-pick id\n\ngit cherry-pick id1..id2\ngit cherry-pick id1^..id2\n</code></pre><h2>参数<code>-x</code></h2><p>提交信息追加一段表明此提交从何处 cherry-pick</p><h2>参数<code>--sign-off</code></h2><p>提交信息追加一段表明操作人</p><h2>参数<code>-m --mainline</code></h2><p>处理 merge 提交</p></body></html>',1),p=[e];function c(s,a){return Object(t["z"])(),Object(t["h"])("section",l,p)}var o=n("6b0d"),r=n.n(o);const i={},h=r()(i,[["render",c]]);a["default"]=h},"9f28":function(s,a,n){"use strict";n.r(a);var t=n("7a23"),l={class:"markdown-body"},e=Object(t["j"])("<html><head></head><body><h1>样式继承</h1><h2>可继承的样式</h2><ol><li>font-size</li><li>font-family</li><li>color</li><li>text-indent</li></ol><h2>不可继承的样式</h2><ol><li>border</li><li>padding</li><li>margin</li><li>width</li><li>height</li></ol></body></html>",1),p=[e];function c(s,a){return Object(t["z"])(),Object(t["h"])("section",l,p)}var o=n("6b0d"),r=n.n(o);const i={},h=r()(i,[["render",c]]);a["default"]=h},a231:function(s,a,n){"use strict";n("a32b")},a23a:function(s,a,n){"use strict";n.r(a);var t=n("7a23"),l=n("fa12"),e=n.n(l),p={class:"markdown-body"},c=Object(t["j"])('<html><head></head><body><h1>JS 数据类型</h1><h2>Js 基本数据类型</h2><ol><li>boolean</li><li>null</li><li>undefined</li><li>number</li><li>string</li><li>bigint</li><li>Symbal</li></ol><p>此外还有引用型变量：如 Object、Function</p><h3>number</h3><p>JS 中的 number 采用 64 位浮点数的形式编码，因此会有小数精度丢失的问题。于是出现了经典的 <code>0.1 + 0.2 === 0.30000000000000004</code> 问题。</p><h4>解决精度丢失</h4><ol><li>NPM 上有许多支持 JavaScript 和 Node.js 的数学库，比如 math.js，decimal.js,D.js 等等。</li><li>toFixed()方法，将数据舍入到指定位数，不可靠，需要重写。</li><li>ES6 在 Number 对象上新增了一个极小的常量——Number.EPSILON。引入一个这么小的量，目的在于为浮点数计算设置一个误差范围，如果误差能够小于 Number.EPSILON，我们就可以认为结果是可靠的。</li></ol><h3>bigint</h3><p>用于弥补 number 导致的大整数精度下降问题，确切地说，JS 中的 Number 类型只能安全地表示-9007199254740991(-(2^53-1))和 9007199254740991（(2^53-1)），任何超出此范围的整数值都可能失去精度。</p><pre><code class="language-js"><span class="hljs-number">10n</span> + <span class="hljs-number">20n</span>; <span class="hljs-comment">// → 30n</span>\n<span class="hljs-number">10n</span> - <span class="hljs-number">20n</span>; <span class="hljs-comment">// → -10n</span>\n+<span class="hljs-number">10n</span>; <span class="hljs-comment">// → TypeError: Cannot convert a BigInt value to a number</span>\n-<span class="hljs-number">10n</span>; <span class="hljs-comment">// → -10n</span>\n<span class="hljs-number">10n</span> * <span class="hljs-number">20n</span>; <span class="hljs-comment">// → 200n</span>\n<span class="hljs-number">20n</span> / <span class="hljs-number">10n</span>; <span class="hljs-comment">// → 2n</span>\n<span class="hljs-number">23n</span> % <span class="hljs-number">10n</span>; <span class="hljs-comment">// → 3n</span>\n<span class="hljs-number">10n</span> ** <span class="hljs-number">3n</span>; <span class="hljs-comment">// → 1000n</span>\n\n<span class="hljs-keyword">const</span> x = <span class="hljs-number">10n</span>;\n++x; <span class="hljs-comment">// → 11n</span>\n--x; <span class="hljs-comment">// → 9n</span>\n<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> x); <span class="hljs-comment">//&quot;bigint&quot;</span>\n</code></pre><h4>bigint 一些问题</h4><ol><li>BigInt 不支持一元加号运算符, 这可能是某些程序可能依赖于 + 始终生成 Number 的不变量，或者抛出异常。另外，更改 + 的行为也会破坏 asm.js 代码。</li><li>因为隐式类型转换可能丢失信息，所以不允许在 bigint 和 Number 之间进行混合操作。当混合使用大整数和浮点数时，结果值可能无法由 BigInt 或 Number 精确表示。</li><li>不能将 BigInt 传递给 Web api 和内置的 JS 函数，这些函数需要一个 Number 类型的数字。尝试这样做会报 TypeError 错误。</li><li>当 Boolean 类型与 BigInt 类型相遇时，BigInt 的处理方式与 Number 类似，换句话说，只要不是 0n，BigInt 就被视为 truthy 的值。</li><li>元素都为 BigInt 的数组可以进行 sort。</li><li>BigInt 可以正常地进行位运算，如|、&amp;、&lt;&lt;、&gt;&gt;和^</li></ol><h4>bigint 适用范围</h4><p>目前只有 chrome67、firefox、Opera 这些主流实现，要正式成为规范，其实还有很长的路要走。</p><h2>JS 数据类型检测</h2><h3>typeof</h3><p>对于原始类型来说，除了 null 为&quot;object&quot;都可以调用 typeof 显示正确的类型。</p><pre><code class="language-js"><span class="hljs-keyword">typeof</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// &#39;number&#39;</span>\n<span class="hljs-keyword">typeof</span> <span class="hljs-string">&#39;1&#39;</span>; <span class="hljs-comment">// &#39;string&#39;</span>\n<span class="hljs-keyword">typeof</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// &#39;object&#39;</span>\n<span class="hljs-keyword">typeof</span> <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// &#39;undefined&#39;</span>\n<span class="hljs-keyword">typeof</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// &#39;boolean&#39;</span>\n<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Symbol</span>(); <span class="hljs-comment">// &#39;symbol&#39;</span>\n</code></pre><p>但对于引用数据类型，除了函数&quot;function&quot;之外，都会显示&quot;object&quot;。</p><pre><code class="language-js"><span class="hljs-keyword">typeof</span> []; <span class="hljs-comment">// &#39;object&#39;</span>\n<span class="hljs-keyword">typeof</span> {}; <span class="hljs-comment">// &#39;object&#39;</span>\n<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">console</span>.log; <span class="hljs-comment">// &#39;function&#39;</span>\n</code></pre><h3>instanceof</h3><p>基于原型链检查，只要原型链上有即为 true。</p><h4>通过 instanceof 判断基本类型</h4><p>自定义 Symbal.hasInstance 方法：</p><pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrimitiveNumber</span> </span>{\n\t<span class="hljs-keyword">static</span> [<span class="hljs-built_in">Symbol</span>.hasInstance](x) {\n\t\t<span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#39;number&#39;</span>;\n\t}\n}\n<span class="hljs-built_in">console</span>.log(<span class="hljs-number">111</span> <span class="hljs-keyword">instanceof</span> PrimitiveNumber); <span class="hljs-comment">// true</span>\n</code></pre><p>手动实现 instanceof 的功能，逐步向上查找直至找到或者到顶（null）</p><pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myInstanceof</span>(<span class="hljs-params">left, right</span>) </span>{\n\t<span class="hljs-comment">//基本数据类型直接返回false</span>\n\t<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> left !== <span class="hljs-string">&#39;object&#39;</span> || left === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;\n\t<span class="hljs-comment">//getProtypeOf是Object对象自带的一个方法，能够拿到参数的原型对象</span>\n\t<span class="hljs-keyword">let</span> proto = <span class="hljs-built_in">Object</span>.getPrototypeOf(left);\n\t<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {\n\t\t<span class="hljs-comment">//查找到尽头，还没找到</span>\n\t\t<span class="hljs-keyword">if</span> (proto == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;\n\t\t<span class="hljs-comment">//找到相同的原型对象</span>\n\t\t<span class="hljs-keyword">if</span> (proto == right.prototype) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;\n\t\tproto = <span class="hljs-built_in">Object</span>.getPrototypeof(proto);\n\t}\n}\n</code></pre><h2>数据类型转换</h2><p>JS 数据类型转换分三种：</p><ol><li>转换成数字</li><li>转换成布尔值</li><li>转换成字符串</li></ol><p><img src="'+e.a+'" alt="JS类型转换"></p><p><a href="https://juejin.im/post/5dac5d82e51d45249850cd20#heading-1">参考图源</a></p><h3><code>&#39;==&#39;</code>与<code>&#39;===&#39;</code></h3><p>===叫做严格相等，是指：左右两边不仅值要相等，类型也要相等，例如&#39;1&#39;===1 的结果是 false，因为一边是 string，另一边是 number。</p><p>==不像===那样严格，对于一般情况，只要值相等，就返回 true，但==还涉及一些类型转换，它的转换规则如下：</p><ul><li>两边的类型是否相同，相同的话就比较值的大小，例如 1==2，返回 false</li><li>判断的是否是 null 和 undefined，是的话就返回 true</li><li>判断的类型是否是 String 和 Number，是的话，把 String 类型转换成 Number，再进行比较</li><li>判断其中一方是否是 Boolean，是的话就把 Boolean 转换成 Number，再进行比较</li><li>如果其中一方为 Object，且另一方为 String、Number 或者 Symbol，会将 Object 转换成字符串，再进行比较</li></ul><h3>对象转原始类型是根据什么流程运行的？</h3><p>象转原始类型，会调用内置的<code>[ToPrimitive]</code>函数，对于该函数而言，其逻辑如下：</p><ol><li>如果<code>Symbol.toPrimitive()</code>方法，优先调用再返回</li><li>调用<code>valueOf()</code>，如果转换为原始类型，则返回</li><li>调用<code>toString()</code>，如果转换为原始类型，则返回</li><li>如果都没有返回原始类型，会报错</li></ol><pre><code class="language-js"><span class="hljs-keyword">var</span> obj = {\n\t<span class="hljs-attr">value</span>: <span class="hljs-number">3</span>,\n\t<span class="hljs-function"><span class="hljs-title">valueOf</span>(<span class="hljs-params"></span>)</span> {\n\t\t<span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;\n\t},\n\t<span class="hljs-function"><span class="hljs-title">toString</span>(<span class="hljs-params"></span>)</span> {\n\t\t<span class="hljs-keyword">return</span> <span class="hljs-string">&#39;5&#39;</span>;\n\t},\n\t[<span class="hljs-built_in">Symbol</span>.toPrimitive]() {\n\t\t<span class="hljs-keyword">return</span> <span class="hljs-number">6</span>;\n\t},\n};\n<span class="hljs-built_in">console</span>.log(obj + <span class="hljs-number">1</span>); <span class="hljs-comment">// 输出7</span>\n</code></pre></body></html>',1),o=[c];function r(s,a){return Object(t["z"])(),Object(t["h"])("section",p,o)}var i=n("6b0d"),h=n.n(i);const d={},j=h()(d,[["render",r]]);a["default"]=j},a32b:function(s,a,n){},a350:function(s,a,n){"use strict";n.r(a);var t=n("7a23"),l={class:"markdown-body"},e=Object(t["j"])("<html><head></head><body><h1>Vuex 实现单向流动的原理</h1><h2>Vue2.0</h2><p>Vuex 实例上有个<code>_vm</code>属性，是一个 new Vue 实例，<code>mutations</code> 对其相应式数据进行修改。</p><h2>Vue3.0</h2><p>引入了 vue 3 的 <code>reactive, watch</code> 实现响应式监听，<code>mutations</code> 对其相应式数据进行修改。</p><h2>直接修改 state</h2><p>Vuex 由于是借助 Vue 实现了数据响应，因此其实是可以直接修改 state 来修改数据，功能依旧正常。 <strong>但是若创建 store 开启严格模式，Vuex 会通过 watch deep 来发出警告</strong></p></body></html>",1),p=[e];function c(s,a){return Object(t["z"])(),Object(t["h"])("section",l,p)}var o=n("6b0d"),r=n.n(o);const i={},h=r()(i,[["render",c]]);a["default"]=h},a3da:function(s,a,n){"use strict";n.r(a);var t=n("7a23"),l={class:"markdown-body"},e=Object(t["j"])("<html><head></head><body><h1>$store 如何实现全局查找</h1><p>Vuex 的 install 过程中，<code>通过Vue.mixin</code>对所有组件注入一个<code>beforeCreate</code>钩子。该钩子上对 Vue 对$store 属性进行初始化。</p><p><code>组件自身不含$options.store的话</code>，其$store 将会指向其<code>$parent.$store</code>。逐层向上直到<code>$root</code>，因此在 new Vue()的时候对根节点放入<code>$options.store</code>即可使得所有组件使用全局状态</p><p><strong>若通过 Vue.extend 创建新的组件，该组件树独立，因此这部分属性需要专门处理</strong></p></body></html>",1),p=[e];function c(s,a){return Object(t["z"])(),Object(t["h"])("section",l,p)}var o=n("6b0d"),r=n.n(o);const i={},h=r()(i,[["render",c]]);a["default"]=h},a468:function(s,a,n){"use strict";n.r(a);var t=n("7a23"),l={class:"markdown-body"},e=Object(t["j"])('<html><head></head><body><h1>数据、存取描述符</h1><h2>JS 的描述符如下：</h2><ul><li>enumerable：描述该属性是否可枚举，不可枚举的属性不会被<code>for...in</code>及<code>Object.keys</code>获取，但该描述符会被<code>Object.getOwnPropertyNames</code>无视。初步定义默认为 false。</li><li>configurable：描述该属性的描述符能否再次修改，若为 false 再次修改会报<code>TypeError</code>，同时该属性也不可被删除（<strong>delete 返回 false，删除失败，不报错</strong>），默认为 false。</li></ul><h3>数据描述符特有：</h3><ul><li>value：属性值，默认 undefined。</li><li>writable：是否可写，为 true 时才能被赋值表达式改变（<strong>为 false 不会影响赋值表达式左值，也不会报错</strong>），默认 false</li></ul><h3>存取描述符特有：</h3><ul><li>get：无参函数，返回值即为属性值</li><li>set：接收新值作为参数的函数</li></ul><p>若我们直接对对象对属性进行赋值，相当于设置了 value 以及 writable，enumerable，configurable：true</p><pre><code class="language-js"><span class="hljs-keyword">var</span> dd = { <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> };\ndd.a = <span class="hljs-number">1</span>;\n<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors(dd));\n<span class="hljs-comment">// {</span>\n<span class="hljs-comment">//   b: { value: 2, writable: true, enumerable: true, configurable: true },</span>\n<span class="hljs-comment">//   a: { value: 1, writable: true, enumerable: true, configurable: true }</span>\n<span class="hljs-comment">// }</span>\n</code></pre><h2>Object.defineProperty</h2><p>接收三个参数对某一个属性进行描述符定义</p><ul><li>obj，目标对象，必须为引用值，否则报错。</li><li>prop，属性名，可为任意 JS 值，<code>调用toString()后</code>作为属性名。</li><li>descriptor，必须为引用值。<strong>获取其上的属性时会往原型链查找</strong>。若六个属性皆无则默认数据描述符。</li></ul><h3>Object.defineProperties</h3><p>接收两个参数，obj 与<code>prop 与 descriptor 字典</code>。</p></body></html>',1),p=[e];function c(s,a){return Object(t["z"])(),Object(t["h"])("section",l,p)}var o=n("6b0d"),r=n.n(o);const i={},h=r()(i,[["render",c]]);a["default"]=h},a603:function(s,a,n){"use strict";n("0152")},a60b:function(s,a,n){"use strict";n("6c37")},acbc:function(s,a,n){s.exports=n.p+"img/AzureToken.dc02d1be.png"},aeb8:function(s,a,n){"use strict";n.r(a);var t=n("7a23"),l={class:"markdown-body"},e=Object(t["j"])('<html><head></head><body><h1>防抖和节流</h1><h2>防抖</h2><p>触发高频事件后 n 秒内函数只会执行一次，如果 n 秒内高频事件再次被触发，则重新计算时间。</p><p>手段：每次触发事件时都取消之前的延时调用方法。</p><pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">fn, delay, ...args</span>) </span>{\n\t<span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;\n\t<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...rest</span>) </span>{\n\t\t<span class="hljs-built_in">clearTimeout</span>(timer); <span class="hljs-comment">//清除之前的计时器</span>\n\t\ttimer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {\n\t\t\t<span class="hljs-comment">//重新计时</span>\n\t\t\tfn.call(<span class="hljs-built_in">this</span>, ...args, ...rest);\n\t\t}, delay);\n\t};\n}\n</code></pre><h2>节流</h2><p>高频事件触发，但在 n 秒内只会执行一次，所以节流会稀释函数的执行频率。</p><p>手段：每次触发事件时都判断当前是否有等待执行的延时函数。</p><pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">fn, delay, ...args</span>) </span>{\n\t<span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;\n\t<span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">...rest</span>) =&gt;</span> {\n\t\t<span class="hljs-keyword">if</span> (!timer) {\n\t\t\t<span class="hljs-comment">//判断是否有计时器</span>\n\t\t\ttimer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {\n\t\t\t\tfn.call(<span class="hljs-built_in">this</span>, ...args, ...rest);\n\t\t\t\t<span class="hljs-built_in">clearTimeout</span>(timer);\n\t\t\t\ttimer = <span class="hljs-literal">null</span>;\n\t\t\t}, delay);\n\t\t}\n\t};\n}\n</code></pre></body></html>',1),p=[e];function c(s,a){return Object(t["z"])(),Object(t["h"])("section",l,p)}var o=n("6b0d"),r=n.n(o);const i={},h=r()(i,[["render",c]]);a["default"]=h},b014:function(s,a,n){s.exports=n.p+"img/async与defer.db947bad.png"},b148:function(s,a,n){"use strict";n.r(a),n.d(a,"install",(function(){return l}));n("b0c0");var t=n("db95"),l=function(s){s.component(t["a"].name,t["a"])};a["default"]={install:l}},b14d:function(s,a,n){"use strict";n.r(a);var t=n("7a23"),l={class:"markdown-body"},e=Object(t["j"])('<html><head></head><body><h1>react Hook</h1><p>通过 Hook，可以在函数组件中完成原本只能在 class 组件中才能完成的操作，比如 state 和生命周期的操作（也叫副作用）。</p><h2>state Hook</h2><pre><code class="language-js"><span class="hljs-keyword">import</span> React, { useState } <span class="hljs-keyword">from</span> <span class="hljs-string">&#39;react&#39;</span>;\n\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Example</span>(<span class="hljs-params"></span>) </span>{\n  <span class="hljs-comment">// 声明一个叫 &quot;count&quot; 的 state 变量</span>\n  <span class="hljs-keyword">const</span> [count, setCount] = useState(<span class="hljs-number">0</span>);\n\n  <span class="hljs-keyword">return</span> (\n      <span class="hljs-comment">//</span>\n  )\n}\n</code></pre><p><code>useState</code>的返回值为 state 属性以及其 setter 函数。由于该函数可多次调用，因此我们可以获得多个响应式变量以及其对应的 setter。</p><h3>state Hook 的函数式更新</h3><p><code>如果新的 state 需要通过使用先前的 state 计算得出</code>，那么可以将函数传递给 setState。该函数将接收先前的 state，并返回一个更新后的值。</p><pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Counter</span>(<span class="hljs-params">{ initialCount }</span>) </span>{\n\t<span class="hljs-keyword">const</span> [count, setCount] = useState(initialCount);\n\t<span class="hljs-keyword">return</span> (\n\t\t<span class="xml"><span class="hljs-tag">&lt;&gt;</span>\n\t\t\tCount: {count}\n\t\t\t<span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setCount(initialCount)}&gt;Reset<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n\t\t\t<span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setCount(prevCount =&gt; prevCount - 1)}&gt;-<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n\t\t\t<span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setCount(prevCount =&gt; prevCount + 1)}&gt;+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n\t\t<span class="hljs-tag">&lt;/&gt;</span></span>\n\t);\n}\n</code></pre><h2>effect Hook</h2><p>Effect Hook 可以让你在函数组件中执行副作用操作。</p><pre><code class="language-js"><span class="hljs-keyword">import</span> React, { useState, useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">&#39;react&#39;</span>;\n\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Example</span>(<span class="hljs-params"></span>) </span>{\n\t<span class="hljs-keyword">const</span> [count, setCount] = useState(<span class="hljs-number">0</span>);\n\n\t<span class="hljs-comment">// Similar to componentDidMount and componentDidUpdate:</span>\n\tuseEffect(<span class="hljs-function">() =&gt;</span> {\n\t\t<span class="hljs-comment">// Update the document title using the browser API</span>\n\t\t<span class="hljs-built_in">document</span>.title = <span class="hljs-string">`You clicked <span class="hljs-subst">${count}</span> times`</span>;\n\t\t<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cleanup</span>(<span class="hljs-params"></span>) </span>{\n\t\t\tChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);\n\t\t};\n\t});\n\n\t<span class="hljs-keyword">return</span> (\n\t\t<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n\t\t\t<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>You clicked {count} times<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>\n\t\t\t<span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setCount(count + 1)}&gt;Click me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n\t\t<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n\t);\n}\n</code></pre><p><code>useEffect</code>的效果相当于<code>componentDidMount</code>，<code>componentDidUpdate</code> 和<code>componentWillUnmount</code> 这三个函数的组合。</p><p>useEffect 的返回值为一个函数。React 会在组件卸载的时候执行清除操作。<code>而effect在每次渲染的时候都会执行。</code></p><p>在一个组件内可以多次声明，实际执行会按照声明顺序执行，仅有助于逻辑上理解。</p><pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">FriendStatus</span>(<span class="hljs-params">props</span>) </span>{\n  <span class="hljs-comment">// ...</span>\n  useEffect(<span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-comment">// ...</span>\n    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);\n    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {\n      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);\n    };\n  });\n\n</code></pre><p>以上代码实际执行效果将为：</p><pre><code class="language-js"><span class="hljs-comment">// Mount with { friend: { id: 100 } } props</span>\nChatAPI.subscribeToFriendStatus(<span class="hljs-number">100</span>, handleStatusChange); <span class="hljs-comment">// 运行第一个 effect</span>\n\n<span class="hljs-comment">// Update with { friend: { id: 200 } } props</span>\nChatAPI.unsubscribeFromFriendStatus(<span class="hljs-number">100</span>, handleStatusChange); <span class="hljs-comment">// 清除上一个 effect</span>\nChatAPI.subscribeToFriendStatus(<span class="hljs-number">200</span>, handleStatusChange); <span class="hljs-comment">// 运行下一个 effect</span>\n\n<span class="hljs-comment">// Update with { friend: { id: 300 } } props</span>\nChatAPI.unsubscribeFromFriendStatus(<span class="hljs-number">200</span>, handleStatusChange); <span class="hljs-comment">// 清除上一个 effect</span>\nChatAPI.subscribeToFriendStatus(<span class="hljs-number">300</span>, handleStatusChange); <span class="hljs-comment">// 运行下一个 effect</span>\n\n<span class="hljs-comment">// Unmount</span>\nChatAPI.unsubscribeFromFriendStatus(<span class="hljs-number">300</span>, handleStatusChange); <span class="hljs-comment">// 清除最后一个 effect</span>\n</code></pre><p>这样将生命周期函数的效果进行合并，优点为调用更加简洁，因为大多数时候我们都需要在页面渲染完成时做一些事情。但是在有的时候难以满足需求，或者会带来性能问题。</p><p>这时可以通过跳过 effect 来解决。</p><h3>为 effect Hook 设置依赖</h3><pre><code class="language-js"><span class="hljs-comment">// class组件中的解决方法：prevProps, prevState</span>\n<span class="hljs-function"><span class="hljs-title">componentDidUpdate</span>(<span class="hljs-params">prevProps, prevState</span>)</span> {\n  <span class="hljs-keyword">if</span> (prevState.count !== <span class="hljs-built_in">this</span>.state.count) {\n    <span class="hljs-built_in">document</span>.title = <span class="hljs-string">`You clicked <span class="hljs-subst">${<span class="hljs-built_in">this</span>.state.count}</span> times`</span>;\n  }\n}\n</code></pre><p>这是很常见的需求，所以它被内置到了 useEffect 的 Hook API 中。如果某些特定值在两次重渲染之间没有发生变化，你可以通知 React 跳过对 effect 的调用，只要传递数组作为 useEffect 的第二个可选参数即可：</p><pre><code class="language-js">useEffect(<span class="hljs-function">() =&gt;</span> {\n\t<span class="hljs-built_in">document</span>.title = <span class="hljs-string">`You clicked <span class="hljs-subst">${count}</span> times`</span>;\n}, [count]); <span class="hljs-comment">// 仅在 count 更改时更新</span>\n</code></pre><p>如果传入的数组依赖频繁发生变化，可能导致 bug：</p><pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Counter</span>(<span class="hljs-params"></span>) </span>{\n\t<span class="hljs-keyword">const</span> [count, setCount] = useState(<span class="hljs-number">0</span>);\n\n\tuseEffect(<span class="hljs-function">() =&gt;</span> {\n\t\t<span class="hljs-keyword">const</span> id = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {\n\t\t\tsetCount(count + <span class="hljs-number">1</span>); <span class="hljs-comment">// 这个 effect 依赖于 `count` state</span>\n\t\t}, <span class="hljs-number">1000</span>);\n\t\t<span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">clearInterval</span>(id);\n\t}, []); <span class="hljs-comment">// 🔴 Bug: `count` 没有被指定为依赖</span>\n\n\t<span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>{count}<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;\n}\n</code></pre><p>传入空的依赖数组 []，意味着该 hook 只在组件挂载时运行一次，并非重新渲染时。但如此会有问题，在 setInterval 的回调中，count 的值不会发生变化。<code>因为当 effect 执行时，会创建一个闭包，并将 count 的值被保存在该闭包当中</code>，且初值为 0。每隔一秒，回调就会执行 setCount(0 + 1)，因此，count 永远不会超过 1。</p><p>解决方案：<a href="#state-hook%e7%9a%84%e5%87%bd%e6%95%b0%e5%bc%8f%e6%9b%b4%e6%96%b0">函数式更新</a></p><pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Counter</span>(<span class="hljs-params"></span>) </span>{\n\t<span class="hljs-keyword">const</span> [count, setCount] = useState(<span class="hljs-number">0</span>);\n\n\tuseEffect(<span class="hljs-function">() =&gt;</span> {\n\t\t<span class="hljs-keyword">const</span> id = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {\n\t\t\tsetCount(<span class="hljs-function"><span class="hljs-params">c</span> =&gt;</span> c + <span class="hljs-number">1</span>); <span class="hljs-comment">// ✅ 在这不依赖于外部的 `count` 变量</span>\n\t\t}, <span class="hljs-number">1000</span>);\n\t\t<span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">clearInterval</span>(id);\n\t}, []); <span class="hljs-comment">// ✅ 我们的 effect 不适用组件作用域中的任何变量</span>\n\n\t<span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>{count}<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;\n}\n</code></pre><p>此时，setInterval 的回调依旧每秒调用一次，但每次 setCount 内部的回调取到的 count 是最新值（在回调中变量命名为 c）。</p></body></html>',1),p=[e];function c(s,a){return Object(t["z"])(),Object(t["h"])("section",l,p)}var o=n("6b0d"),r=n.n(o);const i={},h=r()(i,[["render",c]]);a["default"]=h},b244:function(s,a,n){s.exports=n.p+"img/浮动换行遇到反向margin.0b39e635.png"},b3c3:function(s,a,n){"use strict";n.r(a);var t=n("7a23"),l={class:"markdown-body"},e=Object(t["j"])('<html><head></head><body><h1>Vue 动态组件</h1><p>一般引入 Vue 组件的话，通过 component 直接引入</p><pre><code class="language-js">components: {\n\tMyComp,\n}\n</code></pre><p>该引入方式 components 的属性会是一个 Vue 组件的所有 Options 配置。<code>若为单文件组件，模板部分会被loader编译为render函数</code>。</p><p>要改为动态组件引入的话，需要用到<code>import函数</code>。</p><h2>import()</h2><p>是对 ES6 中的模块化补完，用于支持执行时导入。接收参数为模块地址（同 import 语句），<code>返回值为对应模块的Promise</code>。</p><p>Vue 动态组件即将原本 component 接收的 options 配置改为一个返回 Promise&lt;Options&gt;的函数。</p><pre><code class="language-js">components: {\n\t<span class="hljs-attr">MyComp</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#39;path/to/module&#39;</span>),\n}\n</code></pre><p>通过此方式引入的组件在页面渲染时不会直接与主 JS 文件一同返回，而是到该组件将要渲染时单独请求一个新的 JS 文件。</p><h2>webpackChunkName</h2><p>用于自定义 JS 文件名字的特殊注释。若多个组件用同一个 chunkName，他们会被打包为同一个 JS 文件。</p><pre><code class="language-js">components: {\n\t<span class="hljs-attr">MyComp</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-comment">/* webpackChunkName: &quot;my_chunk&quot; */</span> <span class="hljs-string">&#39;path/to/module&#39;</span>),\n}\n</code></pre></body></html>',1),p=[e];function c(s,a){return Object(t["z"])(),Object(t["h"])("section",l,p)}var o=n("6b0d"),r=n.n(o);const i={},h=r()(i,[["render",c]]);a["default"]=h},b905:function(s,a,n){"use strict";n.r(a);var t=n("7a23"),l={class:"markdown-body"},e=Object(t["j"])('<html><head></head><body><h1>create-react-app 配置</h1><h2>自定义配置</h2><pre><code class="language-sh">yarn add -D react-app-rewired customize-cra\n</code></pre><p>通过<code>config.overrides.js</code>返回 override 函数（<code>customize-cra</code>包中的）执行结果，覆盖 webpack 默认配置。</p><h2>ts 下添加别名。</h2><p>ts 模式下的 cra 启动时会复写 tsconfig.json 的配置，别名配置 baseUrl 和 paths 会被删除，即使通过 extends 写到别的文件也会报错。</p><p><code>config.overrides.js</code>中 override 加一个<code>addWebpackAlias</code>提供别名的映射关系</p><pre><code class="language-sh">yarn add -D craco-alias\n</code></pre><p>根据该包的功能修复启动时 paths 报错导致无法构建的问题</p></body></html>',1),p=[e];function c(s,a){return Object(t["z"])(),Object(t["h"])("section",l,p)}var o=n("6b0d"),r=n.n(o);const i={},h=r()(i,[["render",c]]);a["default"]=h},b973:function(s,a,n){"use strict";n.r(a);var t=n("7a23"),l={class:"markdown-body"},e=Object(t["j"])('<html><head></head><body><h1>Python 函数装饰器</h1><p>用于修改函数效果的装饰性函数，特点是将要使用或修改的函数作为参数。</p><pre><code class="language-py"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decorator</span>(<span class="hljs-params">handler</span>):</span>\n\n    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">newFunction</span>():</span>\n        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#39;do something before handler&#39;</span>)\n        handler()\n        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#39;do something after handler&#39;</span>)\n\n    <span class="hljs-keyword">return</span> newFunction\n\n@decorator\n<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">oldFunction</span>():</span>\n    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#39;old function&#39;</span>)\n\noldFunction()\n\n<span class="hljs-string">&#39;&#39;&#39;输出\ndo something before handler\nold function\ndo something after handler\n&#39;&#39;&#39;</span>\n</code></pre><p>函数装饰器常见于各种中间件以及代理模式编程思想中，通过对原函数的封装和修改，能实现想要的结果，同时又可以保留对旧函数名的引用以及旧函数的效果。</p><h2>问题</h2><pre><code class="language-py"><span class="hljs-comment"># 上例中的装饰器</span>\n<span class="hljs-built_in">print</span>(oldFunction.__name__)\n\n<span class="hljs-comment">#输出：newFunction</span>\n</code></pre><p>由于返回的新函数覆盖了旧函数的内容，同时也会覆盖函数名和说明文档。</p><h2>解决方法：functools.wraps</h2><pre><code class="language-py"><span class="hljs-comment"># 将装饰器的定义修改为如下</span>\n<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decorator</span>(<span class="hljs-params">handler</span>):</span>\n\n    @wraps(handler)\n    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">newFunction</span>():</span>\n        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#39;do something before handler&#39;</span>)\n        handler()\n        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#39;do something after handler&#39;</span>)\n\n    <span class="hljs-keyword">return</span> newFunction\n</code></pre><h2>带参数的装饰器</h2><p>通过增加包裹函数</p><pre><code class="language-py"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> wraps\n\n<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decorator</span>(<span class="hljs-params">para=<span class="hljs-string">&quot;para&quot;</span></span>):</span>\n    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decorator_inner</span>(<span class="hljs-params">handler</span>):</span>\n\n        @wraps(handler)\n        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">newFunction</span>():</span>\n            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#39;do something before handler&#39;</span>, para)\n            handler()\n            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#39;do something after handler&#39;</span>)\n\n        <span class="hljs-keyword">return</span> newFunction\n    <span class="hljs-keyword">return</span> decorator_inner\n\n@decorator(para=<span class="hljs-string">&quot;aaaa&quot;</span>)\n<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">oldFunction</span>():</span>\n    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#39;old function&#39;</span>)\n\noldFunction()\n\n<span class="hljs-string">&#39;&#39;&#39;输出\ndo something before handler aaaa\nold function\ndo something after handler\n&#39;&#39;&#39;</span>\n</code></pre><p>在通过<code>@</code>符号语法糖使用装饰器时，只需要在结尾加上小括号，将包裹函数的执行结果（也就是真正的装饰器）即可。</p><h2>装饰器类</h2><p>通过类构建装饰器，即通过类的<code>__call__</code>函数来实现装饰器，通过<code>__init__</code>实现传参，优点是可继承。</p><pre><code class="language-py"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> wraps\n\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">decorator</span>:</span>\n    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, para=<span class="hljs-string">&quot;para&quot;</span></span>):</span>\n        self.para = para\n\n    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__call__</span>(<span class="hljs-params">self, handler</span>):</span>\n        @wraps(handler)\n        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">newFunction</span>():</span>\n            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#39;do something before handler&#39;</span>, self.para)\n            handler()\n            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#39;do something after handler&#39;</span>)\n\n        <span class="hljs-keyword">return</span> newFunction\n\n@decorator(para=<span class="hljs-string">&quot;aaaaaa&quot;</span>)\n<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">oldFunction</span>():</span>\n    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#39;old function&#39;</span>)\n\noldFunction()\n\n<span class="hljs-string">&#39;&#39;&#39;\ndo something before handler aaaaaa\nold function\ndo something after handler\n&#39;&#39;&#39;</span>\n</code></pre></body></html>',1),p=[e];function c(s,a){return Object(t["z"])(),Object(t["h"])("section",l,p)}var o=n("6b0d"),r=n.n(o);const i={},h=r()(i,[["render",c]]);a["default"]=h},bc01:function(s,a,n){"use strict";n.r(a);var t=n("7a23"),l={class:"markdown-body"},e=Object(t["j"])('<html><head></head><body><h1>CSS3 动画相关</h1><h2>transform 变换</h2><p>用来向元素应用各种 2D 和 3D 转换，该属性允许我们对元素进行旋转、缩放、移动或倾斜等操作。</p><p>transform 会用到的方法：</p><ol><li>none: 定义不进行转换。</li><li>matrix(n,n,n,n,n,n): 定义 2D 转换，使用六个值的矩阵。</li><li>matrix3d(n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n): 定义 3D 转换，使用 16 个值的 4x4 矩阵。</li><li>translate(x,y): 定义 2D 位移转换。</li><li>translate3d(x,y,z): 定义 3D 位移转换。</li><li>translateX(x): 定义位移转换，只是用 X 轴的值。</li><li>translateY(y): 定义位移转换，只是用 Y 轴的值。</li><li>translateZ(z): 定义 3D 位移转换，只是用 Z 轴的值。</li><li>scale(x,y): 定义 2D 缩放转换。</li><li>scale3d(x,y,z): 定义 3D 缩放转换。</li><li>scaleX(x): 通过设置 X 轴的值来定义缩放转换。</li><li>scaleY(y): 通过设置 Y 轴的值来定义缩放转换。</li><li>scaleZ(z): 通过设置 Z 轴的值来定义 3D 缩放转换。</li><li>rotate(angle): 定义 2D 旋转，在参数中规定角度。</li><li>rotate3d(x,y,z,angle): 定义 3D 旋转。</li><li>rotateX(angle): 定义沿着 X 轴的 3D 旋转。</li><li>rotateY(angle): 定义沿着 Y 轴的 3D 旋转。</li><li>rotateZ(angle): 定义沿着 Z 轴的 3D 旋转。</li><li>skew(x-angle,y-angle): 定义沿着 X 和 Y 轴的 2D 倾斜转换。</li><li>skewX(angle): 定义沿着 X 轴的 2D 倾斜转换。</li><li>skewY(angle): 定义沿着 Y 轴的 2D 倾斜转换。</li><li>perspective(n): 为 3D 转换元素定义透视视图。</li></ol><ul><li>Internet Explorer 10、Firefox、Opera 支持 transform 属性。</li><li>Internet Explorer 9 支持替代的 -ms-transform 属性（仅适用于 2D 转换）。</li><li>Safari 和 Chrome 支持替代的 -webkit-transform 属性（3D 和 2D 转换）。</li><li>Opera 只支持 2D 转换。</li></ul><h2>transition 过渡动画</h2><p>该特性分四个属性：</p><ol><li>transition-property: 规定应用过渡的 CSS 属性的名称。</li><li>transition-duration: 规定完成过渡效果需要多长时间。</li><li>transition-timing-function: 规定过渡效果的时间曲线，默认是”<code>ease</code>”，还有<code>linear</code>、<code>ease-in</code>、<code>ease-out</code>、<code>ease-in-out</code>和<code>cubic-bezier</code>等过渡类型。</li><li>transition-delay: 规定过渡效果何时开始，默认是 0。</li></ol><p>或者说简写属性如<code>&#39;transition: all 0.3s ease-in-out 0s&#39;</code>。</p><h2>animation 动画</h2><p>通过设定<code>keyframes</code>关键帧来设定一段动画开始到结尾的效果。</p><p>animation 为一个简写属性，对应的属性有六个：</p><ol><li>animation-name：动画的名字，即 keyframes 的名字</li><li>animation-duration：动画持续时间</li><li>animation-timing-function：规定过渡效果的时间曲线，默认是”ease”，还有 linear、ease-in、ease-out、ease-in-out 和 cubic-bezier 等过渡类型。</li><li>animation-delay：规定过渡效果何时开始，默认是 0。</li><li>animation-iteration-count：规定动画应该播放的次数，值可以为次数<code>n</code>或<code>infinite</code>。</li><li>animation-direction：规定是否应该轮流反向播放动画，<code>normal</code>代表正常播放，<code>alternate</code>代表来回播放。</li></ol><p>简写属性 animation，如<code>&#39;animation: MyAnimation 1.5s ease-in-out 0s infinite alternate;&#39;</code>。</p><h3>keyframes 关键帧</h3><p>例子：<code>from</code>和<code>to</code>分别对应<code>0%</code>和<code>100%</code></p><pre><code class="language-css">@keyframes MyAnimation {\n\t<span class="hljs-selector-tag">from</span> {\n\t\t<span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;\n\t}\n\t<span class="hljs-number">33%</span> {\n\t\t<span class="hljs-attribute">height</span>: <span class="hljs-number">250px</span>;\n\t}\n\t<span class="hljs-number">50%</span> {\n\t\t<span class="hljs-attribute">height</span>: <span class="hljs-number">275px</span>;\n\t}\n\t<span class="hljs-selector-tag">to</span> {\n\t\t<span class="hljs-attribute">height</span>: <span class="hljs-number">150px</span>;\n\t}\n}\n</code></pre></body></html>',1),p=[e];function c(s,a){return Object(t["z"])(),Object(t["h"])("section",l,p)}var o=n("6b0d"),r=n.n(o);const i={},h=r()(i,[["render",c]]);a["default"]=h},c618:function(s,a,n){"use strict";n.r(a);var t=n("7a23"),l={class:"markdown-body"},e=Object(t["i"])("html",null,[Object(t["i"])("head"),Object(t["i"])("body",null,[Object(t["i"])("h1",null,"JS 模块实现"),Object(t["i"])("p",null,"通过实现代码来理解一些功能")])],-1),p=[e];function c(s,a){return Object(t["z"])(),Object(t["h"])("section",l,p)}var o=n("6b0d"),r=n.n(o);const i={},h=r()(i,[["render",c]]);a["default"]=h},c658:function(s,a,n){},cc48:function(s,a,n){"use strict";n.r(a);var t=n("7a23"),l={class:"markdown-body"},e=Object(t["j"])("<html><head></head><body><h1>对已经加载的模块进行一个批量的操作</h1><h2>为所有匹配的模块添加顶部注释</h2><p><code>webpack-parallel-uglify-plugin</code></p><h2>JS 代码压缩</h2><ul><li><code>uglifyjs-webpack-plugin</code> 较旧，缺点是单线程操作导致压缩过程很慢</li><li><code>webpack-parallel-uglify-plugin</code>，对第一条进行多线程优化，速度更快</li><li><code>terser-webpack-plugin</code>，同样高效。</li></ul><h2>构建速度优化</h2><p><code>DllPlugin</code>，<code>DllReferencePlugin</code></p></body></html>",1),p=[e];function c(s,a){return Object(t["z"])(),Object(t["h"])("section",l,p)}var o=n("6b0d"),r=n.n(o);const i={},h=r()(i,[["render",c]]);a["default"]=h},cd44:function(s,a,n){"use strict";n.r(a);var t=n("7a23"),l={class:"markdown-body"},e=Object(t["j"])('<html><head></head><body><h1>Python 面向对象</h1><h2>常用特殊属性与方法</h2><pre><code class="language-python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span>:</span>\n    __doc__ = <span class="hljs-string">&#39;&#39;</span><span class="hljs-comment">#说明性文档，声明类时通过三对引号引用的那部分</span>\n    __module__ = <span class="hljs-string">&#39;&#39;</span><span class="hljs-comment">#当前操作对象所属模块</span>\n    __class__ = <span class="hljs-string">&#39;&#39;</span><span class="hljs-comment">#当前对象所属类</span>\n    __dict__ = {}<span class="hljs-comment">#列出对象或类的所用成员</span>\n    __slots__ = (<span class="hljs-string">&#39;a&#39;</span>,<span class="hljs-string">&#39;b&#39;</span>)<span class="hljs-comment">#限制实例可以用的键值，即限制变量数</span>\n\n    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><span class="hljs-comment">#构造函数</span>\n        <span class="hljs-keyword">pass</span>\n    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__del__</span>(<span class="hljs-params">self</span>):</span><span class="hljs-comment">#析构函数</span>\n        <span class="hljs-keyword">pass</span>\n    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__len__</span>(<span class="hljs-params">self</span>):</span><span class="hljs-comment">#对应len()方法</span>\n        <span class="hljs-keyword">pass</span>\n    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__str__</span>(<span class="hljs-params">self</span>):</span><span class="hljs-comment">#对应类的字符串化（print等）</span>\n        <span class="hljs-keyword">pass</span>\n    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__cmp__</span>(<span class="hljs-params">self, s</span>):</span><span class="hljs-comment">#对应sort（sorted函数）行为</span>\n        <span class="hljs-keyword">pass</span>\n    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__iter__</span>(<span class="hljs-params">self</span>):</span><span class="hljs-comment">#与next一同使得对象变得可迭代</span>\n        <span class="hljs-keyword">pass</span>\n    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__next__</span>(<span class="hljs-params">self</span>):</span>\n        <span class="hljs-keyword">pass</span>\n    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__getitem__</span>(<span class="hljs-params">self,key</span>):</span><span class="hljs-comment">#获取对象变量触发</span>\n        <span class="hljs-keyword">pass</span>\n    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__setitem__</span>(<span class="hljs-params">self,key,value</span>):</span><span class="hljs-comment">#改变对象变量触发</span>\n        <span class="hljs-keyword">pass</span>\n    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__delitem__</span>(<span class="hljs-params">self,key</span>):</span><span class="hljs-comment">#删除对象变量触发</span>\n        <span class="hljs-keyword">pass</span>\n    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__add__</span>(<span class="hljs-params">self,s</span>):</span><span class="hljs-comment">#操作符重载</span>\n        <span class="hljs-keyword">pass</span>\n    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__sub__</span>(<span class="hljs-params">self,s</span>):</span>\n        <span class="hljs-keyword">pass</span>\n    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__mul__</span>(<span class="hljs-params">self,s</span>):</span>\n        <span class="hljs-keyword">pass</span>\n    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__truediv__</span>(<span class="hljs-params">self,s</span>):</span>\n        <span class="hljs-keyword">pass</span>\n    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__mod__</span>(<span class="hljs-params">self,s</span>):</span>\n        <span class="hljs-keyword">pass</span>\n    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__pow__</span>(<span class="hljs-params">self,s</span>):</span>\n        <span class="hljs-keyword">pass</span>\n    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__call__</span>(<span class="hljs-params">self, *args, **kwargs</span>):</span><span class="hljs-comment">#当类或对象被当做函数调用时（MyClass()(),myClass()）执行</span>\n        <span class="hljs-keyword">pass</span>\n</code></pre><h2>super(cls, self) (super() in Python3)</h2><p>作用为实例化一个父类</p><pre><code class="language-python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>:</span>\n    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span>\n        self.n = <span class="hljs-number">2</span>\n\n    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">self, m</span>):</span>\n        <span class="hljs-comment"># 第四步</span>\n        <span class="hljs-comment"># 来自 D.add 中的 super</span>\n        <span class="hljs-comment"># self == d, self.n == d.n == 5</span>\n        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#39;self is {0} @A.add&#39;</span>.<span class="hljs-built_in">format</span>(self))\n        self.n += m\n        <span class="hljs-comment"># d.n == 7</span>\n\n\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>(<span class="hljs-params">A</span>):</span>\n    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span>\n        self.n = <span class="hljs-number">3</span>\n\n    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">self, m</span>):</span>\n        <span class="hljs-comment"># 第二步</span>\n        <span class="hljs-comment"># 来自 D.add 中的 super</span>\n        <span class="hljs-comment"># self == d, self.n == d.n == 5</span>\n        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#39;self is {0} @B.add&#39;</span>.<span class="hljs-built_in">format</span>(self))\n        <span class="hljs-comment"># 等价于 suepr(B, self).add(m)</span>\n        <span class="hljs-comment"># self 的 MRO 是 [D, B, C, A, object]</span>\n        <span class="hljs-comment"># 从 B 之后的 [C, A, object] 中查找 add 方法</span>\n        <span class="hljs-built_in">super</span>().add(m)\n\n        <span class="hljs-comment"># 第六步</span>\n        <span class="hljs-comment"># d.n = 11</span>\n        self.n += <span class="hljs-number">3</span>\n        <span class="hljs-comment"># d.n = 14</span>\n\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span>(<span class="hljs-params">A</span>):</span>\n    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span>\n        self.n = <span class="hljs-number">4</span>\n\n    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">self, m</span>):</span>\n        <span class="hljs-comment"># 第三步</span>\n        <span class="hljs-comment"># 来自 B.add 中的 super</span>\n        <span class="hljs-comment"># self == d, self.n == d.n == 5</span>\n        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#39;self is {0} @C.add&#39;</span>.<span class="hljs-built_in">format</span>(self))\n        <span class="hljs-comment"># 等价于 suepr(C, self).add(m)</span>\n        <span class="hljs-comment"># self 的 MRO 是 [D, B, C, A, object]</span>\n        <span class="hljs-comment"># 从 C 之后的 [A, object] 中查找 add 方法</span>\n        <span class="hljs-built_in">super</span>().add(m)\n\n        <span class="hljs-comment"># 第五步</span>\n        <span class="hljs-comment"># d.n = 7</span>\n        self.n += <span class="hljs-number">4</span>\n        <span class="hljs-comment"># d.n = 11</span>\n\n\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span>(<span class="hljs-params">B, C</span>):</span>\n    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span>\n        self.n = <span class="hljs-number">5</span>\n\n    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">self, m</span>):</span>\n        <span class="hljs-comment"># 第一步</span>\n        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#39;self is {0} @D.add&#39;</span>.<span class="hljs-built_in">format</span>(self))\n        <span class="hljs-comment"># 等价于 super(D, self).add(m)</span>\n        <span class="hljs-comment"># self 的 MRO 是 [D, B, C, A, object]</span>\n        <span class="hljs-comment"># 从 D 之后的 [B, C, A, object] 中查找 add 方法</span>\n        <span class="hljs-built_in">super</span>().add(m)\n\n        <span class="hljs-comment"># 第七步</span>\n        <span class="hljs-comment"># d.n = 14</span>\n        self.n += <span class="hljs-number">5</span>\n        <span class="hljs-comment"># self.n = 19</span>\n\nd = D()\nd.add(<span class="hljs-number">2</span>)\n<span class="hljs-built_in">print</span>(d.n)\n</code></pre><p>输出结果：</p><pre><code>self is &lt;__main__.D object at 0x10ce10e48&gt; @D.add\nself is &lt;__main__.D object at 0x10ce10e48&gt; @B.add\nself is &lt;__main__.D object at 0x10ce10e48&gt; @C.add\nself is &lt;__main__.D object at 0x10ce10e48&gt; @A.add\n19\n</code></pre></body></html>',1),p=[e];function c(s,a){return Object(t["z"])(),Object(t["h"])("section",l,p)}var o=n("6b0d"),r=n.n(o);const i={},h=r()(i,[["render",c]]);a["default"]=h},cd49:function(s,a,n){"use strict";n.r(a);n("e260"),n("e6cf"),n("cca6"),n("a79d");var t=n("7a23");function l(s,a,n,l,e,p){var c=Object(t["H"])("page-frame");return Object(t["z"])(),Object(t["f"])(c)}function e(s,a,n,l,e,p){var c=Object(t["H"])("no-head-frame"),o=Object(t["H"])("default-frame");return s.isNoHead?(Object(t["z"])(),Object(t["f"])(c,{key:0,class:"frame"})):(Object(t["z"])(),Object(t["f"])(o,{key:1,class:"frame"}))}var p={class:"default-frame"};function c(s,a,n,l,e,c){var o=Object(t["H"])("Header"),r=Object(t["H"])("router-frame");return Object(t["z"])(),Object(t["h"])("div",p,[Object(t["l"])(o),Object(t["l"])(r,{class:"page-body"})])}var o=function(s){return Object(t["C"])("data-v-34dc105f"),s=s(),Object(t["A"])(),s},r={class:"page-header"},i=o((function(){return Object(t["i"])("div",{class:"title"},"瞎比比，小小实验室",-1)})),h=o((function(){return Object(t["i"])("a",{class:"link-group",target:"_blank",href:"https://github.com/czzczz/czzczz.github.io"}," Github ",-1)})),d=[i,h];function j(s,a,n,l,e,p){return Object(t["z"])(),Object(t["h"])("div",r,d)}var u={name:"PageHeader",setup:function(){return{}}},m=(n("3bdc"),n("6b0d")),b=n.n(m);const g=b()(u,[["render",j],["__scopeId","data-v-34dc105f"]]);var f=g;function y(s,a,n,l,e,p){var c=Object(t["H"])("router-view");return Object(t["z"])(),Object(t["f"])(c,null,{default:Object(t["Q"])((function(s){var a=s.Component,n=s.route;return[Object(t["l"])(t["b"],{name:n.meta.transition||"fade"},{default:Object(t["Q"])((function(){return[(Object(t["z"])(),Object(t["f"])(Object(t["I"])(a)))]})),_:2},1032,["name"])]})),_:1})}var A=Object(t["m"])({name:"routerFrame"});const k=b()(A,[["render",y]]);var w=k,v=Object(t["m"])({name:"defaultFrame",components:{Header:f,routerFrame:w}});n("696a");const _=b()(v,[["render",c],["__scopeId","data-v-21dd513c"]]);var O=_,C={class:"no-header-frame"};function x(s,a,n,l,e,p){var c=Object(t["H"])("router-frame");return Object(t["z"])(),Object(t["h"])("div",C,[Object(t["l"])(c)])}var I=Object(t["m"])({name:"noHeaderFrame",components:{routerFrame:w}});const E=b()(I,[["render",x]]);var S=E,B=Object(t["m"])({name:"pageFrame",components:{defaultFrame:O,noHeadFrame:S},setup:function(){var s=Object(t["E"])(!1);return{isNoHead:s}}});n("10bd");const q=b()(B,[["render",e],["__scopeId","data-v-51858244"]]);var M=q,Q=Object(t["m"])({name:"App",components:{pageFrame:M},setup:function(){console.log("shutBB")}});n("6b7d");const F=b()(Q,[["render",l]]);var z=F,T=(n("99af"),n("d3b7"),n("3ca3"),n("ddb0"),n("6c02")),D=n("f48b"),P=[].concat(D["a"]).concat([{path:"/test",name:"test",component:function(){return n.e("chunk-2d0c7964").then(n.bind(null,"50f9"))}},{path:"/",name:"Index",component:function(){return n.e("chunk-2d0c7964").then(n.bind(null,"50f9"))},redirect:"/notes/README.md"}]),U=Object(T["a"])({history:Object(T["b"])(""),routes:P}),R=U,J=n("5502"),L=Object(J["a"])({state:{},mutations:{},actions:{},modules:{}}),G=n("b85c"),N=n("2909"),H=(n("ac1f"),n("1276"),n("5869")),Y=Object(N["a"])(H.keys()),V=function(s,a){var n=a||{},t=n.components,l=void 0===t?Y:t;if(l===Y){var e,p=Object(G["a"])(Y);try{for(p.s();!(e=p.n()).done;){var c=e.value;s.use(H(c).default)}}catch(u){p.e(u)}finally{p.f()}}else{var o,r=Object(G["a"])(Y);try{for(r.s();!(o=r.n()).done;){var i,h=o.value,d=Object(G["a"])(l);try{for(d.s();!(i=d.n()).done;){var j=i.value;h.split("/")[1]===j&&s.use(H(h).default)}}catch(u){d.e(u)}finally{d.f()}}}catch(u){r.e(u)}finally{r.f()}}},K={install:V},$=(n("2c43"),n("e4cb"),Object(t["e"])(z));$.use(L).use(R).use(K),$.mount("#app")},ce23:function(s,a,n){"use strict";n.r(a);var t=n("7a23"),l={class:"markdown-body"},e=Object(t["j"])('<html><head></head><body><h1>JS 解构赋值</h1><p>ES6 新语法</p><h2>数组解构</h2><pre><code class="language-js"><span class="hljs-keyword">var</span> a, b, rest;\n[a, b] = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>];\n<span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// 10</span>\n<span class="hljs-built_in">console</span>.log(b); <span class="hljs-comment">// 20</span>\n\n<span class="hljs-comment">// 可以通过逗号跳过不需要的属性</span>\n[, b] = [<span class="hljs-number">30</span>, <span class="hljs-number">40</span>];\n\n<span class="hljs-comment">// 可以给默认值</span>\n[a, b = <span class="hljs-number">40</span>] = [<span class="hljs-number">30</span>];\n\n<span class="hljs-comment">// rest解构</span>\n[a, b, ...rest] = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>];\n<span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// 10</span>\n<span class="hljs-built_in">console</span>.log(b); <span class="hljs-comment">// 20</span>\n<span class="hljs-built_in">console</span>.log(rest); <span class="hljs-comment">// [30, 40, 50]</span>\n</code></pre><ul><li>逗号跳过属性数量无限制</li><li>rest 解构右方不可再有逗号，即 rest 必须为最后一个元素</li></ul><h2>对象解构</h2><pre><code class="language-js"><span class="hljs-keyword">var</span> { a, b } = { <span class="hljs-attr">a</span>: <span class="hljs-number">42</span>, <span class="hljs-attr">b</span>: <span class="hljs-literal">true</span> };\n\n<span class="hljs-comment">// 无声明赋值</span>\n<span class="hljs-keyword">var</span> a, b;\n({ a, b } = { <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> });\n\n<span class="hljs-comment">// 变量重命名</span>\n<span class="hljs-keyword">var</span> { <span class="hljs-attr">a</span>: d, <span class="hljs-attr">b</span>: e } = { <span class="hljs-attr">a</span>: <span class="hljs-number">42</span>, <span class="hljs-attr">b</span>: <span class="hljs-literal">true</span> };\n\n<span class="hljs-comment">// 变量默认值</span>\n<span class="hljs-keyword">var</span> { a = <span class="hljs-number">1</span>, b = <span class="hljs-number">2</span> } = {};\n\n<span class="hljs-comment">// 重命名并且给默认值</span>\n<span class="hljs-keyword">var</span> { <span class="hljs-attr">a</span>: g = <span class="hljs-number">3</span>, <span class="hljs-attr">c</span>: f = <span class="hljs-number">4</span> } = { <span class="hljs-attr">a</span>: <span class="hljs-string">&#39;a&#39;</span> };\n\n<span class="hljs-comment">// 嵌套解构</span>\n<span class="hljs-keyword">var</span> { <span class="hljs-attr">a</span>: [b = <span class="hljs-number">1</span>] = [], <span class="hljs-attr">c</span>: { d = <span class="hljs-number">5</span> } = {} } = {};\n\n<span class="hljs-comment">// 计算属性名解构重命名</span>\n<span class="hljs-keyword">let</span> key = <span class="hljs-string">&#39;z&#39;</span>;\n<span class="hljs-keyword">let</span> { [key]: foo } = { <span class="hljs-attr">z</span>: <span class="hljs-string">&#39;bar&#39;</span> };\n\n<span class="hljs-comment">// 对象的rest解构</span>\n<span class="hljs-keyword">let</span> { a, b, ...rest } = { <span class="hljs-attr">a</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">20</span>, <span class="hljs-attr">c</span>: <span class="hljs-number">30</span>, <span class="hljs-attr">d</span>: <span class="hljs-number">40</span> };\n</code></pre><ul><li>无声明赋值外侧的小括号不可省略，否则左式会被认为是代码块。</li><li>变量重命名后原名不可使用。</li><li>赋值的<code>默认值仅处理undefined</code>。</li><li>嵌套解构层级较深时须注意默认值问题，否则会因目标无法解构<code>如null</code>导致异常。</li><li>对象的 rest 解构（目前 stage 4），Rest 属性收集那些尚未被解构模式拾取的剩余可枚举属性键。</li><li><strong>对象的解构会查找原型链</strong></li></ul></body></html>',1),p=[e];function c(s,a){return Object(t["z"])(),Object(t["h"])("section",l,p)}var o=n("6b0d"),r=n.n(o);const i={},h=r()(i,[["render",c]]);a["default"]=h},ce7b:function(s,a){s.exports="data:image/gif;base64,R0lGODlhJQAlAJECAL3L2AYrTv///wAAACH/C05FVFNDQVBFMi4wAwEAAAAh+QQFCgACACwAAAAAJQAlAAACi5SPqcvtDyGYIFpF690i8xUw3qJBwUlSadmcLqYmGQu6KDIeM13beGzYWWy3DlB4IYaMk+Dso2RWkFCfLPcRvFbZxFLUDTt21BW56TyjRep1e20+i+eYMR145W2eefj+6VFmgTQi+ECVY8iGxcg35phGo/iDFwlTyXWphwlm1imGRdcnuqhHeop6UAAAIfkEBQoAAgAsEAACAAQACwAAAgWMj6nLXAAh+QQFCgACACwVAAUACgALAAACFZQvgRi92dyJcVJlLobUdi8x4bIhBQAh+QQFCgACACwXABEADAADAAACBYyPqcsFACH5BAUKAAIALBUAFQAKAAsAAAITlGKZwWoMHYxqtmplxlNT7ixGAQAh+QQFCgACACwQABgABAALAAACBYyPqctcACH5BAUKAAIALAUAFQAKAAsAAAIVlC+BGL3Z3IlxUmUuhtR2LzHhsiEFACH5BAUKAAIALAEAEQAMAAMAAAIFjI+pywUAIfkEBQoAAgAsBQAFAAoACwAAAhOUYJnAagwdjGq2amXGU1PuLEYBACH5BAUKAAIALBAAAgAEAAsAAAIFhI+py1wAIfkEBQoAAgAsFQAFAAoACwAAAhWUL4AIvdnciXFSZS6G1HYvMeGyIQUAIfkEBQoAAgAsFwARAAwAAwAAAgWEj6nLBQAh+QQFCgACACwVABUACgALAAACE5RgmcBqDB2MarZqZcZTU+4sRgEAIfkEBQoAAgAsEAAYAAQACwAAAgWEj6nLXAAh+QQFCgACACwFABUACgALAAACFZQvgAi92dyJcVJlLobUdi8x4bIhBQAh+QQFCgACACwBABEADAADAAACBYSPqcsFADs="},d4a4:function(s,a,n){s.exports=n.p+"img/writing-mode.4df1f9e7.jpg"},d836:function(s,a,n){"use strict";n.r(a),n.d(a,"install",(function(){return e}));n("b0c0");var t=n("4ce0"),l=n("4b77"),e=function(s){s.component(t["a"].name,t["a"]),s.component(l["a"].name,l["a"])};a["default"]={install:e}},d86bb:function(s,a,n){"use strict";n("7439")},d8f1:function(s,a,n){"use strict";n.r(a);var t=n("7a23"),l={class:"markdown-body"},e=Object(t["j"])('<html><head></head><body><h1>JS 中的 with 语句</h1><p>with 语句，用于扩展一个语句的作用域链。</p><p><strong><code>with</code> 会在 strict 中被禁止，不建议使用</strong></p><pre><code class="language-js"><span class="hljs-keyword">with</span> (exp) {\n\tstatement;\n}\n</code></pre><ul><li><code>exp</code> 将给定的表达式添加到在评估语句时使用的作用域链上。表达式周围的括号是必需的。</li><li><code>statement</code> 即要执行的表达式。</li></ul><h2>with 的优劣</h2><p>优点：</p><ol><li>with 语句可以在不造成性能损失的情況下，减少变量的长度（减少了指针地址查询的消耗，用变量缓存一下目标值也有同样的效果）。<strong>with 也会查原型链。</strong></li></ol><h3>使用实例</h3><p>使用 with 来解构 <code>Math</code> 对象，其中<code>PI,cos,sin</code>都是 <code>Math</code> 上的成员。</p><pre><code class="language-js"><span class="hljs-keyword">var</span> a, x, y;\n<span class="hljs-keyword">var</span> r = <span class="hljs-number">10</span>;\n\n<span class="hljs-keyword">with</span> (<span class="hljs-built_in">Math</span>) {\n\ta = PI * r * r;\n\tx = r * cos(PI);\n\ty = r * sin(PI / <span class="hljs-number">2</span>);\n}\n</code></pre><p>缺点：</p><ol><li>查找性能：with 会将 <code>exp</code> 作为作用域的顶层。程序在查找变量值时，都是先在指定的对象中查找。所以那些本来不是这个对象的属性的变量，查找起来将会很慢。<code>statement</code> 中的变量最好都是 <code>exp</code> 中的成员。</li><li>语义不明：难以排查对应的变量具体来源，且难以实现兼容。若<code>exp</code>在新版本中扩展了新的成员，会导致上层作用域原本调用的变量被覆盖导致查找失败。</li></ol><h3>语义不明实例</h3><p>如果是在 <code>ES5</code> 环境调用 <code>f([1,2,3], obj)</code>，则 with 语句中变量 <code>values</code> 将指向函数的第二个参数 <code>values</code>。但是，<code>ES6</code> 标准给 <code>Array.prototype</code> 添加了一个新属性 <code>values</code>，所有数组实例将继承这个属性。所以在 <code>ES6</code> 环境中，with 语句中变量 <code>values</code> 将查找原型链并指向 <code>[1,2,3].values</code>。</p><pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">foo, values</span>) </span>{\n\t<span class="hljs-keyword">with</span> (foo) {\n\t\t<span class="hljs-built_in">console</span>.log(values);\n\t}\n}\n</code></pre><h2>替代方案</h2><p>用变量暂存某个属性，<strong>注意 with 上的 this 指向跟直接链式调用一样，是 <code>exp</code></strong></p><pre><code class="language-js"><span class="hljs-keyword">const</span> obj = {\n\t<span class="hljs-attr">val</span>: <span class="hljs-number">1</span>,\n\t<span class="hljs-function"><span class="hljs-title">log</span>(<span class="hljs-params"></span>)</span> {\n\t\t<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.val);\n\t},\n};\n<span class="hljs-keyword">with</span> (obj) {\n\tlog(); <span class="hljs-comment">// 1;</span>\n}\n<span class="hljs-keyword">const</span> { log } = obj;\nlog(); <span class="hljs-comment">// undefined</span>\n</code></pre></body></html>',1),p=[e];function c(s,a){return Object(t["z"])(),Object(t["h"])("section",l,p)}var o=n("6b0d"),r=n.n(o);const i={},h=r()(i,[["render",c]]);a["default"]=h},d963:function(s,a,n){s.exports=n.p+"img/background-clip.d3411bba.jpg"},da65:function(s,a,n){"use strict";n.r(a);var t=n("7a23"),l=n("d963"),e=n.n(l),p={class:"markdown-body"},c=Object(t["i"])("html",null,[Object(t["i"])("head"),Object(t["i"])("body",null,[Object(t["i"])("h1",null,"background"),Object(t["i"])("p",null,"css 对背景的设置属性"),Object(t["i"])("h2",null,"background-clip"),Object(t["i"])("p",null,"对背景进行切割，控制背景的显示范围（如把背景限制在文字里）"),Object(t["i"])("p",null,[Object(t["i"])("img",{src:e.a,alt:"background-clip"})])])],-1),o=[c];function r(s,a){return Object(t["z"])(),Object(t["h"])("section",p,o)}var i=n("6b0d"),h=n.n(i);const d={},j=h()(d,[["render",r]]);a["default"]=j},db95:function(s,a,n){"use strict";var t=n("ade3"),l=(n("b0c0"),n("7a23")),e=["xlink:href"];function p(s,a,n,p,c,o){var r=Object(l["H"])("ShutBWrapper");return Object(l["z"])(),Object(l["f"])(r,{class:Object(l["s"])(["shut-b-icon",Object(t["a"])({},s.type,!s.color)])},{default:Object(l["Q"])((function(){return[Object(l["R"])((Object(l["z"])(),Object(l["h"])("svg",{style:Object(l["t"])({color:s.color})},[Object(l["i"])("use",{"xlink:href":"#"+s.name},null,8,e)],4)),[[l["N"],s.visible]])]})),_:1},8,["class"])}n("caad"),n("01af");var c=n("fc61"),o=Object(l["m"])({name:"ShutBIcon",components:{ShutBWrapper:c["a"]},props:{type:{type:String,default:"text",validator:function(s){return["text","info","success","warning","error"].includes(String(s))}},visible:{type:Boolean,default:!0},color:{type:String,default:"var(--textColor)"},name:{type:String,required:!0}}}),r=(n("6402"),n("6b0d")),i=n.n(r);const h=i()(o,[["render",p],["__scopeId","data-v-9c78efce"]]);a["a"]=h},de73:function(s,a,n){},e0c0:function(s,a,n){"use strict";n.r(a);var t=n("7a23"),l={class:"markdown-body"},e=Object(t["j"])('<html><head></head><body><h1>Python 闭包</h1><p>Python 闭包的基本形式与 JS 大致相同，通过内部定义的函数来保留外部函数的运行环境。</p><pre><code class="language-py"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>(<span class="hljs-params"><span class="hljs-built_in">id</span>=<span class="hljs-number">0</span>, name=<span class="hljs-string">&quot;bob&quot;</span></span>):</span>\n    data = <span class="hljs-string">&#39;cooool&#39;</span>\n\n    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getdata</span>():</span>\n        <span class="hljs-keyword">return</span> data\n\n    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">setdata</span>(<span class="hljs-params">value=<span class="hljs-string">&quot;cool&quot;</span></span>):</span>\n        data = value\n\n    <span class="hljs-keyword">return</span> getdata, setdata\n\n(myget, myset) = f(<span class="hljs-number">3</span>, <span class="hljs-string">&#39;tom&#39;</span>)\n\n<span class="hljs-built_in">print</span>(myget())\nmyset(<span class="hljs-string">&#39;aaaaaa&#39;</span>)\n<span class="hljs-built_in">print</span>(myget())\n\n<span class="hljs-string">&quot;&quot;&quot;输出\ncooool\ncooool\n&quot;&quot;&quot;</span>\n</code></pre><p>Python 中的闭包函数无法直接修改外层函数的栈内容，因此对于<code>data = value</code>会理解为新声明的局部变量<code>data</code>，若该语句改为<code>data = &#39;I am &#39; + data</code>则会由于声明前访问了变量而报错。 解决方案：</p><ul><li>Python3 之前只能通过将变量放入堆来解决，即将<code>data</code>包装为引用型变量，如数组。</li></ul><pre><code class="language-py"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>(<span class="hljs-params"><span class="hljs-built_in">id</span>=<span class="hljs-number">0</span>, name=<span class="hljs-string">&quot;bob&quot;</span></span>):</span>\n    data = [<span class="hljs-string">&#39;cooool&#39;</span>]<span class="hljs-comment">#将对象包装为引用型变量</span>\n\n    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getdata</span>():</span>\n        <span class="hljs-keyword">return</span> data[<span class="hljs-number">0</span>]\n\n    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">setdata</span>(<span class="hljs-params">value=<span class="hljs-string">&quot;cool&quot;</span></span>):</span>\n        data[<span class="hljs-number">0</span>] = value\n\n    <span class="hljs-keyword">return</span> getdata, setdata\n\n(myget, myset) = f(<span class="hljs-number">3</span>, <span class="hljs-string">&#39;tom&#39;</span>)\n\n<span class="hljs-built_in">print</span>(myget())\nmyset(<span class="hljs-string">&#39;aaaaaa&#39;</span>)\n<span class="hljs-built_in">print</span>(myget())\n<span class="hljs-string">&quot;&quot;&quot;输出\ncooool\naaaaaa\n&quot;&quot;&quot;</span>\n</code></pre><ul><li>Python3 新增 nonlocal 关键字，指明某变量为上层作用域的变量,用法跟 global 关键字一致。</li></ul><pre><code class="language-py"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>(<span class="hljs-params"><span class="hljs-built_in">id</span>=<span class="hljs-number">0</span>, name=<span class="hljs-string">&quot;bob&quot;</span></span>):</span>\n    data = <span class="hljs-string">&#39;cooool&#39;</span>\n\n    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getdata</span>():</span>\n        <span class="hljs-keyword">return</span> data\n\n    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">setdata</span>(<span class="hljs-params">value=<span class="hljs-string">&quot;cool&quot;</span></span>):</span>\n        <span class="hljs-keyword">nonlocal</span> data <span class="hljs-comment">#Python3的nonlocal关键字</span>\n        data = value\n\n    <span class="hljs-keyword">return</span> getdata, setdata\n\n(myget, myset) = f(<span class="hljs-number">3</span>, <span class="hljs-string">&#39;tom&#39;</span>)\n\n<span class="hljs-built_in">print</span>(myget())\nmyset(<span class="hljs-string">&#39;aaaaaa&#39;</span>)\n<span class="hljs-built_in">print</span>(myget())\n<span class="hljs-string">&quot;&quot;&quot;输出\ncooool\naaaaaa\n&quot;&quot;&quot;</span>\n</code></pre></body></html>',1),p=[e];function c(s,a){return Object(t["z"])(),Object(t["h"])("section",l,p)}var o=n("6b0d"),r=n.n(o);const i={},h=r()(i,[["render",c]]);a["default"]=h},e0c1:function(s,a,n){},e373:function(s,a,n){"use strict";n("93d2")},e510:function(s,a,n){s.exports=n.p+"img/浮动换行遇到margin.3671a572.png"},ebed:function(s,a,n){"use strict";n.r(a);var t=n("7a23"),l={class:"markdown-body"},e=Object(t["i"])("html",null,[Object(t["i"])("head"),Object(t["i"])("body",null,[Object(t["i"])("h1",null,"notes"),Object(t["i"])("p",null,"这是 CZZCZZ 学习笔记"),Object(t["i"])("p",null,"测试 webpack loader 收集 md 文件"),Object(t["i"])("p",null,"测试 webpack 自动收集依赖信息")])],-1),p=[e];function c(s,a){return Object(t["z"])(),Object(t["h"])("section",l,p)}var o=n("6b0d"),r=n.n(o);const i={},h=r()(i,[["render",c]]);a["default"]=h},edc9:function(s,a,n){"use strict";n.r(a);var t=n("7a23"),l={class:"markdown-body"},e=Object(t["j"])('<html><head></head><body><h1>JS 正则表达式</h1><p>JS 正则表达式可以通过两种方式声明：</p><pre><code class="language-js"><span class="hljs-keyword">let</span> reg = <span class="hljs-regexp">/abc/gi</span>;\n<span class="hljs-keyword">let</span> reg1 = <span class="hljs-keyword">new</span> regExp(<span class="hljs-string">&#39;ab+c&#39;</span>, <span class="hljs-string">&#39;m&#39;</span>);\n</code></pre><h2>标志 flag</h2><p>可用的 flag 包括：</p><ol><li>g，全局搜索。</li><li>i，不区分大小写搜索。</li><li>m，多行搜索。</li><li>s，允许 . 匹配换行符。</li><li>u，使用 unicode 码的模式进行匹配。</li><li>y，执行“粘性”搜索,匹配从目标字符串的当前位置开始（正则实例的<code>re.lastIndex</code>），可以使用 y 标志。</li></ol><h2>正则表达式特殊字符</h2><ol><li><code>\\</code>，转义符号，将部分符号转义为特殊字符，在<code>[]</code>内只有<code>[</code>，<code>]</code>两个字符以及<code>-</code>需要转义。</li><li><code>^</code>仅匹配字符串开头符合要求的串，若多行<code>&#39;m&#39;</code>为真则对换行符后的字符同样有效。</li><li><code>$</code>匹配字符串尾，与<code>^</code>相对。</li><li><code>{n}</code>，匹配次数修饰符，对该式前面的结果匹配<code>n</code>次。</li><li><code>{n,}</code>，匹配至少<code>n</code>次。</li><li><code>{n,m}</code>，匹配<code>n</code>至<code>m</code>次。</li><li><code>*</code>，匹配至少<code>0</code>次，即可以没有。</li><li><code>+</code>，匹配至少一次。</li><li><code>?</code>，若跟在表达式后，表示匹配<code>0</code>次或<code>1</code>次，若跟在匹配次数修饰符后，表示<code>非贪婪匹配</code>，即满足条件下尽可能匹配更短的串。</li><li><code>.</code>，匹配换行符外任意字符，若<code>&#39;s&#39;</code>为真则会匹配包括换行符的任意字符。</li><li><code>(abc)</code>，捕获括号，该内容在<code>reg.exec</code>结果集中会展示出来，也就是会被捕获。</li><li><code>(?:abc)</code>，非捕获括号，该内容在<code>reg.exec</code>结果中不会展示。</li><li><code>x|y</code>，匹配 x 或者 y。</li><li><code>[abc]</code>字符集合，可以用短横线来表示范围<code>[a-zA-Z0-9]</code>。</li><li><code>[^abc]</code>反向字符集合，与字符集合用法相近。</li></ol><h3>特殊匹配</h3><ol><li><code>[\\b]</code>，匹配一个退格。</li><li><code>\\b</code>，匹配一个边界，一个词的边界就是一个词不被另外一个“字”字符跟随的位置或者前面跟其他“字”字符的位置，例如在字母和空格之间。注意，匹配中不包括匹配的字边界。换句话说，一个匹配的词的边界的内容的长度是 0。</li><li><code>\\B</code>，匹配一个非边界，例如，/\\B../匹配&quot;noonday&quot;中的&#39;oo&#39;, 而/y\\B../匹配&quot;possibly yesterday&quot;中的&#39;yes&#39;。</li><li><code>\\cX</code>，若 X 为 A-Z 之间的字符，则匹配对应控制字符，例如，/\\cM/ 匹配字符串中的 control-M (U+000D)。</li><li><code>\\d</code>，匹配一个数字。等价于[0-9]。</li><li><code>\\B</code>，匹配一个非数字字符。等价于[^0-9]。</li><li><code>\\r</code>，匹配一个回车符。(U+000D)。</li><li><code>\\n</code>，换行符。 (U+000A)。</li><li><code>\\f</code>，换页符。(U+000C)。</li><li><code>\\s</code>，匹配一个空白字符，包括空格、制表符、换页符和换行符。等价于<code>[\\f\\n\\r\\t\\v\\u00a0\\u1680\\u180e\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]</code>。</li><li><code>\\S</code>，匹配一个非空白符。</li><li><code>\\t</code>，匹配一个水平制表符 (U+0009)。</li><li><code>\\v</code>，匹配一个垂直制表符 (U+000B)。</li><li><code>\\w</code>，匹配一个单字字符（字母、数字或者下划线）。等价于 [A-Za-z0-9_]。</li><li><code>\\W</code>，匹配一个非单字字符。等价于 [^a-za-z0-9_]。</li><li><code>\\n</code>，n 为整数，在正则表达式中，它返回最后的第 n 个子捕获匹配的子字符串(捕获的数目以左括号计数)。比如 <code>/apple(,)\\sorange\\1/</code> 匹配<code>&quot;apple, orange, cherry, peach.&quot;</code>中的<code>&#39;apple, orange,&#39;</code>。</li><li><code>\\0</code>，匹配 NULL（U+0000）字符，不要在这后面跟其它小数，因为 <code>\\0&lt;digits&gt;</code> 是一个八进制转义序列。</li><li><code>\\xhh</code>，与代码 hh 匹配字符（两个十六进制数字）。</li><li><code>\\uhhhh</code>，与代码 hhhh 匹配字符（四个十六进制数字）。</li><li><code>\\u{hhhh}</code>，（仅当设置了 u 标志时）使用 Unicode 值 hhhh 匹配字符（十六进制数字）。</li></ol><h3>断言</h3><p><strong>断言本身性能较差，同时后行断言有兼容问题（如 IE），可考虑使用分组提取需要的数据</strong></p><ol><li><code>x(?=y)</code>，先行断言，仅匹配后面有 y 的 x。</li><li><code>x(?!y)</code>，先行否定断言，仅匹配后面没有 y 的 x。</li><li><code>(?&lt;=y)x</code>，后行断言，仅匹配前面有 y 的 x。</li><li><code>(?&lt;!y)x</code>，后行否定断言，仅匹配前面没有 y 的 x。</li></ol><h3>常用方法</h3><ol><li><code>reg.exec(str)</code>，返回对字符串的第一个匹配结果以及其内部所有捕获组。<strong>该函数会根据 reg 当前对属性（如 lastIndex）进行执行</strong></li><li><code>reg.test(str)</code>，判断字符串内部是否有匹配。</li><li><code>str.match(reg)</code>，返回字符串内第一个匹配，若设置了<code>&#39;g&#39;</code>标志位则返回全部。</li><li><code>str.matchAll(reg)</code>，ES6 新增，返回全部结果，返回值为迭代器。</li><li><code>str.search(reg)</code>，返回第一个匹配的索引。</li><li><code>str.replace(reg,substr)</code>，将 str 内部第一个 reg 的匹配替换为 substr，标志位<code>&#39;g&#39;</code>使其变为全局替换。substr 可以用<code>$</code>来代表内部捕获组的结果。</li><li><code>str.split(reg)</code>，按照所有匹配对字符串进行切割，返回切割结果数组。</li></ol><h3>RegExp</h3><p>正则构造函数，上有一些全局属性。</p><ol><li>RegExp.$1...$9，正则匹配时捕获符号匹配的字串会放在对应位置（字符串函数 match 等也会处理）。</li></ol></body></html>',1),p=[e];function c(s,a){return Object(t["z"])(),Object(t["h"])("section",l,p)}var o=n("6b0d"),r=n.n(o);const i={},h=r()(i,[["render",c]]);a["default"]=h},ef90:function(s,a,n){"use strict";n.r(a);var t=n("7a23"),l={class:"markdown-body"},e=Object(t["j"])('<html><head></head><body><h1>Log 指令用于展示 git 提交记录以及其他相关信息</h1><pre><code class="language-sh">git <span class="hljs-built_in">log</span>\n</code></pre><h2>--pretty 对输出内容进行格式化</h2><pre><code class="language-sh">git <span class="hljs-built_in">log</span> --pretty=format:%xx...\n</code></pre><p>所有可用的指令</p><pre><code>%H: commit hash\n%h: 缩短的commit hash\n%T: tree hash\n%t: 缩短的 tree hash\n%P: parent hashes\n%p: 缩短的 parent hashes\n%an: 作者名字\n%aN: mailmap的作者名字 (.mailmap对应，详情参照git-shortlog(1)或者git-blame(1))\n%ae: 作者邮箱\n%aE: 作者邮箱 (.mailmap对应，详情参照git-shortlog(1)或者git-blame(1))\n%ad: 日期 (--date= 制定的格式)\n%aD: 日期, RFC2822格式\n%ar: 日期, 相对格式(1 day ago)\n%at: 日期, UNIX timestamp\n%ai: 日期, ISO 8601 格式\n%cn: 提交者名字\n%cN: 提交者名字 (.mailmap对应，详情参照git-shortlog(1)或者git-blame(1))\n%ce: 提交者 email\n%cE: 提交者 email (.mailmap对应，详情参照git-shortlog(1)或者git-blame(1))\n%cd: 提交日期 (--date= 制定的格式)\n%cD: 提交日期, RFC2822格式\n%cr: 提交日期, 相对格式(1 day ago)\n%ct: 提交日期, UNIX timestamp\n%ci: 提交日期, ISO 8601 格式\n%d: ref名称\n%e: encoding\n%s: commit信息标题\n%f: sanitized subject line, suitable for a filename\n%b: commit信息内容\n%N: commit notes\n%gD: reflog selector, e.g., refs/stash@{1}\n%gd: shortened reflog selector, e.g., stash@{1}\n%gs: reflog subject\n%Cred: 切换到红色\n%Cgreen: 切换到绿色\n%Cblue: 切换到蓝色\n%Creset: 重设颜色\n%C(...): 制定颜色, as described in color.branch.* config option\n%m: left, right or boundary mark\n%n: 换行\n%%: a raw %\n%x00: print a byte from a hex code\n%w([[,[,]]]): switch line wrapping, like the -w option of git-shortlog(1)\n</code></pre><h2>--date=</h2><p>日期输出格式化</p><pre><code>--date=relative shows dates relative to the current time, e.g. “2 hours ago”. The -local option has no effect for --date=relative.\n\n--date=local is an alias for --date=default-local.\n\n--date=iso (or --date=iso8601) shows timestamps in a ISO 8601-like format. The differences to the strict ISO 8601 format are:\n\na space instead of the T date/time delimiter\n\na space between time and time zone\n\nno colon between hours and minutes of the time zone\n\n--date=iso-strict (or --date=iso8601-strict) shows timestamps in strict ISO 8601 format.\n\n+ --date=rfc (or --date=rfc2822) shows timestamps in RFC 2822 format, often found in email messages.\n\n+ --date=short shows only the date, but not the time, in YYYY-MM-DD format.\n\n+ --date=raw shows the date as seconds since the epoch (1970-01-01 00:00:00 UTC), followed by a space, and then the timezone as an offset from UTC (a + or - with four digits; the first two are hours, and the second two are minutes). I.e., as if the timestamp were formatted with strftime(&quot;%s %z&quot;)). Note that the -local option does not affect the seconds-since-epoch value (which is always measured in UTC), but does switch the accompanying timezone value.\n\n+ --date=unix shows the date as a Unix epoch timestamp (seconds since 1970). As with --raw, this is always in UTC and therefore -local has no effect.\n\n+ --date=format:... feeds the format ... to your system strftime, except for %z and %Z, which are handled internally. Use --date=format:%c to show the date in your system locale’s preferred format. See the strftime manual for a complete list of format placeholders. When using -local, the correct syntax is --date=format-local:....\n\n--date=default is the default format, and is similar to --date=rfc2822, with a few exceptions\n</code></pre></body></html>',1),p=[e];function c(s,a){return Object(t["z"])(),Object(t["h"])("section",l,p)}var o=n("6b0d"),r=n.n(o);const i={},h=r()(i,[["render",c]]);a["default"]=h},f0b8:function(s,a,n){},f100:function(s,a,n){"use strict";n.r(a);var t=n("7a23"),l={class:"markdown-body"},e=Object(t["j"])("<html><head></head><body><h1>position 属性</h1><h2>absolute</h2><p>绝对定位，逐层往父元素找，之后的定位将基于定义了 position 属性的父元素的左上角进行。</p><h2>fixed</h2><p>基于窗口的绝对定位，之后的定位将基于窗口的左上角进行，同时不受内容滚动的影响。</p><h2>relative</h2><p>相对定位，之后的定位将基于默认定位的位置进行。</p><h2>inherit</h2><p>继承父组件的 position 属性。</p><h2>position 的 absolute 与 fixed 共同点与不同点</h2><p>共同点：</p><ol><li>改变行内元素的呈现方式，display 被置为 inline-block；</li><li>让元素脱离普通流，不占据空间；</li><li>默认会覆盖到非定位元素上</li></ol><p>不同点： absolute 的”根元素“是可以设置的，而 fixed 的”根元素“固定为浏览器窗口。 当你滚动网页，fixed 元素与浏览器窗口之间的距离是不变的。</p></body></html>",1),p=[e];function c(s,a){return Object(t["z"])(),Object(t["h"])("section",l,p)}var o=n("6b0d"),r=n.n(o);const i={},h=r()(i,[["render",c]]);a["default"]=h},f277:function(s,a,n){"use strict";n.r(a);var t=n("7a23"),l={class:"markdown-body"},e=Object(t["j"])('<html><head></head><body><h1>网络请求方式</h1><h2>XHR</h2><pre><code class="language-js"><span class="hljs-keyword">const</span> XHR = <span class="hljs-function">() =&gt;</span> {\n\t<span class="hljs-keyword">if</span> (XMLHttpRequest) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> XMLHttpRequest();\n\t<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ActiveXObject(<span class="hljs-string">&#39;Microsoft.XMLHttp&#39;</span>);\n};\n<span class="hljs-keyword">const</span> xhr = XHR();\nxhr.open(<span class="hljs-string">&#39;post&#39;</span>, urlAndqueryParamsStr);\nxhr.setRequestHeader(<span class="hljs-string">&#39;Content-Type&#39;</span>, <span class="hljs-string">&#39;application/json; charset=UTF-8&#39;</span>);\nxhr.timeout = <span class="hljs-number">5000</span>;\nxhr.ontimeout = <span class="hljs-function">() =&gt;</span> {\n\t<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#39;timeout&#39;</span>, timeout);\n\treject(<span class="hljs-string">&#39;timeout&#39;</span>);\n};\nxhr.onreadystatechange = <span class="hljs-function">() =&gt;</span> {\n\t<span class="hljs-keyword">if</span> (xhr.readyState === <span class="hljs-number">4</span>)\n\t\t<span class="hljs-keyword">if</span> ([<span class="hljs-number">200</span>, <span class="hljs-number">201</span>, <span class="hljs-number">304</span>].includes(xhr.status)) resolve(<span class="hljs-built_in">JSON</span>.parse(xhr.responseText));\n\t\t<span class="hljs-keyword">else</span> reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(xhr.statusText));\n};\nxhr.send(data);\n</code></pre><h2>axios</h2><pre><code class="language-js"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#39;axios&#39;</span>;\n\n<span class="hljs-keyword">const</span> instance = axios.create({\n\t<span class="hljs-attr">baseURL</span>: <span class="hljs-string">&#39;https://some-domain.com/api/&#39;</span>,\n\t<span class="hljs-attr">timeout</span>: <span class="hljs-number">1000</span>,\n\t<span class="hljs-attr">headers</span>: { <span class="hljs-string">&#39;X-Custom-Header&#39;</span>: <span class="hljs-string">&#39;foobar&#39;</span> },\n});\ninstance({\n\t<span class="hljs-attr">method</span>: <span class="hljs-string">&#39;post&#39;</span>,\n\t<span class="hljs-attr">url</span>: <span class="hljs-string">&#39;/user/12345&#39;</span>,\n\t<span class="hljs-attr">data</span>: {\n\t\t<span class="hljs-attr">firstName</span>: <span class="hljs-string">&#39;Fred&#39;</span>,\n\t\t<span class="hljs-attr">lastName</span>: <span class="hljs-string">&#39;Flintstone&#39;</span>,\n\t},\n});\n</code></pre><h2>fetch</h2><pre><code class="language-js">fetch(url, {\n\t<span class="hljs-attr">method</span>: <span class="hljs-string">&#39;POST&#39;</span>, <span class="hljs-comment">// or &#39;PUT&#39;</span>\n\t<span class="hljs-attr">body</span>: <span class="hljs-built_in">JSON</span>.stringify(data), <span class="hljs-comment">// data can be `string` or {object}!</span>\n\t<span class="hljs-attr">headers</span>: <span class="hljs-keyword">new</span> Headers({\n\t\t<span class="hljs-string">&#39;Content-Type&#39;</span>: <span class="hljs-string">&#39;application/json&#39;</span>,\n\t}),\n})\n\t.then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.json())\n\t.catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-built_in">console</span>.error(<span class="hljs-string">&#39;Error:&#39;</span>, error))\n\t.then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#39;Success:&#39;</span>, response));\n</code></pre><h2>取消请求</h2><pre><code class="language-js"><span class="hljs-comment">// XHR</span>\nxhr.abort();\n</code></pre><pre><code class="language-js"><span class="hljs-comment">// axios</span>\n<span class="hljs-keyword">const</span> CancelToken = axios.CancelToken;\n<span class="hljs-keyword">const</span> source = CancelToken.source();\n\naxios\n\t.get(<span class="hljs-string">&#39;/user/12345&#39;</span>, {\n\t\t<span class="hljs-attr">cancelToken</span>: source.token,\n\t})\n\t.catch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">thrown</span>) </span>{\n\t\t<span class="hljs-keyword">if</span> (axios.isCancel(thrown)) {\n\t\t\t<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#39;Request canceled&#39;</span>, thrown.message);\n\t\t} <span class="hljs-keyword">else</span> {\n\t\t\t<span class="hljs-comment">// 处理错误</span>\n\t\t}\n\t});\n\naxios.post(\n\t<span class="hljs-string">&#39;/user/12345&#39;</span>,\n\t{\n\t\t<span class="hljs-attr">name</span>: <span class="hljs-string">&#39;new name&#39;</span>,\n\t},\n\t{\n\t\t<span class="hljs-attr">cancelToken</span>: source.token,\n\t},\n);\n\n<span class="hljs-comment">// 取消请求（message 参数是可选的）</span>\nsource.cancel(<span class="hljs-string">&#39;Operation canceled by the user.&#39;</span>);\n</code></pre><pre><code class="language-js"><span class="hljs-comment">// fetch</span>\n<span class="hljs-keyword">const</span> controller = <span class="hljs-keyword">new</span> AbortController();\n<span class="hljs-keyword">const</span> signal = controller.signal;\n\nfetch(url, { signal })\n\t.then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">response</span>) </span>{\n\t\t<span class="hljs-comment">//...</span>\n\t})\n\t.catch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{\n\t\t<span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> AbortError) <span class="hljs-built_in">console</span>.error(<span class="hljs-string">&#39;cancel&#39;</span>);\n\t});\n\ncontroller.abort();\n</code></pre></body></html>',1),p=[e];function c(s,a){return Object(t["z"])(),Object(t["h"])("section",l,p)}var o=n("6b0d"),r=n.n(o);const i={},h=r()(i,[["render",c]]);a["default"]=h},f38b:function(s,a,n){"use strict";n("3c26")},f40e:function(s,a,n){"use strict";n.r(a),n.d(a,"install",(function(){return l}));n("b0c0");var t=n("1fa9"),l=function(s){s.component(t["a"].name,t["a"])};a["default"]={install:l}},f482:function(s,a,n){"use strict";n.r(a);var t=n("7a23"),l={class:"markdown-body"},e=Object(t["j"])('<html><head></head><body><h1>vue 生命周期</h1><p>从前到后共有 8 个钩子函数。</p><h2>全部生命周期</h2><h3>beforeCreate（setup）</h3><p>vue 实例创建前。</p><p>vue3 的<code>组合式 api</code> 中被 <code>setup</code> 取代。</p><h3>created（setup）</h3><p>vue 实例创建完成，此时 data 响应式变量已经初始化完成，vdom 树构建完毕。但是由于没有挂载实际 dom，因此不能操作界面元素。</p><p>vue3 的<code>组合式 api</code> 中被 <code>setup</code> 取代。</p><h3>beforeMount</h3><p>挂载前。</p><h3>mounted</h3><p>vdom 挂载到实际 dom 后，此时界面已经渲染完成，界面进入响应式更新的状态。</p><h3>beforeUpdate</h3><p>响应式数据 data 发生变化，界面更新前。</p><h3>updated</h3><p>data 变化且界面重新渲染完成后。</p><h3>beforeDestroy（beforeUnmount）</h3><p>界面关闭，vue 实例销毁前。</p><p>vue3 中换为卸载前调用。</p><h3>destroyed（unmounted）</h3><p>vue 实例销毁后。</p><p>vue3 中换为卸载后调用。</p><h3>activated</h3><p><code>keep-alive</code>包裹的组件在从不活跃态到活跃态时触发</p><h3>deactivated</h3><p><code>keep-alive</code>包裹的组件在从活跃态到不活跃态时触发</p><h2>父子节点生命周期顺序</h2><pre><code class="language-vue"><span class="hljs-tag">&lt;<span class="hljs-name">A</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">B</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">C</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">C</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">B</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">D</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">D</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">E</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">F</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">F</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">E</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">A</span>&gt;</span>\n</code></pre><p>父子节点之间的生命周期依照遍历顺序进行</p><h3>创建节点阶段</h3><ol><li><p>从父组件到子组件进行一个<code>前序</code>的<code>深度优先遍历</code>，对组件进行响应式初始化</p><ol><li>A-&gt;setup,beforeCreate,created,beforeMount</li><li>B-&gt;setup,beforeCreate,created,beforeMount</li><li>C-&gt;setup,beforeCreate,created,beforeMount</li><li>D-&gt;setup,beforeCreate,created,beforeMount</li><li>E-&gt;setup,beforeCreate,created,beforeMount</li><li>F-&gt;setup,beforeCreate,created,beforeMount</li></ol></li><li><p>从父组件到子组件进行一个<code>后序</code>的<code>深度优先遍历</code>，依次进行挂载</p><ol><li>C-&gt;mounted</li><li>B-&gt;mounted</li><li>D-&gt;mounted</li><li>F-&gt;mounted</li><li>E-&gt;mounted</li><li>A-&gt;mounted</li></ol></li></ol><h3>更新节点过程</h3><p><strong>需要注意的是如果子组件的 props 等参数没有更新的话，生命周期不一定会执行，因为节点会被重用</strong></p><ol><li><p>依旧是前序的深度优先遍历</p><ol><li>A-&gt;beforeUpdate</li><li>B-&gt;beforeUpdate</li><li>C-&gt;beforeUpdate</li><li>D-&gt;beforeUpdate</li><li>E-&gt;beforeUpdate</li><li>F-&gt;beforeUpdate</li></ol></li><li><p>然后是后序的更新完成</p><ol><li>C-&gt;updated</li><li>B-&gt;updated</li><li>D-&gt;updated</li><li>F-&gt;updated</li><li>E-&gt;updated</li><li>A-&gt;updated</li></ol></li></ol><h3>销毁节点过程</h3><ol><li>还是一样，前序 <ol><li>beforeUnmount A</li><li>beforeUnmount B</li><li>beforeUnmount C</li><li>beforeUnmount D</li><li>beforeUnmount E</li><li>beforeUnmount F</li></ol></li><li>后序 <ol><li>unmounted C</li><li>unmounted B</li><li>unmounted D</li><li>unmounted F</li><li>unmounted E</li><li>unmounted A</li></ol></li></ol></body></html>',1),p=[e];function c(s,a){return Object(t["z"])(),Object(t["h"])("section",l,p)}var o=n("6b0d"),r=n.n(o);const i={},h=r()(i,[["render",c]]);a["default"]=h},f48b:function(s,a,n){"use strict";n("d81d"),n("d3b7"),n("ddb0"),n("fb6a"),n("ac1f"),n("1276"),n("3ca3"),n("5319");var t=n("55d8"),l=t.keys().map((function(s){var a=s.slice(2),n=a.split("/").pop()||"暂无标题";return{path:a,fileName:n}})),e=[{path:"/notes",name:"notes",component:function(){return n.e("chunk-b1aac4f0").then(n.bind(null,"3cf1"))},children:l.map((function(s){var a=s.path.replace(/\//g,"_");return{path:encodeURIComponent(s.path).replace(/%2F/g,"/"),name:a,component:function(){return n("93de")("./"+s.path)}}}))}];a["a"]=e},f4fa:function(s,a,n){"use strict";n.r(a);var t=n("7a23"),l={class:"markdown-body"},e=Object(t["i"])("html",null,[Object(t["i"])("head"),Object(t["i"])("body",null,[Object(t["i"])("h1",null,"Webpack 工作原理及流程"),Object(t["i"])("p",null,"Webpack 是一个基于 nodeJs 的静态模块打包器，通过统一的依赖过程将项目下包括 JS 文件等静态资源打包为高可用的 bundle。"),Object(t["i"])("p",null,"Webpack Loader 用于收集不同类型的静态资源文件，将对应的文件内容进行预处理（如编译和语法替换）并形成 webpack 支持的模块（可通过 require 引入）。"),Object(t["i"])("p",null,"Webpack Plugin 用于在 webpack 打包过程的各个关键点对打包过程进行一个整体对修改和优化。")])],-1),p=[e];function c(s,a){return Object(t["z"])(),Object(t["h"])("section",l,p)}var o=n("6b0d"),r=n.n(o);const i={},h=r()(i,[["render",c]]);a["default"]=h},fa12:function(s,a,n){s.exports=n.p+"img/js数据类型转换.d470ad60.jpg"},faec:function(s,a,n){"use strict";n.r(a);var t=n("7a23"),l={class:"markdown-body"},e=Object(t["j"])('<html><head></head><body><h1>发布一个 Npm 包包装常用的 Cli 指令</h1><pre><code class="language-sh">npm config <span class="hljs-built_in">set</span> registry http://www.npmjs.org <span class="hljs-comment"># 源换为npm官方源，非官方源不支持注册等功能</span>\nnpm adduser <span class="hljs-comment"># 注册用户，其中需要填写用户名（登陆用）、密码、邮箱（注册验证用）</span>\nnpm login <span class="hljs-comment"># 若登陆始终不生效可以删除对应的.npmrc文件再重新登陆</span>\nnpm publish <span class="hljs-comment"># 发布</span>\nnpm config <span class="hljs-built_in">set</span> registry https://registry.npm.taobao.org <span class="hljs-comment"># 切换阿里源</span>\n</code></pre><h2>package.json 配置</h2><h3>main</h3><p>包入口，即引用该包时<code>require(&#39;my-pack&#39;)</code>时默认引入的 js 入口</p><h3>bin</h3><p>指明要创建的可执行文件，及其对应的入口 js 文件</p><pre><code class="language-json"><span class="hljs-string">&quot;bin&quot;</span>: {\n\t<span class="hljs-attr">&quot;nsh&quot;</span>: <span class="hljs-string">&quot;./dist/index.js&quot;</span>\n}\n</code></pre></body></html>',1),p=[e];function c(s,a){return Object(t["z"])(),Object(t["h"])("section",l,p)}var o=n("6b0d"),r=n.n(o);const i={},h=r()(i,[["render",c]]);a["default"]=h},fc61:function(s,a,n){"use strict";var t=n("7a23"),l={class:"shut-b-wrapper"};function e(s,a,n,e,p,c){return Object(t["z"])(),Object(t["h"])("div",l,[Object(t["G"])(s.$slots,"default",{},void 0,!0)])}var p=n("5fd2"),c=Object(t["m"])({name:"ShutBWrapper",props:{theme:{type:Object,default:function(){return p["a"]}},fontSizeName:{type:String,default:"fontSize"},fontSize:{}},setup:function(s){Object(t["x"])((function(){Object(p["b"])(s.theme)||(Object(p["d"])(s.theme),console.log("shutBTheme init"))}))}}),o=(n("a231"),n("6b0d")),r=n.n(o);const i=r()(c,[["render",e],["__scopeId","data-v-1e4a7564"]]);a["a"]=i}});